/*
 * $Id$
 *
 * $Log$
 * Revision 1.1  1996/03/01 11:38:58  mclareni
 * Initial revision
 *
 */
#include "paw/pilot.h"
#if !defined(CERNLIB_QP)
/*CMZ :          10/01/96  17.22.51  by  O.Couet*/
/*-- Author :*/
/*
 * This file has been generated by the KUIP compiler.  Do NOT change it!
 *
 * KUIP header: 950303      Generation date: Wed Jan 10 17:22:48 1996
 *
 * Input file: pawcdf.txt
 */

#if (!defined(F77_LCASE)) && (!defined(F77_UCASE)) && (!defined(F77_USCORE))
#  if defined(__EXTENDED__) && (!defined(IBM370)) && (!defined(_IBMR2))
#    define IBM370
#  endif
#  if defined(CRAY) || defined(IBM370) || defined(vms)
#    define F77_UCASE
#  else
#    if ( defined(apollo) || defined(__apollo) ) && defined(APOFTN)
#      define F77_LCASE
#    else
#      define F77_USCORE
#    endif
#  endif
#endif

typedef int     IntFunc();
typedef char*   CharFunc();
typedef char** pCharFunc();
typedef void    SUBROUTINE();
#ifdef IBM370
#  pragma linkage(SUBROUTINE,FORTRAN)
#endif

extern void klnkmenu();
extern void klnkbrcl();
extern void klnkkmcl();
extern void klnkicon();
extern void klnkbutt();

typedef unsigned long KmPixmap; /* Pixmap from <X11/X.h>                   */
 typedef void *KmWidget;         /* Widget from <X11/Intrinsic.h>           */
 typedef void *KmCalldata;       /* XmAnyCallbackStruct from <Motif/Xm.h>   */
                                 /*                                         */
 typedef enum {                  /*                                         */
   BRACT_OPEN = 0,               /*                                         */
   BRACT_ROOT = 1,               /*                                         */
   BRACT_CONT = 2,               /*                                         */
   BRACT_GRAF = 3                /*                                         */
 } BrActTag;                     /*                                         */
                                 /*                                         */
 typedef enum {                  /*                                         */
   BrActUpdate    = 0x01,        /* browser window has to be updated ('!')  */
   BrActSeparator = 0x02,        /* put separator in menu ('/')             */
   BrActToggle    = 0x04,        /* register as toggle button               */
   BrActToggleOn  = 0x08,        /* toggle state is on                      */
   BrActSensitive = 0x10         /* button is sensitive                     */
 } BrActFlag;                    /*                                         */
                                 /*                                         */

typedef struct _BrAction {      /*                                         */
  struct _BrAction *next;       /* link to next action binding             */
  BrActFlag   flags;            /*                                         */
  char       *text;             /* text line in menu                       */
  char       *user_text;        /* user text overriding CDF text (malloced)*/
  char       *accel;            /* accelerator                             */
  char       *exec;             /* action commands                         */
  SUBROUTINE *call_F;           /* action routine                          */
  IntFunc    *call_C;           /* action function                         */
  BrActTag    tag;              /* for which window the action is defined  */
  struct _BrClass *class;       /* pointer to BrClass in case of open menu */
 } BrAction;                     /*                                         */
                                 /*                                         */
 typedef struct _BrClass {       /*                                         */
   struct _BrClass *next;        /* link to next browsable class            */
   char       *name;             /* unique identifier name                  */
   char       *title;            /* title for popup menu (maybe NULL)       */
   SUBROUTINE *scan_km_F;        /* user function scanning the directory    */
   pCharFunc  *scan_km_C;        /* user function scanning the directory    */
   SUBROUTINE *scan_br_F;        /* user function scanning for browsables   */
   pCharFunc  *scan_br_C;        /* user function scanning for browsables   */
   BrAction   *root;             /* list of actions in root window          */
   BrAction   *open;             /* list of actions in open menu            */
 } BrClass;                      /*                                         */
                                 /*                                         */

typedef struct _KmIcon {        /*                                         */
  struct _KmIcon *next;         /* link to next icon                       */
  char       *name;             /* unique identifier name                  */
  int         width;            /* width of the pixmap                     */
  int         height;           /* height of the pixmap                    */
  char       *bitmap;           /* bitmap data                             */
  KmPixmap    pix;              /* filled in Motif part                    */
  KmPixmap    hi_pix;           /* high lighted pixmap                     */
 } KmIcon;                       /*                                         */
                                 /*                                         */
 typedef struct _KmClass {       /*                                         */
   struct _KmClass *next;        /* link to next object class               */
   int         is_dir;           /* flag if class has is a directory        */
   char       *name;             /* unique identifier name                  */
   char       *title;            /* title for popup menu (maybe NULL)       */
   char       *big_icon;         /* name of the big icon                    */
   KmIcon     *bicon;            /* pointer to the big icon structure       */
   char       *sm_icon;          /* name of the small icon                  */
   KmIcon     *sicon;            /* pointer to the small icon structure     */
   SUBROUTINE *user_icon_F;      /* user function to return icon bitmap     */
   IntFunc    *user_icon_C;      /* user function to return icon bitmap     */
   BrAction   *cont;             /* list of actions in content window       */
   BrAction   *graf;             /* list of actions in graphics window      */
   int         obj_count;        /* number of objects in content window     */
 } KmClass;                      /*                                         */
                                 /*                                         */

typedef enum {                  /*                                         */
  KmButtSensitive       = 0x00, /* sensitive button                        */
  KmButtNonSensitive    = 0x01, /* non-sensitive button ('NS')             */
  KmButtToggleSensitive = 0x02, /* toggle-sensitive button ('TS')          */
  KmButtSensitivityMask = 0x03, /* mask for sensitivity type               */
  KmButtSeparator       = 0x04, /* put separator in menu ('/')             */
  KmButtBrowser         = 0x08  /* button is in main browser ('BR')        */
 } KmButtFlag;                   /*                                         */
                                 /*                                         */
 typedef struct _KmButton {      /*                                         */
   struct _KmButton *next;       /* button label or menu item               */
   char       *menu;             /* menu name or NULL for buttons           */
   char       *label;            /* button label or menu item               */
   SUBROUTINE *call_F;           /* callback routine (FORTRAN)              */
   IntFunc    *call_C;           /* callback routine (C)                    */
   char       *action;           /* name of callback routine                */
   char       *mnemo;            /* button mnemonic                         */
   char       *accel;            /* button accelerator                      */
   char       *accel_text;       /* button accelerator text                 */
   KmButtFlag  flags;            /* sensitivity type etc.                   */
   KmWidget    widget;           /* Motif widget ID                         */
 } KmButton;                     /*                                         */
                                 /*                                         */

extern struct {                        /*
    */   /* indirect calls to avoid linking HIGZ
    */   IntFunc    *graf_info_C;      /* pass display, open and close
 (ixmotif)  */   SUBROUTINE *graf_size_F;      /* resize window (IGRSIZ)
            */   SUBROUTINE *graf_pick_F;      /* identifying graphics objects
 (IGOBJ)    */   SUBROUTINE *graf_attr_F;      /* set attributes (IGSET)
            */   SUBROUTINE *graf_close_F;     /* close workstation (ICLWK)
            */   /* optional routines for Motif customization
            */   pCharFunc  *user_FallBk_C;    /* get application fallbacks
            */   IntFunc    *user_TopWid_C;    /* pass toplevel widget
 identifiers        */ } klnkaddr;                     /*
                    */

typedef enum {                  /*                                         */
  KmFLAG_FORGET = 0x01,         /* last value is not kept for Motif panels */
  KmFLAG_MINUS  = 0x02,         /* -VALUE is not an abbrev for CHOPT=VALUE */
  KmFLAG_QUOTE  = 0x04,         /* do not remove quotes                    */
  KmFLAG_VARARG = 0x08,         /* append additional args to this param.   */
  KmFLAG_CONST  = 0x10,         /* do not allow to assign a value          */
  KmFLAG_HIDDEN = 0x20,         /* do not show in menus                    */
  KmFLAG_SEPARATE = 0x40        /* treat arguments as separate tokens      */
 } KmParFlag;                    /*                                         */
                                 /*                                         */
 typedef enum {                  /*                                         */
   KmTYPE_CHAR   = 'C',          /* character string                        */
   KmTYPE_FILE   = 'F',          /* file name                               */
   KmTYPE_INT    = 'I',          /* integer                                 */
   KmTYPE_OPTION = 'O',          /* option                                  */
   KmTYPE_REAL   = 'R'           /* real                                    */
 } KmParType;                    /*                                         */
                                 /*                                         */

typedef struct {                /* file name                               */
  char         *filter_default; /* filter wildcard                         */
  char         *filter_current; /* current filter                          */
 } KmParFile;                    /*                                         */
                                 /*                                         */
 typedef struct {                /*                                         */
   char         *range_lower;    /* lower value of range                    */
   char         *range_upper;    /* upper value of range                    */
   char         *slider_lower;   /* lower limit for slider                  */
   char         *slider_upper;   /* upper limit for slider                  */
   int           decimals;       /* number of decimals used for slider      */
 } KmParInt;                     /*                                         */
                                 /*                                         */
 typedef struct {                /* option                                  */
   char        **text;           /* explanations (parallel to range_value)  */
   int          *mutex;          /* mutex group to which text belongs       */
   int          *radio;          /* radio group to which text belongs       */
 } KmParOption;                  /*                                         */
                                 /*                                         */

typedef KmParInt KmParReal;     /* real and int have the same fields       */
                                /*                                         */
 typedef struct {                /*                                         */
   char         *name;           /* parameter name                          */
   int           abbrev;         /* minimum length that name is recognized  */
   char         *prompt;         /* prompt string                           */
   char         *dfault;         /* default value                           */
   char         *last;           /* last value for Motif panel (malloced)   */
   int           width;          /* width of input field                    */
   int           range_count;    /* number of items in range_value          */
   char        **range_value;    /* list of allowed values                  */
   int           select_count;   /* number of items in select_count         */
   char        **select_value;   /* list of values for selection box        */
   KmParFlag     flags;          /* special flags                           */
   KmParType     type;           /* parameter type                          */
   void        *ptype;           /* structure pointer selected by type      */
 } KmParameter;                  /*                                         */
                                 /*                                         */

typedef struct _KmCommand {     /*                                         */
  struct _KmCommand *next;      /* link to next command                    */
  char         *path;           /* command path                            */
  char         *name;           /* command name                            */
  int           hidden;         /* flag if command is invisible            */
  int           level;          /* depth of submenus                       */
  int           total;          /* total number of parameters              */
  int           mandatory;      /* number of mandatory parameters          */
  KmParameter **par;            /* list of total parameter descriptions    */
  int           list_par;       /* index+1 of parameter taking a list      */
  int           xcount;         /* count number of action calls            */
  SUBROUTINE   *action_F;       /* action routine                          */
  IntFunc      *action_C;       /* action routine                          */
  SUBROUTINE   *user_help_F;    /* user help routine                       */
  pCharFunc    *user_help_C;    /* user help routine                       */
  int          nguidance;       /* number of lines in guidance text        */
  char        **guidance;       /* help text                               */
  int          nkeyword;        /* number of lines for keywords            */
  char        **keyword;        /* list of keywords                        */
  int          nhlink;          /* number of lines for links               */
  char        **hlink;          /* list of links                           */
  int           argc;           /* number of arguments entered             */
  char        **argv;           /* argc argument values                    */
  char         *argline;        /* argument line as entered                */
  int          *argoffs;        /* argc offsets into argline for KUGETE    */
 } KmCommand;                    /*                                         */
                                 /*                                         */

typedef struct _KmMenu {        /*                                         */
  struct _KmMenu *next;         /* link to next menu                       */
  struct _KmMenu *down;         /* link to submenu                         */
  char         *path;           /* path of parent menu                     */
  char         *name;           /* menu name                               */
  int           level;          /* depth of submenus                       */
  KmCommand    *cmds;           /* link to first command                   */
  int          nguidance;       /* number of lines in guidance text        */
  char        **guidance;       /* help text                               */
  int          nkeyword;        /* number of lines for keywords            */
  char        **keyword;        /* list of keywords                        */
  int          nhlink;          /* number of lines for links               */
  char        **hlink;          /* list of links                           */
 } KmMenu;                       /*                                         */
                                 /*                                         */
 extern void klnkbrcl();         /*                                         */
 extern void klnkicon();         /*                                         */
 extern void klnkkmcl();         /*                                         */
 extern void klnkmenu();         /*                                         */
                                 /*                                         */

#ifdef F77_LCASE
#  define hisdef_ hisdef
#  define pahist_ pahist
#  define pahbok_ pahbok
#  define pahio_ pahio
#  define pahfit_ pahfit
#  define pahope_ pahope
#  define pahvec_ pahvec
#  define pahset_ pahset
#  define pafith_ pafith
#endif

#ifdef F77_UCASE
#  define hisdef_ HISDEF
#  define pahist_ PAHIST
#  define pahbok_ PAHBOK
#  define pahio_ PAHIO
#  define pahfit_ PAHFIT
#  define pahope_ PAHOPE
#  define pahvec_ PAHVEC
#  define pahset_ PAHSET
#  define pafith_ PAFITH
#endif

#ifdef IBM370
#  pragma linkage(HISDEF,FORTRAN)
#  pragma linkage(PAHIST,FORTRAN)
#  pragma linkage(PAHBOK,FORTRAN)
#  pragma linkage(PAHIO,FORTRAN)
#  pragma linkage(PAHFIT,FORTRAN)
#  pragma linkage(PAHOPE,FORTRAN)
#  pragma linkage(PAHVEC,FORTRAN)
#  pragma linkage(PAHSET,FORTRAN)
#  pragma linkage(PAFITH,FORTRAN)
#endif

extern void hisdef_();
extern void pahist_();
extern void pahbok_();
extern void pahio_();
extern void pahfit_();
extern void pahope_();
extern void pahvec_();
extern void pahset_();
extern void pafith_();

void hisdef_()
{

static KmParameter _HISTOGRAM_2D_PLOT_CONTOUR_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_2D_PLOT_CONTOUR_NLEVEL_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_2D_PLOT_CONTOUR_NLEVEL = { "NLEVEL", 6,
 "Number of contour lines", "10", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_2D_PLOT_CONTOUR_NLEVEL_type };
static char *_HISTOGRAM_2D_PLOT_CONTOUR_CHOPT_range[] = { "0", "1", "2", "3",
 "S" };
static char *_HISTOGRAM_2D_PLOT_CONTOUR_CHOPT_text[] = {
 "Use colour to distinguish contours.",
 "Use line style to distinguish contours.",
 "Line style and colour are the same for all contours.",
 "The contour is drawn with filled colour levels. The levels are equidistant.\
 The color indices are taken in the current palette (defined with the command\
 PALETTE). If the number of levels (NLEVEL) is greater than the number of\
 entries in the current palette, the palette is explore again from the\
 beginning in order to reach NLEVEL.",
 "Superimpose plot on top of existing picture." };
static KmParOption _HISTOGRAM_2D_PLOT_CONTOUR_CHOPT_type = {
 _HISTOGRAM_2D_PLOT_CONTOUR_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_2D_PLOT_CONTOUR_CHOPT = { "CHOPT", 5, "Options",
 "1", (char*)0, 8, 5, _HISTOGRAM_2D_PLOT_CONTOUR_CHOPT_range, 5,
 _HISTOGRAM_2D_PLOT_CONTOUR_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_2D_PLOT_CONTOUR_CHOPT_type };
static KmParameter _HISTOGRAM_2D_PLOT_CONTOUR_PARAM = { "PARAM", 5,
 "Vector of contour levels", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_2D_PLOT_CONTOUR_parameters[] = {
 &_HISTOGRAM_2D_PLOT_CONTOUR_ID, &_HISTOGRAM_2D_PLOT_CONTOUR_NLEVEL,
 &_HISTOGRAM_2D_PLOT_CONTOUR_CHOPT, &_HISTOGRAM_2D_PLOT_CONTOUR_PARAM };
static char *_HISTOGRAM_2D_PLOT_CONTOUR_guidance[] = {
 "Draw a contour plot from a 2-Dim histogram.",
 "If PARAM is not given, contour levels are equidistant.",
 "If given, the vector PARAM may contain up to 50 values.", "", "Example:",
 "    Fun2 2 x*y 40 0 1 40 0 1 ' '   | Create a 2D histogram",
 "    V/Cr PAR(5) R .1 .11 .3 .31 .5 | Define the contours",
 "    Contour 2 5 ! PAR              | Draw the non equidistant contours", "",
 "Note: The non equidistant contours are not implemented with the option '3'."
 };
static KmCommand _HISTOGRAM_2D_PLOT_CONTOUR = {  (KmCommand*)0,
 "/HISTOGRAM/2D_PLOT/CONTOUR", "CONTOUR", 0, 2, 4, 0,
 _HISTOGRAM_2D_PLOT_CONTOUR_parameters, 1, 0, pahist_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 10, _HISTOGRAM_2D_PLOT_CONTOUR_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_2D_PLOT_SURFACE_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_2D_PLOT_SURFACE_THETA_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_2D_PLOT_SURFACE_THETA = { "THETA", 5,
 "Angle THETA in degrees", "30.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_2D_PLOT_SURFACE_THETA_type };
static KmParReal   _HISTOGRAM_2D_PLOT_SURFACE_PHI_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_2D_PLOT_SURFACE_PHI = { "PHI", 3,
 "Angle PHI in degrees", "30.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_2D_PLOT_SURFACE_PHI_type };
static char *_HISTOGRAM_2D_PLOT_SURFACE_CHOPT_range[] = { "", "1", "2", "3",
 "4" };
static char *_HISTOGRAM_2D_PLOT_SURFACE_CHOPT_text[] = {
 "Hidden line algorithm is used.",
 "Hidden surface algorithm is used and each cell is filled with a colour\
 corresponding to the Z value (or grey scale with PostScript). It is possible\
 to change the set of colours used with SET HCOL ic.L where L define a palette\
 of colours given by the command ATT/PALETTE.",
 "Similar to option '1' except that the cell lines are not drawn. This is very\
 useful to draw contour plots with colours if THETA=90 and PHI=0.",
 "Surface is drawn with a contour plot in color on top. The contour plot is\
 drawn with the colors defined with the command PALETTE.",
 "Surface is drawn with Gouraud shading." };
static KmParOption _HISTOGRAM_2D_PLOT_SURFACE_CHOPT_type = {
 _HISTOGRAM_2D_PLOT_SURFACE_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_2D_PLOT_SURFACE_CHOPT = { "CHOPT", 5, "Options",
 " ", (char*)0, 8, 5, _HISTOGRAM_2D_PLOT_SURFACE_CHOPT_range, 5,
 _HISTOGRAM_2D_PLOT_SURFACE_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_2D_PLOT_SURFACE_CHOPT_type };
static KmParameter *_HISTOGRAM_2D_PLOT_SURFACE_parameters[] = {
 &_HISTOGRAM_2D_PLOT_SURFACE_ID, &_HISTOGRAM_2D_PLOT_SURFACE_THETA,
 &_HISTOGRAM_2D_PLOT_SURFACE_PHI, &_HISTOGRAM_2D_PLOT_SURFACE_CHOPT };
static char *_HISTOGRAM_2D_PLOT_SURFACE_guidance[] = {
 "Draw a surface plot from 2-Dim or 1-Dim histograms.",
 "With this command it is possible to draw color contour plots:",
 "    PAW > ATT/PAL 1 3 2 3 4   | Define the palette 1 with 3 elements",
 "    PAW > SET HCOL 0.1        | Set the list 1 as colours for histograms",
 "    PAW > SET NDVZ 4          | Set the number of Z divisions to 4",
 "    PAW > SURF id 90 0 2      | Draw the contour", "",
 "Note: - The options 1 to 4 must be used only on selective erase devices." };
static KmCommand _HISTOGRAM_2D_PLOT_SURFACE = { &_HISTOGRAM_2D_PLOT_CONTOUR,
 "/HISTOGRAM/2D_PLOT/SURFACE", "SURFACE", 0, 2, 4, 0,
 _HISTOGRAM_2D_PLOT_SURFACE_parameters, 1, 0, pahist_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 8, _HISTOGRAM_2D_PLOT_SURFACE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_2D_PLOT_LEGO_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_2D_PLOT_LEGO_THETA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_2D_PLOT_LEGO_THETA = { "THETA", 5,
 "Angle THETA in degrees", "30.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_2D_PLOT_LEGO_THETA_type };
static KmParReal   _HISTOGRAM_2D_PLOT_LEGO_PHI_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_2D_PLOT_LEGO_PHI = { "PHI", 3,
 "Angle PHI in degrees", "30.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_2D_PLOT_LEGO_PHI_type };
static char *_HISTOGRAM_2D_PLOT_LEGO_CHOPT_range[] = { "", "1", "2" };
static char *_HISTOGRAM_2D_PLOT_LEGO_CHOPT_text[] = {
 "Hidden line algorithm is used.",
 "Hidden surface algorithm is used. The colour of the lego is given by SET\
 HCOL CI where CI is a colour index. For the top and the sides of the lego the\
 same hue is used but with a different light.",
 "Hidden surface algorithm is used. The colour of each bar changes according\
 to the value of Z. It is possible to change the set of colours used with SET\
 HCOL c.L where L define a palette of colours given by the command\
 ATT/PALETTE." };
static KmParOption _HISTOGRAM_2D_PLOT_LEGO_CHOPT_type = {
 _HISTOGRAM_2D_PLOT_LEGO_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_2D_PLOT_LEGO_CHOPT = { "CHOPT", 5, "Options",
 " ", (char*)0, 8, 3, _HISTOGRAM_2D_PLOT_LEGO_CHOPT_range, 3,
 _HISTOGRAM_2D_PLOT_LEGO_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_2D_PLOT_LEGO_CHOPT_type };
static KmParameter *_HISTOGRAM_2D_PLOT_LEGO_parameters[] = {
 &_HISTOGRAM_2D_PLOT_LEGO_ID, &_HISTOGRAM_2D_PLOT_LEGO_THETA,
 &_HISTOGRAM_2D_PLOT_LEGO_PHI, &_HISTOGRAM_2D_PLOT_LEGO_CHOPT };
static char *_HISTOGRAM_2D_PLOT_LEGO_guidance[] = {
 "Draw a lego plot from 2-Dim or 1-Dim histograms.",
 "It is also possible to produce stacked lego plots. A stacked lego plot",
 "consists of a superimposition of several histograms, whose identifiers are",
 "given in the command LEGO separated by the character '+'.",
 " PAW > LEGO ID1+ID2+ID3    | Maximum number of ID's is 10. The colours of",
 "                           | each IDn is given by the command ATT/PALETTE",
 "Examples:",
 " PAW > SET HCOL 2          | The colour the histogram is 2 (red)",
 " PAW > LEGO 20             | Display a lego with lines",
 " PAW > LEGO 20 ! ! 1       | Display a lego with different lights",
 " PAW > LEGO 20 ! ! 2       | Display a lego with colours",
 " PAW > PALETTE  1 3 2 3 4  | Create the palette number 1 with 3",
 "                           | elements: 2,3",
 " PAW > SET HCOL 0.1        | The subsequent stack lego plots will use list\
 1", " PAW > LEGO 10+20+30       | Plot a stack of lego plots with lines",
 " PAW > LEGO 10+20+30 ! ! 1 | Plot a stack of lego plots with light",
 "Notes: - The commands OPTION BAR, SET BARW and SET BARO act on lego plots",
 "       - The options 1 and 2 must be used only on selective erase",
 "         devices." };
static KmCommand _HISTOGRAM_2D_PLOT_LEGO = { &_HISTOGRAM_2D_PLOT_SURFACE,
 "/HISTOGRAM/2D_PLOT/LEGO", "LEGO", 0, 2, 4, 0,
 _HISTOGRAM_2D_PLOT_LEGO_parameters, 1, 0, pahist_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 19, _HISTOGRAM_2D_PLOT_LEGO_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_TITLE_GLOBAL_CHTITL = { "CHTITL", 6,
 "Global title", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static char *_HISTOGRAM_CREATE_TITLE_GLOBAL_CHOPT_range[] = { "", "U" };
static char *_HISTOGRAM_CREATE_TITLE_GLOBAL_CHOPT_text[] = {
 "The global title is plotted at the top of each picture.",
 "If the option 'UTIT' is on, a user title is plotted at the bottom of each\
 histogram." };
static KmParOption _HISTOGRAM_CREATE_TITLE_GLOBAL_CHOPT_type = {
 _HISTOGRAM_CREATE_TITLE_GLOBAL_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_CREATE_TITLE_GLOBAL_CHOPT = { "CHOPT", 5,
 "Options", " ", (char*)0, 8, 2, _HISTOGRAM_CREATE_TITLE_GLOBAL_CHOPT_range,
 2, _HISTOGRAM_CREATE_TITLE_GLOBAL_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_CREATE_TITLE_GLOBAL_CHOPT_type };
static KmParameter *_HISTOGRAM_CREATE_TITLE_GLOBAL_parameters[] = {
 &_HISTOGRAM_CREATE_TITLE_GLOBAL_CHTITL, &_HISTOGRAM_CREATE_TITLE_GLOBAL_CHOPT
 };
static char *_HISTOGRAM_CREATE_TITLE_GLOBAL_guidance[] = {
 "Set the global title.",
 "The size and the Y position of the global title may be changed",
 "by the commands SET GSIZ and SET YGTI respectively. The size and",
 "the Y position of the user title may be changed by the commands",
 "SET TSIZ and SET YHTI respectively." };
static KmCommand _HISTOGRAM_CREATE_TITLE_GLOBAL = {  (KmCommand*)0,
 "/HISTOGRAM/CREATE/TITLE_GLOBAL", "TITLE_GLOBAL", 0, 2, 2, 0,
 _HISTOGRAM_CREATE_TITLE_GLOBAL_parameters, 0, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _HISTOGRAM_CREATE_TITLE_GLOBAL_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_BANY_ID = { "ID", 2,
 "Histogram (2-Dim) Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_CREATE_BANY_XMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_BANY_XMIN = { "XMIN", 4, "Low edge in X",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_HISTOGRAM_CREATE_BANY_XMIN_type };
static KmParReal   _HISTOGRAM_CREATE_BANY_XMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_BANY_XMAX = { "XMAX", 4,
 "Upper edge in X", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_BANY_XMAX_type };
static KmParameter *_HISTOGRAM_CREATE_BANY_parameters[] = {
 &_HISTOGRAM_CREATE_BANY_ID, &_HISTOGRAM_CREATE_BANY_XMIN,
 &_HISTOGRAM_CREATE_BANY_XMAX };
static char *_HISTOGRAM_CREATE_BANY_guidance[] = {
 "Create a projection onto the y axis, in a band of x. Several bands can be",
 "defined on the one histogram. The projection may be filled with",
 "Histo/Project.", " To plot band 1 in Y of ID type:",
 "   PAW > HI/PLOT ID.BANY.1" };
static KmCommand _HISTOGRAM_CREATE_BANY = { &_HISTOGRAM_CREATE_TITLE_GLOBAL,
 "/HISTOGRAM/CREATE/BANY", "BANY", 0, 2, 3, 3,
 _HISTOGRAM_CREATE_BANY_parameters, 1, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _HISTOGRAM_CREATE_BANY_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_BANX_ID = { "ID", 2,
 "Histogram (2-Dim) Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_CREATE_BANX_YMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_BANX_YMIN = { "YMIN", 4, "Low edge in Y",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_HISTOGRAM_CREATE_BANX_YMIN_type };
static KmParReal   _HISTOGRAM_CREATE_BANX_YMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_BANX_YMAX = { "YMAX", 4,
 "Upper edge in Y", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_BANX_YMAX_type };
static KmParameter *_HISTOGRAM_CREATE_BANX_parameters[] = {
 &_HISTOGRAM_CREATE_BANX_ID, &_HISTOGRAM_CREATE_BANX_YMIN,
 &_HISTOGRAM_CREATE_BANX_YMAX };
static char *_HISTOGRAM_CREATE_BANX_guidance[] = {
 "Create a projection onto the x axis, in a band of y. Several bands can be",
 "defined on the one histogram. The projection may be filled with",
 "Histo/Project.", " To plot band 1 in X of ID type:",
 "   PAW > HI/PLOT ID.BANX.1" };
static KmCommand _HISTOGRAM_CREATE_BANX = { &_HISTOGRAM_CREATE_BANY,
 "/HISTOGRAM/CREATE/BANX", "BANX", 0, 2, 3, 3,
 _HISTOGRAM_CREATE_BANX_parameters, 1, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _HISTOGRAM_CREATE_BANX_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_SLIY_ID = { "ID", 2,
 "Histogram (2-Dim) Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_CREATE_SLIY_NSLICES_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_SLIY_NSLICES = { "NSLICES", 7,
 "Number of slices", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_CREATE_SLIY_NSLICES_type };
static KmParameter *_HISTOGRAM_CREATE_SLIY_parameters[] = {
 &_HISTOGRAM_CREATE_SLIY_ID, &_HISTOGRAM_CREATE_SLIY_NSLICES };
static char *_HISTOGRAM_CREATE_SLIY_guidance[] = {
 "Create projections onto the y axis, in x-slices.",
 "The projection may be filled with Histo/Project.",
 " To plot slice 2 in Y of ID type:", "   PAW > HI/PLOT ID.SLIY.2" };
static KmCommand _HISTOGRAM_CREATE_SLIY = { &_HISTOGRAM_CREATE_BANX,
 "/HISTOGRAM/CREATE/SLIY", "SLIY", 0, 2, 2, 2,
 _HISTOGRAM_CREATE_SLIY_parameters, 1, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _HISTOGRAM_CREATE_SLIY_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_SLIX_ID = { "ID", 2,
 "Histogram (2-Dim) Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_CREATE_SLIX_NSLICES_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_SLIX_NSLICES = { "NSLICES", 7,
 "Number of slices", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_CREATE_SLIX_NSLICES_type };
static KmParameter *_HISTOGRAM_CREATE_SLIX_parameters[] = {
 &_HISTOGRAM_CREATE_SLIX_ID, &_HISTOGRAM_CREATE_SLIX_NSLICES };
static char *_HISTOGRAM_CREATE_SLIX_guidance[] = {
 "Create projections onto the x axis, in y-slices.",
 "The projection may be filled with Histo/Project.",
 " To plot slice 3 in X of ID type:", "   PAW > HI/PLOT ID.SLIX.3" };
static KmCommand _HISTOGRAM_CREATE_SLIX = { &_HISTOGRAM_CREATE_SLIY,
 "/HISTOGRAM/CREATE/SLIX", "SLIX", 0, 2, 2, 2,
 _HISTOGRAM_CREATE_SLIX_parameters, 1, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _HISTOGRAM_CREATE_SLIX_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_PROY_ID = { "ID", 2,
 "Histogram (2-Dim) Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_CREATE_PROY_parameters[] = {
 &_HISTOGRAM_CREATE_PROY_ID };
static char *_HISTOGRAM_CREATE_PROY_guidance[] = {
 "Create the projection onto the y axis.",
 "The projection may be filled with Histo/Project.",
 " To plot projection Y of ID type:", "   PAW > HI/PLOT ID.PROY" };
static KmCommand _HISTOGRAM_CREATE_PROY = { &_HISTOGRAM_CREATE_SLIX,
 "/HISTOGRAM/CREATE/PROY", "PROY", 0, 2, 1, 1,
 _HISTOGRAM_CREATE_PROY_parameters, 1, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _HISTOGRAM_CREATE_PROY_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_PROX_ID = { "ID", 2,
 "Histogram (2-Dim) Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_CREATE_PROX_parameters[] = {
 &_HISTOGRAM_CREATE_PROX_ID };
static char *_HISTOGRAM_CREATE_PROX_guidance[] = {
 "Create the projection onto the x axis.",
 "The projection is not filled until the Histo/Project command is executed.",
 " To plot projection X of ID type:", "   PAW > HI/PLOT ID.PROX" };
static KmCommand _HISTOGRAM_CREATE_PROX = { &_HISTOGRAM_CREATE_PROY,
 "/HISTOGRAM/CREATE/PROX", "PROX", 0, 2, 1, 1,
 _HISTOGRAM_CREATE_PROX_parameters, 1, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _HISTOGRAM_CREATE_PROX_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_2DHISTO_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_CREATE_2DHISTO_TITLE = { "TITLE", 5,
 "Histogram title", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_CREATE_2DHISTO_NCX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_2DHISTO_NCX = { "NCX", 3,
 "Number of channels in X", "40", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_CREATE_2DHISTO_NCX_type };
static KmParReal   _HISTOGRAM_CREATE_2DHISTO_XMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_2DHISTO_XMIN = { "XMIN", 4,
 "Low edge in X", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_2DHISTO_XMIN_type };
static KmParReal   _HISTOGRAM_CREATE_2DHISTO_XMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_2DHISTO_XMAX = { "XMAX", 4,
 "Upper edge in X", "40.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_2DHISTO_XMAX_type };
static KmParInt    _HISTOGRAM_CREATE_2DHISTO_NCY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_2DHISTO_NCY = { "NCY", 3,
 "Number of channels in Y", "40", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_CREATE_2DHISTO_NCY_type };
static KmParReal   _HISTOGRAM_CREATE_2DHISTO_YMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_2DHISTO_YMIN = { "YMIN", 4,
 "Low edge in Y", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_2DHISTO_YMIN_type };
static KmParReal   _HISTOGRAM_CREATE_2DHISTO_YMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_2DHISTO_YMAX = { "YMAX", 4,
 "Upper edge in Y", "40.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_2DHISTO_YMAX_type };
static KmParReal   _HISTOGRAM_CREATE_2DHISTO_VALMAX_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_2DHISTO_VALMAX = { "VALMAX", 6,
 "Maximum bin content", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_2DHISTO_VALMAX_type };
static KmParameter *_HISTOGRAM_CREATE_2DHISTO_parameters[] = {
 &_HISTOGRAM_CREATE_2DHISTO_ID, &_HISTOGRAM_CREATE_2DHISTO_TITLE,
 &_HISTOGRAM_CREATE_2DHISTO_NCX, &_HISTOGRAM_CREATE_2DHISTO_XMIN,
 &_HISTOGRAM_CREATE_2DHISTO_XMAX, &_HISTOGRAM_CREATE_2DHISTO_NCY,
 &_HISTOGRAM_CREATE_2DHISTO_YMIN, &_HISTOGRAM_CREATE_2DHISTO_YMAX,
 &_HISTOGRAM_CREATE_2DHISTO_VALMAX };
static char *_HISTOGRAM_CREATE_2DHISTO_guidance[] = {
 "Create a two dimensional histogram.",
 "The contents are set to zero. See 1DHISTO for VALMAX." };
static KmCommand _HISTOGRAM_CREATE_2DHISTO = { &_HISTOGRAM_CREATE_PROX,
 "/HISTOGRAM/CREATE/2DHISTO", "2DHISTO", 0, 2, 9, 8,
 _HISTOGRAM_CREATE_2DHISTO_parameters, 1, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _HISTOGRAM_CREATE_2DHISTO_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_BINS_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_CREATE_BINS_TITLE = { "TITLE", 5,
 "Histogram title", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_CREATE_BINS_NCX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_BINS_NCX = { "NCX", 3,
 "Number of channels", "100", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_CREATE_BINS_NCX_type };
static KmParameter _HISTOGRAM_CREATE_BINS_XBINS = { "XBINS", 5,
 "Vector of NCX+1 low-edges", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_CREATE_BINS_VALMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_BINS_VALMAX = { "VALMAX", 6,
 "Maximum bin content", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_BINS_VALMAX_type };
static KmParameter *_HISTOGRAM_CREATE_BINS_parameters[] = {
 &_HISTOGRAM_CREATE_BINS_ID, &_HISTOGRAM_CREATE_BINS_TITLE,
 &_HISTOGRAM_CREATE_BINS_NCX, &_HISTOGRAM_CREATE_BINS_XBINS,
 &_HISTOGRAM_CREATE_BINS_VALMAX };
static char *_HISTOGRAM_CREATE_BINS_guidance[] = {
 "Create a histogram with variable size bins.",
 "The low-edge of each bin is given in vector XBINS (NCX+1) values.",
 "The contents are set to zero. See 1DHISTO for VALMAX." };
static KmCommand _HISTOGRAM_CREATE_BINS = { &_HISTOGRAM_CREATE_2DHISTO,
 "/HISTOGRAM/CREATE/BINS", "BINS", 0, 2, 5, 4,
 _HISTOGRAM_CREATE_BINS_parameters, 0, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _HISTOGRAM_CREATE_BINS_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_PROFILE_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_CREATE_PROFILE_TITLE = { "TITLE", 5,
 "Histogram title", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_CREATE_PROFILE_NCX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_PROFILE_NCX = { "NCX", 3,
 "Number of channels", "100", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_CREATE_PROFILE_NCX_type };
static KmParReal   _HISTOGRAM_CREATE_PROFILE_XMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_PROFILE_XMIN = { "XMIN", 4,
 "Low edge in X", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_PROFILE_XMIN_type };
static KmParReal   _HISTOGRAM_CREATE_PROFILE_XMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_PROFILE_XMAX = { "XMAX", 4,
 "Upper edge in X", "100.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_PROFILE_XMAX_type };
static KmParReal   _HISTOGRAM_CREATE_PROFILE_YMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_PROFILE_YMIN = { "YMIN", 4,
 "Low edge in Y", "-1.E30", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_PROFILE_YMIN_type };
static KmParReal   _HISTOGRAM_CREATE_PROFILE_YMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_PROFILE_YMAX = { "YMAX", 4,
 "Upper edge in Y", "1.E30", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_PROFILE_YMAX_type };
static char *_HISTOGRAM_CREATE_PROFILE_CHOPT_range[] = { "", "S" };
static char *_HISTOGRAM_CREATE_PROFILE_CHOPT_text[] = { "Error on mean",
 "Spread option" };
static KmParOption _HISTOGRAM_CREATE_PROFILE_CHOPT_type = {
 _HISTOGRAM_CREATE_PROFILE_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_CREATE_PROFILE_CHOPT = { "CHOPT", 5, "Options",
 " ", (char*)0, 8, 2, _HISTOGRAM_CREATE_PROFILE_CHOPT_range, 2,
 _HISTOGRAM_CREATE_PROFILE_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_CREATE_PROFILE_CHOPT_type };
static KmParameter *_HISTOGRAM_CREATE_PROFILE_parameters[] = {
 &_HISTOGRAM_CREATE_PROFILE_ID, &_HISTOGRAM_CREATE_PROFILE_TITLE,
 &_HISTOGRAM_CREATE_PROFILE_NCX, &_HISTOGRAM_CREATE_PROFILE_XMIN,
 &_HISTOGRAM_CREATE_PROFILE_XMAX, &_HISTOGRAM_CREATE_PROFILE_YMIN,
 &_HISTOGRAM_CREATE_PROFILE_YMAX, &_HISTOGRAM_CREATE_PROFILE_CHOPT };
static char *_HISTOGRAM_CREATE_PROFILE_guidance[] = {
 "Create a profile histogram.",
 "Profile histograms accumulate statistical quantities of a variable y",
 "in bins of a variable x. The contents are set to zero." };
static KmCommand _HISTOGRAM_CREATE_PROFILE = { &_HISTOGRAM_CREATE_BINS,
 "/HISTOGRAM/CREATE/PROFILE", "PROFILE", 0, 2, 8, 7,
 _HISTOGRAM_CREATE_PROFILE_parameters, 0, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _HISTOGRAM_CREATE_PROFILE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_1DHISTO_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_CREATE_1DHISTO_TITLE = { "TITLE", 5,
 "Histogram title", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_CREATE_1DHISTO_NCX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_1DHISTO_NCX = { "NCX", 3,
 "Number of channels", "100", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_CREATE_1DHISTO_NCX_type };
static KmParReal   _HISTOGRAM_CREATE_1DHISTO_XMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_1DHISTO_XMIN = { "XMIN", 4, "Low edge",
 "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_HISTOGRAM_CREATE_1DHISTO_XMIN_type };
static KmParReal   _HISTOGRAM_CREATE_1DHISTO_XMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_1DHISTO_XMAX = { "XMAX", 4, "Upper edge",
 "100.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_HISTOGRAM_CREATE_1DHISTO_XMAX_type };
static KmParReal   _HISTOGRAM_CREATE_1DHISTO_VALMAX_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_1DHISTO_VALMAX = { "VALMAX", 6,
 "Maximum bin content", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_1DHISTO_VALMAX_type };
static KmParameter *_HISTOGRAM_CREATE_1DHISTO_parameters[] = {
 &_HISTOGRAM_CREATE_1DHISTO_ID, &_HISTOGRAM_CREATE_1DHISTO_TITLE,
 &_HISTOGRAM_CREATE_1DHISTO_NCX, &_HISTOGRAM_CREATE_1DHISTO_XMIN,
 &_HISTOGRAM_CREATE_1DHISTO_XMAX, &_HISTOGRAM_CREATE_1DHISTO_VALMAX };
static char *_HISTOGRAM_CREATE_1DHISTO_guidance[] = {
 "Create a one dimensional histogram.", "The contents are set to zero.",
 "If VALMAX=0, then a full word is allocated per channel, else VALMAX",
 "is used as the maximum bin content allowing several channels to be",
 "stored into the same machine word." };
static KmCommand _HISTOGRAM_CREATE_1DHISTO = { &_HISTOGRAM_CREATE_PROFILE,
 "/HISTOGRAM/CREATE/1DHISTO", "1DHISTO", 0, 2, 6, 5,
 _HISTOGRAM_CREATE_1DHISTO_parameters, 1, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _HISTOGRAM_CREATE_1DHISTO_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_HIO_GRESET_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_HIO_GRESET_parameters[] = {
 &_HISTOGRAM_HIO_GRESET_ID };
static char *_HISTOGRAM_HIO_GRESET_guidance[] = {
 "Reset histogram ID in the global section." };
static KmCommand _HISTOGRAM_HIO_GRESET = {  (KmCommand*)0,
 "/HISTOGRAM/HIO/GRESET", "GRESET", 0, 2, 1, 1,
 _HISTOGRAM_HIO_GRESET_parameters, 0, 0, pahio_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _HISTOGRAM_HIO_GRESET_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_HIO_GLOBAL_SECT_GNAME = { "GNAME", 5,
 "Global section name", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_HIO_GLOBAL_SECT_parameters[] = {
 &_HISTOGRAM_HIO_GLOBAL_SECT_GNAME };
static char *_HISTOGRAM_HIO_GLOBAL_SECT_guidance[] = {
 "Map the global section GNAME.",
 "The current directory is changed to //GNAME.",
 "This command doesn't work on HPUX." };
static KmCommand _HISTOGRAM_HIO_GLOBAL_SECT = { &_HISTOGRAM_HIO_GRESET,
 "/HISTOGRAM/HIO/GLOBAL_SECT", "GLOBAL_SECT", 0, 2, 1, 1,
 _HISTOGRAM_HIO_GLOBAL_SECT_parameters, 0, 0, pahio_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _HISTOGRAM_HIO_GLOBAL_SECT_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _HISTOGRAM_HIO_OUTPUT_LP_LUN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_HIO_OUTPUT_LP_LUN = { "LUN", 3,
 "Logical unit number", "6", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_HIO_OUTPUT_LP_LUN_type };
static KmParameter _HISTOGRAM_HIO_OUTPUT_LP_FNAME = { "FNAME", 5, "File name",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_HISTOGRAM_HIO_OUTPUT_LP_parameters[] = {
 &_HISTOGRAM_HIO_OUTPUT_LP_LUN, &_HISTOGRAM_HIO_OUTPUT_LP_FNAME };
static char *_HISTOGRAM_HIO_OUTPUT_LP_guidance[] = {
 "Change the HBOOK 'line printer' file name.",
 "If FNAME=' ' then OUTPUT is appended to an already opened file on unit\
 LUN.", "If LUN is negative, the file is closed and subsequent output",
 "is directed to unit 6." };
static KmCommand _HISTOGRAM_HIO_OUTPUT_LP = { &_HISTOGRAM_HIO_GLOBAL_SECT,
 "/HISTOGRAM/HIO/OUTPUT_LP", "OUTPUT_LP", 0, 2, 2, 0,
 _HISTOGRAM_HIO_OUTPUT_LP_parameters, 0, 0, pahio_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _HISTOGRAM_HIO_OUTPUT_LP_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_HIO_DUMP_ID = { "ID", 2, "Histogram Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_HIO_DUMP_parameters[] = {
 &_HISTOGRAM_HIO_DUMP_ID };
static char *_HISTOGRAM_HIO_DUMP_guidance[] = {
 "Dump the histogram ZEBRA data structure on the terminal." };
static KmCommand _HISTOGRAM_HIO_DUMP = { &_HISTOGRAM_HIO_OUTPUT_LP,
 "/HISTOGRAM/HIO/DUMP", "DUMP", 0, 2, 1, 1, _HISTOGRAM_HIO_DUMP_parameters, 1,
 0, pahio_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _HISTOGRAM_HIO_DUMP_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_HIO_PRINT_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_HISTOGRAM_HIO_PRINT_CHOPT_range[] = { "", "S" };
static char *_HISTOGRAM_HIO_PRINT_CHOPT_text[] = { "Print histograms.",
 "Only statistics (Number of entries, mean, RMS, underflow, overflow) are\
 printed." };
static KmParOption _HISTOGRAM_HIO_PRINT_CHOPT_type = {
 _HISTOGRAM_HIO_PRINT_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_HIO_PRINT_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 2, _HISTOGRAM_HIO_PRINT_CHOPT_range, 2,
 _HISTOGRAM_HIO_PRINT_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_HIO_PRINT_CHOPT_type };
static KmParameter *_HISTOGRAM_HIO_PRINT_parameters[] = {
 &_HISTOGRAM_HIO_PRINT_ID, &_HISTOGRAM_HIO_PRINT_CHOPT };
static char *_HISTOGRAM_HIO_PRINT_guidance[] = {
 "Print histograms (line-printer format) on screen.",
 "The command OUTPUT_LP may be used to change the output file." };
static KmCommand _HISTOGRAM_HIO_PRINT = { &_HISTOGRAM_HIO_DUMP,
 "/HISTOGRAM/HIO/PRINT", "PRINT", 0, 2, 2, 1, _HISTOGRAM_HIO_PRINT_parameters,
 1, 0, pahio_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _HISTOGRAM_HIO_PRINT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_HIO_HREAD_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_HIO_HREAD_FNAME = { "FNAME", 5, "File name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_HIO_HREAD_parameters[] = {
 &_HISTOGRAM_HIO_HREAD_ID, &_HISTOGRAM_HIO_HREAD_FNAME };
static char *_HISTOGRAM_HIO_HREAD_guidance[] = {
 "Read histogram ID from file FNAME.",
 "FNAME has been created by the old version of HBOOK3 (Formatted)." };
static KmCommand _HISTOGRAM_HIO_HREAD = { &_HISTOGRAM_HIO_PRINT,
 "/HISTOGRAM/HIO/HREAD", "HREAD", 0, 2, 2, 2, _HISTOGRAM_HIO_HREAD_parameters,
 0, 0, pahio_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _HISTOGRAM_HIO_HREAD_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_HIO_HFETCH_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_HIO_HFETCH_FNAME = { "FNAME", 5, "File name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_HIO_HFETCH_parameters[] = {
 &_HISTOGRAM_HIO_HFETCH_ID, &_HISTOGRAM_HIO_HFETCH_FNAME };
static char *_HISTOGRAM_HIO_HFETCH_guidance[] = {
 "Fetch histogram ID from file FNAME.",
 "FNAME has been created by the old version of HBOOK3 (Unformatted)." };
static KmCommand _HISTOGRAM_HIO_HFETCH = { &_HISTOGRAM_HIO_HREAD,
 "/HISTOGRAM/HIO/HFETCH", "HFETCH", 0, 2, 2, 2,
 _HISTOGRAM_HIO_HFETCH_parameters, 0, 0, pahio_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 2, _HISTOGRAM_HIO_HFETCH_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_HIO_HSCRATCH_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_HIO_HSCRATCH_parameters[] = {
 &_HISTOGRAM_HIO_HSCRATCH_ID };
static char *_HISTOGRAM_HIO_HSCRATCH_guidance[] = {
 "Delete histogram ID in Current Directory on disk.",
 "If ID='0' or '*' delete all histograms.",
 "To delete histograms in memory use command HISTO/DELETE." };
static KmCommand _HISTOGRAM_HIO_HSCRATCH = { &_HISTOGRAM_HIO_HFETCH,
 "/HISTOGRAM/HIO/HSCRATCH", "HSCRATCH", 0, 2, 1, 1,
 _HISTOGRAM_HIO_HSCRATCH_parameters, 1, 0, pahio_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _HISTOGRAM_HIO_HSCRATCH_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_HIO_HROUT_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_HISTOGRAM_HIO_HROUT_CHOPT_range[] = { "", "T" };
static char *_HISTOGRAM_HIO_HROUT_CHOPT_text[] = {
 "Write histo/Ntuple ID from memory to current directory.",
 "Writes all histograms in subdirectories as well." };
static KmParOption _HISTOGRAM_HIO_HROUT_CHOPT_type = {
 _HISTOGRAM_HIO_HROUT_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_HIO_HROUT_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 2, _HISTOGRAM_HIO_HROUT_CHOPT_range, 2,
 _HISTOGRAM_HIO_HROUT_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_HIO_HROUT_CHOPT_type };
static KmParameter *_HISTOGRAM_HIO_HROUT_parameters[] = {
 &_HISTOGRAM_HIO_HROUT_ID, &_HISTOGRAM_HIO_HROUT_CHOPT };
static char *_HISTOGRAM_HIO_HROUT_guidance[] = {
 "Write histo/Ntuple ID from memory to current directory.",
 "Identifier may be '0' or '*' (for all histograms)." };
static KmCommand _HISTOGRAM_HIO_HROUT = { &_HISTOGRAM_HIO_HSCRATCH,
 "/HISTOGRAM/HIO/HROUT", "HROUT", 0, 2, 2, 1, _HISTOGRAM_HIO_HROUT_parameters,
 1, 0, pahio_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _HISTOGRAM_HIO_HROUT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_HIO_HRIN_ID = { "ID", 2, "Histogram Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_HIO_HRIN_ICYCLE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_HIO_HRIN_ICYCLE = { "ICYCLE", 6, "Cycle number",
 "999", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_HISTOGRAM_HIO_HRIN_ICYCLE_type };
static KmParInt    _HISTOGRAM_HIO_HRIN_IOFSET_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_HIO_HRIN_IOFSET = { "IOFSET", 6, "Offset", "0",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_HISTOGRAM_HIO_HRIN_IOFSET_type };
static KmParameter *_HISTOGRAM_HIO_HRIN_parameters[] = {
 &_HISTOGRAM_HIO_HRIN_ID, &_HISTOGRAM_HIO_HRIN_ICYCLE,
 &_HISTOGRAM_HIO_HRIN_IOFSET };
static char *_HISTOGRAM_HIO_HRIN_guidance[] = {
 "Read histogram/Ntuple ID from the current directory",
 "on direct access file to memory.",
 "An identical histogram is created but with an ID equal to that",
 "of the original histogram plus the offset IOFSET.",
 "Identifier may be '0' or '*' (for all histograms).",
 "If ICYCLE > 1000 and ID=0 read all histograms in all subdirectories as\
 well.",
 "If IOFSET = 99999 then the contents of histogram ID on the disk file",
 "are added to the current histogram in memory if it exists. For example",
 "to add all histograms from FILE1 and FILE2 in memory, the sequence",
 "of commands can be:", " PAW > Histo/File 1 FILE1", " PAW > Hrin 0",
 " PAW > Histo/File 2 FILE2", " PAW > Hrin 0 ! 99999" };
static KmCommand _HISTOGRAM_HIO_HRIN = { &_HISTOGRAM_HIO_HROUT,
 "/HISTOGRAM/HIO/HRIN", "HRIN", 0, 2, 3, 1, _HISTOGRAM_HIO_HRIN_parameters, 1,
 0, pahio_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 14,
 _HISTOGRAM_HIO_HRIN_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_HSETPR_PARAM = { "PARAM", 5,
 "Parameter name", "FEPS", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_OPERATIONS_HSETPR_VALUE_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_HSETPR_VALUE = { "VALUE", 5,
 "Parameter value", "0.001", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_HSETPR_VALUE_type };
static KmParameter *_HISTOGRAM_OPERATIONS_HSETPR_parameters[] = {
 &_HISTOGRAM_OPERATIONS_HSETPR_PARAM, &_HISTOGRAM_OPERATIONS_HSETPR_VALUE };
static char *_HISTOGRAM_OPERATIONS_HSETPR_guidance[] = {
 "Set various parameters for command PARAM." };
static KmCommand _HISTOGRAM_OPERATIONS_HSETPR = {  (KmCommand*)0,
 "/HISTOGRAM/OPERATIONS/HSETPR", "HSETPR", 0, 2, 2, 2,
 _HISTOGRAM_OPERATIONS_HSETPR_parameters, 0, 0, pahfit_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _HISTOGRAM_OPERATIONS_HSETPR_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_PARAM_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_OPERATIONS_PARAM_ISEL_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_PARAM_ISEL = { "ISEL", 4,
 "Control word", "11", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_HISTOGRAM_OPERATIONS_PARAM_ISEL_type };
static KmParReal   _HISTOGRAM_OPERATIONS_PARAM_R2MIN_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_PARAM_R2MIN = { "R2MIN", 5,
 "Min correlation coefficient", "1.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_PARAM_R2MIN_type
 };
static KmParInt    _HISTOGRAM_OPERATIONS_PARAM_MAXPOW_type = { "1", "20", "1",
 "20", 0 };
static KmParameter _HISTOGRAM_OPERATIONS_PARAM_MAXPOW = { "MAXPOW", 6,
 "Max degree of polynomials", "5", (char*)0, 3, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_OPERATIONS_PARAM_MAXPOW_type };
static KmParameter *_HISTOGRAM_OPERATIONS_PARAM_parameters[] = {
 &_HISTOGRAM_OPERATIONS_PARAM_ID, &_HISTOGRAM_OPERATIONS_PARAM_ISEL,
 &_HISTOGRAM_OPERATIONS_PARAM_R2MIN, &_HISTOGRAM_OPERATIONS_PARAM_MAXPOW };
static char *_HISTOGRAM_OPERATIONS_PARAM_guidance[] = {
 "Perform a regression on contents of the 1-Dim histogram ID.",
 "Find the best parameterisation in terms of elementary functions",
 "(regressors). See HBOOK guide HPARAM.",
 "Control word ISEL=1000*T +100*W +10*S +P",
 " S = 1 resulting parametric fit superimposed on histogram",
 "     0 no superposition",
 " P = 0 minimal output: the residual sum of squares is printed",
 "     1 normal output: in addition, the problem characteristics and",
 "       options are printed; also the standard deviations and",
 "       confidence intervals of the coefficients.",
 "     2 extensive output: the results of each iteration are printed",
 "       with the normal output.",
 " W = 0 weights on histogram contents are already defined via HBARX",
 "       or HPAKE. If not they are taken to be equal to the",
 "       square-root of the contents.", "     1 weights are equal to 1.",
 " T = 0 monomials will be selected as the elementary functions",
 "     1 Chebyshev polynomials with a definition region: [-1,1]",
 "     2 Legendre polynomials with a definition region: [-1,1]",
 "     3 shifted Chebyshev polynomials with a definition region: [0,1]",
 "     4 Laguerre polynomials with a definition region: [0,+infinite]",
 "     5 Hermite polynomials with a definition region: [-inf,+inf]",
 "The FORTRAN code of the parameterisation is written onto the file",
 "FPARAM.DAT." };
static KmCommand _HISTOGRAM_OPERATIONS_PARAM = {
 &_HISTOGRAM_OPERATIONS_HSETPR, "/HISTOGRAM/OPERATIONS/PARAM", "PARAM", 0, 2,
 4, 1, _HISTOGRAM_OPERATIONS_PARAM_parameters, 0, 0, pahfit_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 24, _HISTOGRAM_OPERATIONS_PARAM_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_FUNCTION_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_FUNCTION_UFUNC = { "UFUNC", 5,
 "Name of the function", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_OPERATIONS_FUNCTION_parameters[] = {
 &_HISTOGRAM_OPERATIONS_FUNCTION_ID, &_HISTOGRAM_OPERATIONS_FUNCTION_UFUNC };
static char *_HISTOGRAM_OPERATIONS_FUNCTION_guidance[] = {
 "Associate the function UFUNC with the histogram ID.", "", "Example:",
 "    HIS/OP/FUN 110 X**2", "    H/PL 110" };
static KmCommand _HISTOGRAM_OPERATIONS_FUNCTION = {
 &_HISTOGRAM_OPERATIONS_PARAM, "/HISTOGRAM/OPERATIONS/FUNCTION", "FUNCTION",
 0, 2, 2, 2, _HISTOGRAM_OPERATIONS_FUNCTION_parameters, 0, 0, pahfit_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 5,
 _HISTOGRAM_OPERATIONS_FUNCTION_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_SPLINE_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_OPERATIONS_SPLINE_ISEL_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_SPLINE_ISEL = { "ISEL", 4,
 "Option flag", "2", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_HISTOGRAM_OPERATIONS_SPLINE_ISEL_type };
static KmParInt    _HISTOGRAM_OPERATIONS_SPLINE_KNOTX_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_SPLINE_KNOTX = { "KNOTX", 5,
 "Number of knots", "10", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_OPERATIONS_SPLINE_KNOTX_type };
static KmParInt    _HISTOGRAM_OPERATIONS_SPLINE_KX_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_SPLINE_KX = { "KX", 2,
 "Degree of the spline", "3", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_OPERATIONS_SPLINE_KX_type };
static KmParameter *_HISTOGRAM_OPERATIONS_SPLINE_parameters[] = {
 &_HISTOGRAM_OPERATIONS_SPLINE_ID, &_HISTOGRAM_OPERATIONS_SPLINE_ISEL,
 &_HISTOGRAM_OPERATIONS_SPLINE_KNOTX, &_HISTOGRAM_OPERATIONS_SPLINE_KX };
static char *_HISTOGRAM_OPERATIONS_SPLINE_guidance[] = {
 "Smooth 1-Dim or 2-Dim histogram ID using B-splines.",
 "If ID is a 1-Dim histogram then:",
 " ISEL = 0,1 replace original histogram by smoothed.",
 "      = 2   superimpose as a function when editing.",
 "If ID is a 2-Dim histogram then original contents are replaced." };
static KmCommand _HISTOGRAM_OPERATIONS_SPLINE = {
 &_HISTOGRAM_OPERATIONS_FUNCTION, "/HISTOGRAM/OPERATIONS/SPLINE", "SPLINE", 0,
 2, 4, 1, _HISTOGRAM_OPERATIONS_SPLINE_parameters, 0, 0, pahfit_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _HISTOGRAM_OPERATIONS_SPLINE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_SMOOTH_ID = { "ID", 2,
 "Histogram or Ntuple Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)2, KmTYPE_CHAR,  (void*)0 };
static char *_HISTOGRAM_OPERATIONS_SMOOTH_OPTION_range[] = { "0", "1", "2",
 "M", "Q", "S", "V", "N", "F" };
static char *_HISTOGRAM_OPERATIONS_SMOOTH_OPTION_text[] = {
 "Replace original histogram by smoothed.",
 "Replace original histogram by smoothed.",
 "Store values of smoothed function and its parameters without replacing the\
 original histogram (but see note below) - the smoothed function can be\
 displayed at editing time - see HISTOGRAM/PLOT.",
 "Invoke multiquadric smoothing (see HBOOK routine HQUAD).",
 "Invoke the 353QH algorithm (see HBOOK routine HSMOOF).",
 "Invoke spline smoothing.",
 "Verbose (default for all except 1-D histogram).",
 "Do not plot the result of the fit.",
 "Write Fortran77 function to HQUADF.DAT (multiquadric only)" };
static KmParOption _HISTOGRAM_OPERATIONS_SMOOTH_OPTION_type = {
 _HISTOGRAM_OPERATIONS_SMOOTH_OPTION_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_SMOOTH_OPTION = { "OPTION", 6,
 "Options", "2M", (char*)0, 8, 9, _HISTOGRAM_OPERATIONS_SMOOTH_OPTION_range,
 9, _HISTOGRAM_OPERATIONS_SMOOTH_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_OPERATIONS_SMOOTH_OPTION_type };
static KmParReal   _HISTOGRAM_OPERATIONS_SMOOTH_SENSIT_type = { "0.3", "3.",
 "0.3", "3.", 1 };
static KmParameter _HISTOGRAM_OPERATIONS_SMOOTH_SENSIT = { "SENSIT", 6,
 "Sensitivity parameter", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_SMOOTH_SENSIT_type };
static KmParReal   _HISTOGRAM_OPERATIONS_SMOOTH_SMOOTH_type = { "0.3", "3.",
 "0.3", "3.", 1 };
static KmParameter _HISTOGRAM_OPERATIONS_SMOOTH_SMOOTH = { "SMOOTH", 6,
 "Smoothness parameter", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_SMOOTH_SMOOTH_type };
static KmParameter *_HISTOGRAM_OPERATIONS_SMOOTH_parameters[] = {
 &_HISTOGRAM_OPERATIONS_SMOOTH_ID, &_HISTOGRAM_OPERATIONS_SMOOTH_OPTION,
 &_HISTOGRAM_OPERATIONS_SMOOTH_SENSIT, &_HISTOGRAM_OPERATIONS_SMOOTH_SMOOTH };
static char *_HISTOGRAM_OPERATIONS_SMOOTH_guidance[] = {
 "Smooth a histogram or 'simple' ntuple.  ('simple' = 1, 2, or 3 variables.)",
 "",
 "For multiquadric smoothing, SENSIT controls the sensitivity to statistical",
 "fluctuations.  SMOOTH controls the (radius of) curvature of the",
 "multiquadric basis functions.", "", "Notes:", "",
 "1) The multiquadric basis functions are SQRT(R**2+D**2), where R is",
 "the distance from the 'centre', and D is a scale parameter and",
 "also the curvature at the 'centre'.  'Centres' are located at",
 "points where the 2nd differential or Laplacian of event density",
 "is statistically significant.", "",
 "2) The data must be statistically independent, i.e. events (weighted",
 "or unweighted) drawn randomly from a parent probability",
 "distribution or differential cross-section.", "",
 "For spline smoothing, SENSIT and SMOOTH control the no. of knots (= 10 *",
 "SENSIT) and degree of splines (= SMOOTH + 2) (thus if SENSIT and SMOOTH",
 "are at their default values a 10-knot cubic spline is used).", "", "Notes:",
 "", "1) The spline option ALWAYS replaces the contents of a 2-D histogram.",
 "(Also chi-squared is unavailable in this case.)", "",
 "2) Use the SPLINE command for more flexibility." };
static KmCommand _HISTOGRAM_OPERATIONS_SMOOTH = {
 &_HISTOGRAM_OPERATIONS_SPLINE, "/HISTOGRAM/OPERATIONS/SMOOTH", "SMOOTH", 0,
 2, 4, 1, _HISTOGRAM_OPERATIONS_SMOOTH_parameters, 0, 0, pahfit_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 28, _HISTOGRAM_OPERATIONS_SMOOTH_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_SORT_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_HISTOGRAM_OPERATIONS_SORT_CHOPT_range[] = { "X", "Y", "Z", "A",
 "E", "D", "V" };
static char *_HISTOGRAM_OPERATIONS_SORT_CHOPT_text[] = {
 "X-axis is being treated.", "Y-axis is being treated.",
 "Z-axis is being treated.", "Alphabetically.", "Reverse alphabetical order.",
 "By increasing channel contents.", "By decreasing channel contents." };
static KmParOption _HISTOGRAM_OPERATIONS_SORT_CHOPT_type = {
 _HISTOGRAM_OPERATIONS_SORT_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_SORT_CHOPT = { "CHOPT", 5, "Options",
 "XA", (char*)0, 8, 7, _HISTOGRAM_OPERATIONS_SORT_CHOPT_range, 7,
 _HISTOGRAM_OPERATIONS_SORT_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_OPERATIONS_SORT_CHOPT_type };
static KmParameter *_HISTOGRAM_OPERATIONS_SORT_parameters[] = {
 &_HISTOGRAM_OPERATIONS_SORT_ID, &_HISTOGRAM_OPERATIONS_SORT_CHOPT };
static char *_HISTOGRAM_OPERATIONS_SORT_guidance[] = {
 "Sort the alphanumeric labels of the histogram ID according",
 "to the value of CHOPT." };
static KmCommand _HISTOGRAM_OPERATIONS_SORT = { &_HISTOGRAM_OPERATIONS_SMOOTH,
 "/HISTOGRAM/OPERATIONS/SORT", "SORT", 0, 2, 2, 1,
 _HISTOGRAM_OPERATIONS_SORT_parameters, 1, 0, pahope_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _HISTOGRAM_OPERATIONS_SORT_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_DIFF_ID1 = { "ID1", 3,
 "First Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_DIFF_ID2 = { "ID2", 3,
 "Second Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_HISTOGRAM_OPERATIONS_DIFF_CHOPT_range[] = { "", "N", "D", "O",
 "U", "L", "R", "T", "B", "F1", "F2" };
static char *_HISTOGRAM_OPERATIONS_DIFF_CHOPT_text[] = {
 "The comparison is done only on the shape of the two histograms.",
 "Include also comparison of the relative normalisation of the two histograms,\
 in addition to comparing the shapes. PROB is then a combined confidence level\
 taking account of absolute contents.",
 "Debug printout, produces a blank line and two lines of information at each\
 call, including the ID numbers, the number of events in each histogram, the\
 PROB value, and the maximum Kolmogorov distance between the two histograms.\
 For 2-Dim histograms, there are two Kolmogorov distances (see below). If 'N'\
 is specified, there is a third line of output giving the PROB for shape\
 alone, and for normalisation.",
 "Overflow, requests that overflow bins be taken into account.",
 "Underflow, requests that underflow bins be taken into account.",
 "Left: include x-underflows", "Right: include x-overflows",
 "Top: include y-overflows", "Bottom: include y-underflows",
 "Histogram 1 has no error (is a function)",
 "Histogram 2 has no error (is a function)" };
static KmParOption _HISTOGRAM_OPERATIONS_DIFF_CHOPT_type = {
 _HISTOGRAM_OPERATIONS_DIFF_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_DIFF_CHOPT = { "CHOPT", 5, "Options",
 "D", (char*)0, 8, 11, _HISTOGRAM_OPERATIONS_DIFF_CHOPT_range, 11,
 _HISTOGRAM_OPERATIONS_DIFF_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_OPERATIONS_DIFF_CHOPT_type };
static KmParameter *_HISTOGRAM_OPERATIONS_DIFF_parameters[] = {
 &_HISTOGRAM_OPERATIONS_DIFF_ID1, &_HISTOGRAM_OPERATIONS_DIFF_ID2,
 &_HISTOGRAM_OPERATIONS_DIFF_CHOPT };
static char *_HISTOGRAM_OPERATIONS_DIFF_guidance[] = {
 "Test of compatibility for two 1-Dim histograms ID1 and ID2.",
 "A probability PROB is calculated as a number between zero and one,",
 "where PROB near",
 "one indicates very similar histograms, and PROB near zero",
 "means that it is very unlikely that the two arose from the same",
 "parent distribution.",
 "For two histograms sampled randomly from the same distribution,",
 "PROB will be (approximately) uniformly distributed between 0 and 1.",
 "See discussion in HBOOK manual under 'HDIFF- Statistical Considerations'.",
 "By default (if no options are selected with CHOPT) the comparison",
 "is done only on the shape of the two histograms, without consideration",
 "of the difference in numbers of events, and ignoring all underflow and",
 "overflow bins." };
static KmCommand _HISTOGRAM_OPERATIONS_DIFF = { &_HISTOGRAM_OPERATIONS_SORT,
 "/HISTOGRAM/OPERATIONS/DIFF", "DIFF", 0, 2, 3, 2,
 _HISTOGRAM_OPERATIONS_DIFF_parameters, 0, 0, pahope_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 13, _HISTOGRAM_OPERATIONS_DIFF_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_RESET_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_RESET_TITLE = { "TITLE", 5,
 "New title", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_OPERATIONS_RESET_parameters[] = {
 &_HISTOGRAM_OPERATIONS_RESET_ID, &_HISTOGRAM_OPERATIONS_RESET_TITLE };
static char *_HISTOGRAM_OPERATIONS_RESET_guidance[] = {
 "Reset contents and errors of an histogram.",
 "Bin definition is not modified." };
static KmCommand _HISTOGRAM_OPERATIONS_RESET = { &_HISTOGRAM_OPERATIONS_DIFF,
 "/HISTOGRAM/OPERATIONS/RESET", "RESET", 0, 2, 2, 1,
 _HISTOGRAM_OPERATIONS_RESET_parameters, 1, 0, pahope_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _HISTOGRAM_OPERATIONS_RESET_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_DIVIDE_ID1 = { "ID1", 3,
 "First histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_DIVIDE_ID2 = { "ID2", 3,
 "Second histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_DIVIDE_ID3 = { "ID3", 3,
 "Result histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_OPERATIONS_DIVIDE_C1_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_DIVIDE_C1 = { "C1", 2,
 "Scale factor for ID1", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_DIVIDE_C1_type };
static KmParReal   _HISTOGRAM_OPERATIONS_DIVIDE_C2_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_DIVIDE_C2 = { "C2", 2,
 "Scale factor for ID2", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_DIVIDE_C2_type };
static char *_HISTOGRAM_OPERATIONS_DIVIDE_OPTION_range[] = { " ", "E" };
static char *_HISTOGRAM_OPERATIONS_DIVIDE_OPTION_text[] = { (char*)0, (char*)0
 };
static KmParOption _HISTOGRAM_OPERATIONS_DIVIDE_OPTION_type = {
 _HISTOGRAM_OPERATIONS_DIVIDE_OPTION_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_DIVIDE_OPTION = { "OPTION", 6,
 "Option", " ", (char*)0, 8, 2, _HISTOGRAM_OPERATIONS_DIVIDE_OPTION_range, 2,
 _HISTOGRAM_OPERATIONS_DIVIDE_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_OPERATIONS_DIVIDE_OPTION_type };
static KmParameter *_HISTOGRAM_OPERATIONS_DIVIDE_parameters[] = {
 &_HISTOGRAM_OPERATIONS_DIVIDE_ID1, &_HISTOGRAM_OPERATIONS_DIVIDE_ID2,
 &_HISTOGRAM_OPERATIONS_DIVIDE_ID3, &_HISTOGRAM_OPERATIONS_DIVIDE_C1,
 &_HISTOGRAM_OPERATIONS_DIVIDE_C2, &_HISTOGRAM_OPERATIONS_DIVIDE_OPTION };
static char *_HISTOGRAM_OPERATIONS_DIVIDE_guidance[] = {
 "Divide histograms: ID3 = C1*ID1 / C2*ID2.",
 "Applicable to 1-Dim and 2-Dim histograms.",
 "If option 'E' is set, error bars are calculated for ID3." };
static KmCommand _HISTOGRAM_OPERATIONS_DIVIDE = {
 &_HISTOGRAM_OPERATIONS_RESET, "/HISTOGRAM/OPERATIONS/DIVIDE", "DIVIDE", 0, 2,
 6, 3, _HISTOGRAM_OPERATIONS_DIVIDE_parameters, 0, 0, pahope_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _HISTOGRAM_OPERATIONS_DIVIDE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_MULTIPLY_ID1 = { "ID1", 3,
 "First histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_MULTIPLY_ID2 = { "ID2", 3,
 "Second histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_MULTIPLY_ID3 = { "ID3", 3,
 "Result histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_OPERATIONS_MULTIPLY_C1_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_MULTIPLY_C1 = { "C1", 2,
 "Scale factor for ID1", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_MULTIPLY_C1_type };
static KmParReal   _HISTOGRAM_OPERATIONS_MULTIPLY_C2_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_MULTIPLY_C2 = { "C2", 2,
 "Scale factor for ID2", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_MULTIPLY_C2_type };
static char *_HISTOGRAM_OPERATIONS_MULTIPLY_OPTION_range[] = { " ", "E" };
static char *_HISTOGRAM_OPERATIONS_MULTIPLY_OPTION_text[] = { (char*)0,
 (char*)0 };
static KmParOption _HISTOGRAM_OPERATIONS_MULTIPLY_OPTION_type = {
 _HISTOGRAM_OPERATIONS_MULTIPLY_OPTION_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_MULTIPLY_OPTION = { "OPTION", 6,
 "Option", " ", (char*)0, 8, 2, _HISTOGRAM_OPERATIONS_MULTIPLY_OPTION_range,
 2, _HISTOGRAM_OPERATIONS_MULTIPLY_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_OPERATIONS_MULTIPLY_OPTION_type };
static KmParameter *_HISTOGRAM_OPERATIONS_MULTIPLY_parameters[] = {
 &_HISTOGRAM_OPERATIONS_MULTIPLY_ID1, &_HISTOGRAM_OPERATIONS_MULTIPLY_ID2,
 &_HISTOGRAM_OPERATIONS_MULTIPLY_ID3, &_HISTOGRAM_OPERATIONS_MULTIPLY_C1,
 &_HISTOGRAM_OPERATIONS_MULTIPLY_C2, &_HISTOGRAM_OPERATIONS_MULTIPLY_OPTION };
static char *_HISTOGRAM_OPERATIONS_MULTIPLY_guidance[] = {
 "Multiply histogram contents: ID3 = C1*ID1 * C2*ID2.",
 "Applicable to 1-Dim and 2-Dim histograms.",
 "If option 'E' is set, error bars are calculated for ID3." };
static KmCommand _HISTOGRAM_OPERATIONS_MULTIPLY = {
 &_HISTOGRAM_OPERATIONS_DIVIDE, "/HISTOGRAM/OPERATIONS/MULTIPLY", "MULTIPLY",
 0, 2, 6, 3, _HISTOGRAM_OPERATIONS_MULTIPLY_parameters, 0, 0, pahope_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _HISTOGRAM_OPERATIONS_MULTIPLY_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_SUBTRACT_ID1 = { "ID1", 3,
 "First histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_SUBTRACT_ID2 = { "ID2", 3,
 "Second histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_SUBTRACT_ID3 = { "ID3", 3,
 "Result histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_OPERATIONS_SUBTRACT_C1_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_SUBTRACT_C1 = { "C1", 2,
 "Scale factor for ID1", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_SUBTRACT_C1_type };
static KmParReal   _HISTOGRAM_OPERATIONS_SUBTRACT_C2_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_SUBTRACT_C2 = { "C2", 2,
 "Scale factor for ID2", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_SUBTRACT_C2_type };
static char *_HISTOGRAM_OPERATIONS_SUBTRACT_OPTION_range[] = { " ", "E" };
static char *_HISTOGRAM_OPERATIONS_SUBTRACT_OPTION_text[] = { (char*)0,
 (char*)0 };
static KmParOption _HISTOGRAM_OPERATIONS_SUBTRACT_OPTION_type = {
 _HISTOGRAM_OPERATIONS_SUBTRACT_OPTION_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_SUBTRACT_OPTION = { "OPTION", 6,
 "Option", " ", (char*)0, 8, 2, _HISTOGRAM_OPERATIONS_SUBTRACT_OPTION_range,
 2, _HISTOGRAM_OPERATIONS_SUBTRACT_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_OPERATIONS_SUBTRACT_OPTION_type };
static KmParameter *_HISTOGRAM_OPERATIONS_SUBTRACT_parameters[] = {
 &_HISTOGRAM_OPERATIONS_SUBTRACT_ID1, &_HISTOGRAM_OPERATIONS_SUBTRACT_ID2,
 &_HISTOGRAM_OPERATIONS_SUBTRACT_ID3, &_HISTOGRAM_OPERATIONS_SUBTRACT_C1,
 &_HISTOGRAM_OPERATIONS_SUBTRACT_C2, &_HISTOGRAM_OPERATIONS_SUBTRACT_OPTION };
static char *_HISTOGRAM_OPERATIONS_SUBTRACT_guidance[] = {
 "Subtract histograms: ID3 = C1*ID1 - C2*ID2.",
 "Applicable to 1-Dim and 2-Dim histograms.",
 "If option 'E' is set, error bars are calculated for ID3." };
static KmCommand _HISTOGRAM_OPERATIONS_SUBTRACT = {
 &_HISTOGRAM_OPERATIONS_MULTIPLY, "/HISTOGRAM/OPERATIONS/SUBTRACT",
 "SUBTRACT", 0, 2, 6, 3, _HISTOGRAM_OPERATIONS_SUBTRACT_parameters, 0, 0,
 pahope_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _HISTOGRAM_OPERATIONS_SUBTRACT_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_ADD_ID1 = { "ID1", 3,
 "First histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_ADD_ID2 = { "ID2", 3,
 "Second histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_ADD_ID3 = { "ID3", 3,
 "Result histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_OPERATIONS_ADD_C1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_ADD_C1 = { "C1", 2,
 "Scale factor for ID1", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_ADD_C1_type };
static KmParReal   _HISTOGRAM_OPERATIONS_ADD_C2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_ADD_C2 = { "C2", 2,
 "Scale factor for ID2", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_ADD_C2_type };
static char *_HISTOGRAM_OPERATIONS_ADD_OPTION_range[] = { " ", "E" };
static char *_HISTOGRAM_OPERATIONS_ADD_OPTION_text[] = { (char*)0, (char*)0 };
static KmParOption _HISTOGRAM_OPERATIONS_ADD_OPTION_type = {
 _HISTOGRAM_OPERATIONS_ADD_OPTION_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_ADD_OPTION = { "OPTION", 6, "Option",
 " ", (char*)0, 8, 2, _HISTOGRAM_OPERATIONS_ADD_OPTION_range, 2,
 _HISTOGRAM_OPERATIONS_ADD_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_OPERATIONS_ADD_OPTION_type };
static KmParameter *_HISTOGRAM_OPERATIONS_ADD_parameters[] = {
 &_HISTOGRAM_OPERATIONS_ADD_ID1, &_HISTOGRAM_OPERATIONS_ADD_ID2,
 &_HISTOGRAM_OPERATIONS_ADD_ID3, &_HISTOGRAM_OPERATIONS_ADD_C1,
 &_HISTOGRAM_OPERATIONS_ADD_C2, &_HISTOGRAM_OPERATIONS_ADD_OPTION };
static char *_HISTOGRAM_OPERATIONS_ADD_guidance[] = {
 "Add histograms: ID3 = C1*ID1 + C2*ID2.",
 "Applicable to 1-Dim and 2-Dim histograms.",
 "See command HRIN to add histograms with same IDS", "from different files.",
 "If option 'E' is set, error bars are calculated for ID3." };
static KmCommand _HISTOGRAM_OPERATIONS_ADD = {
 &_HISTOGRAM_OPERATIONS_SUBTRACT, "/HISTOGRAM/OPERATIONS/ADD", "ADD", 0, 2, 6,
 3, _HISTOGRAM_OPERATIONS_ADD_parameters, 0, 0, pahope_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _HISTOGRAM_OPERATIONS_ADD_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_GET_VECT_REBIN_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_GET_VECT_REBIN_X = { "X", 1, "Name of vector X",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_GET_VECT_REBIN_Y = { "Y", 1, "Name of vector Y",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_GET_VECT_REBIN_EX = { "EX", 2,
 "Name of vector EX", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_GET_VECT_REBIN_EY = { "EY", 2,
 "Name of vector EY", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_GET_VECT_REBIN_N_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_GET_VECT_REBIN_N = { "N", 1,
 "Number of elements to fill", "100", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_GET_VECT_REBIN_N_type };
static KmParInt    _HISTOGRAM_GET_VECT_REBIN_IFIRST_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_GET_VECT_REBIN_IFIRST = { "IFIRST", 6,
 "First bin", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_HISTOGRAM_GET_VECT_REBIN_IFIRST_type };
static KmParInt    _HISTOGRAM_GET_VECT_REBIN_ILAST_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_GET_VECT_REBIN_ILAST = { "ILAST", 5, "Last bin",
 "100", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_HISTOGRAM_GET_VECT_REBIN_ILAST_type };
static char *_HISTOGRAM_GET_VECT_REBIN_CHOPT_range[] = { "N" };
static char *_HISTOGRAM_GET_VECT_REBIN_CHOPT_text[] = {
 "Do not normalize values in Y" };
static KmParOption _HISTOGRAM_GET_VECT_REBIN_CHOPT_type = {
 _HISTOGRAM_GET_VECT_REBIN_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_GET_VECT_REBIN_CHOPT = { "CHOPT", 5, "Option",
 " ", (char*)0, 8, 1, _HISTOGRAM_GET_VECT_REBIN_CHOPT_range, 1,
 _HISTOGRAM_GET_VECT_REBIN_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_GET_VECT_REBIN_CHOPT_type };
static KmParameter *_HISTOGRAM_GET_VECT_REBIN_parameters[] = {
 &_HISTOGRAM_GET_VECT_REBIN_ID, &_HISTOGRAM_GET_VECT_REBIN_X,
 &_HISTOGRAM_GET_VECT_REBIN_Y, &_HISTOGRAM_GET_VECT_REBIN_EX,
 &_HISTOGRAM_GET_VECT_REBIN_EY, &_HISTOGRAM_GET_VECT_REBIN_N,
 &_HISTOGRAM_GET_VECT_REBIN_IFIRST, &_HISTOGRAM_GET_VECT_REBIN_ILAST,
 &_HISTOGRAM_GET_VECT_REBIN_CHOPT };
static char *_HISTOGRAM_GET_VECT_REBIN_guidance[] = {
 "The specified channels of the 1-Dim histogram ID are cumulated (rebinned)",
 "into new bins. The final contents of the new bin is the average",
 "of the original bins by default. If the option N is given, the final",
 "contents of the new bin is the sum of the original bins.",
 "Get contents and errors into vectors, grouping bins.",
 "Bin width and centers are also extracted.",
 "Allow to combine 2, 3 or more bins into one.",
 "   E.g.:  REBIN 110 X Y EX EY 25 11 85",
 "           will group by 3 channels 11 to 85  and return",
 "           new abscissa, contents and errors.",
 "           Errors in X are equal to 1.5*BINWIDTH.", "   N.B.:",
 "          REBIN ID X Y EX EY  is a convenient way to return in",
 "          one call abscissa, contents and errors for 1-Dim histogram.",
 "          In this case the errors in X are equal to 0.5*BINWIDTH." };
static KmCommand _HISTOGRAM_GET_VECT_REBIN = {  (KmCommand*)0,
 "/HISTOGRAM/GET_VECT/REBIN", "REBIN", 0, 2, 9, 5,
 _HISTOGRAM_GET_VECT_REBIN_parameters, 0, 0, pahvec_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 15, _HISTOGRAM_GET_VECT_REBIN_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_GET_VECT_ABSCISSA_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_GET_VECT_ABSCISSA_VNAME = { "VNAME", 5,
 "Vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_GET_VECT_ABSCISSA_parameters[] = {
 &_HISTOGRAM_GET_VECT_ABSCISSA_ID, &_HISTOGRAM_GET_VECT_ABSCISSA_VNAME };
static char *_HISTOGRAM_GET_VECT_ABSCISSA_guidance[] = {
 "Get values of center of bins abscissa into vector VNAME." };
static KmCommand _HISTOGRAM_GET_VECT_ABSCISSA = { &_HISTOGRAM_GET_VECT_REBIN,
 "/HISTOGRAM/GET_VECT/ABSCISSA", "ABSCISSA", 0, 2, 2, 2,
 _HISTOGRAM_GET_VECT_ABSCISSA_parameters, 0, 0, pahvec_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _HISTOGRAM_GET_VECT_ABSCISSA_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_GET_VECT_FUNCTION_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_GET_VECT_FUNCTION_VNAME = { "VNAME", 5,
 "Vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_GET_VECT_FUNCTION_parameters[] = {
 &_HISTOGRAM_GET_VECT_FUNCTION_ID, &_HISTOGRAM_GET_VECT_FUNCTION_VNAME };
static char *_HISTOGRAM_GET_VECT_FUNCTION_guidance[] = {
 "Get function associated to histogram ID into vector VNAME." };
static KmCommand _HISTOGRAM_GET_VECT_FUNCTION = {
 &_HISTOGRAM_GET_VECT_ABSCISSA, "/HISTOGRAM/GET_VECT/FUNCTION", "FUNCTION", 0,
 2, 2, 2, _HISTOGRAM_GET_VECT_FUNCTION_parameters, 0, 0, pahvec_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _HISTOGRAM_GET_VECT_FUNCTION_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_GET_VECT_ERRORS_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_GET_VECT_ERRORS_VNAME = { "VNAME", 5,
 "Vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_GET_VECT_ERRORS_parameters[] = {
 &_HISTOGRAM_GET_VECT_ERRORS_ID, &_HISTOGRAM_GET_VECT_ERRORS_VNAME };
static char *_HISTOGRAM_GET_VECT_ERRORS_guidance[] = {
 "Get errors of histogram ID into vector VNAME." };
static KmCommand _HISTOGRAM_GET_VECT_ERRORS = { &_HISTOGRAM_GET_VECT_FUNCTION,
 "/HISTOGRAM/GET_VECT/ERRORS", "ERRORS", 0, 2, 2, 2,
 _HISTOGRAM_GET_VECT_ERRORS_parameters, 0, 0, pahvec_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _HISTOGRAM_GET_VECT_ERRORS_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_GET_VECT_CONTENTS_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_GET_VECT_CONTENTS_VNAME = { "VNAME", 5,
 "Vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_GET_VECT_CONTENTS_parameters[] = {
 &_HISTOGRAM_GET_VECT_CONTENTS_ID, &_HISTOGRAM_GET_VECT_CONTENTS_VNAME };
static char *_HISTOGRAM_GET_VECT_CONTENTS_guidance[] = {
 "Get contents of histogram ID into vector VNAME." };
static KmCommand _HISTOGRAM_GET_VECT_CONTENTS = { &_HISTOGRAM_GET_VECT_ERRORS,
 "/HISTOGRAM/GET_VECT/CONTENTS", "CONTENTS", 0, 2, 2, 2,
 _HISTOGRAM_GET_VECT_CONTENTS_parameters, 0, 0, pahvec_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _HISTOGRAM_GET_VECT_CONTENTS_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_PUT_VECT_ERRORS_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_PUT_VECT_ERRORS_VNAME = { "VNAME", 5,
 "Vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_PUT_VECT_ERRORS_parameters[] = {
 &_HISTOGRAM_PUT_VECT_ERRORS_ID, &_HISTOGRAM_PUT_VECT_ERRORS_VNAME };
static char *_HISTOGRAM_PUT_VECT_ERRORS_guidance[] = {
 "Replace errors of histogram with values of vector VNAME." };
static KmCommand _HISTOGRAM_PUT_VECT_ERRORS = {  (KmCommand*)0,
 "/HISTOGRAM/PUT_VECT/ERRORS", "ERRORS", 0, 2, 2, 2,
 _HISTOGRAM_PUT_VECT_ERRORS_parameters, 0, 0, pahvec_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _HISTOGRAM_PUT_VECT_ERRORS_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_PUT_VECT_CONTENTS_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_PUT_VECT_CONTENTS_VNAME = { "VNAME", 5,
 "Vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_PUT_VECT_CONTENTS_parameters[] = {
 &_HISTOGRAM_PUT_VECT_CONTENTS_ID, &_HISTOGRAM_PUT_VECT_CONTENTS_VNAME };
static char *_HISTOGRAM_PUT_VECT_CONTENTS_guidance[] = {
 "Replace contents of histogram with values of vector VNAME." };
static KmCommand _HISTOGRAM_PUT_VECT_CONTENTS = { &_HISTOGRAM_PUT_VECT_ERRORS,
 "/HISTOGRAM/PUT_VECT/CONTENTS", "CONTENTS", 0, 2, 2, 2,
 _HISTOGRAM_PUT_VECT_CONTENTS_parameters, 0, 0, pahvec_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _HISTOGRAM_PUT_VECT_CONTENTS_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_SET_IDOPT_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_HISTOGRAM_SET_IDOPT_OPTION_range[] = { "SETD*", "SHOW", "BLAC",
 "CONT*", "STAR", "SCAT*", "TABL", "PROE*", "PROS", "STAT", "NSTA*", "ERRO",
 "NERR*", "INTE", "NINT*", "LOGY", "LINY*", "PCHA*", "NPCH", "PCON*", "NPCO",
 "PLOW*", "NPLO", "PERR", "NPER*", "PFUN", "NPFU*", "PHIS*", "NPHI", "PSTA*",
 "NPST", "ROTA", "NROT*", "1EVL", "AEVL*", "2PAG", "1PAG*", "AUTO*" };
static char *_HISTOGRAM_SET_IDOPT_OPTION_text[] = {
 "Set all options to the default values",
 "Print all the options currently set",
 "1 Dim histogram printed with X characters",
 "1 Dim histogram is printed with the contour option",
 "1 Dim histogram is printed with a * at the Y value",
 "Print a 2 Dim histogram as a scatter-plot",
 "Print a 2 Dim histogram as a table",
 "Plot errors as the error on mean of bin in Y for profile histograms",
 "Plot errors as the Spread of each bin in Y for profile histograms",
 "Mean value and RMS computed at filling time",
 "Mean value and RMS computed from bin contents only",
 "Errors bars printed as SQRT(contents)", "Do not print print error bars",
 "Print the values of integrated contents bin by bin",
 "Do not print integrated contents",
 "1 Dim histogram is printed in Log scale in Y",
 "1 Dim histogram is printed in linear scale in Y", "Print channel numbers",
 "Do not print channel numbers", "Print bin contents",
 "Do not print bin contents", "Print values of low edge of the bins",
 "Do not print the low edge", "Print the values of the errors for each bin",
 "Do not print the values of the errors",
 "Print the values of the associated function bin by bin",
 "Do not print the values of the associated function",
 "Print the histogram profile", "Do not print the histogram profile",
 "Print the values of statistics (entries,mean,RMS,etc.)",
 "Do not print values of statistics", "Print histogram rotated by 90 degrees",
 "Print histogram vertically",
 "Force an integer value for the steps in the Y axis",
 "Steps for the Y axis are automatically computed",
 "Histogram is printed over two pages",
 "Histogram is printed in one single page", "Automatic scaling" };
static KmParOption _HISTOGRAM_SET_IDOPT_OPTION_type = {
 _HISTOGRAM_SET_IDOPT_OPTION_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_SET_IDOPT_OPTION = { "OPTION", 6, "Options",
 (char*)0, (char*)0, 8, 38, _HISTOGRAM_SET_IDOPT_OPTION_range, 38,
 _HISTOGRAM_SET_IDOPT_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_SET_IDOPT_OPTION_type };
static KmParameter *_HISTOGRAM_SET_IDOPT_parameters[] = {
 &_HISTOGRAM_SET_IDOPT_ID, &_HISTOGRAM_SET_IDOPT_OPTION };
static char *_HISTOGRAM_SET_IDOPT_guidance[] = {
 "Set options for histogram ID. (* means default)." };
static KmCommand _HISTOGRAM_SET_IDOPT = {  (KmCommand*)0,
 "/HISTOGRAM/SET/IDOPT", "IDOPT", 0, 2, 2, 2, _HISTOGRAM_SET_IDOPT_parameters,
 0, 0, pahset_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _HISTOGRAM_SET_IDOPT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_SET_SCALE_FACTOR_2D_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_SET_SCALE_FACTOR_2D_XSCALE_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_SET_SCALE_FACTOR_2D_XSCALE = { "XSCALE", 6,
 "Scale factor", "0", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_HISTOGRAM_SET_SCALE_FACTOR_2D_XSCALE_type };
static KmParameter *_HISTOGRAM_SET_SCALE_FACTOR_2D_parameters[] = {
 &_HISTOGRAM_SET_SCALE_FACTOR_2D_ID, &_HISTOGRAM_SET_SCALE_FACTOR_2D_XSCALE };
static char *_HISTOGRAM_SET_SCALE_FACTOR_2D_guidance[] = {
 "Set the scale factor for histograms (2-Dim)." };
static KmCommand _HISTOGRAM_SET_SCALE_FACTOR_2D = { &_HISTOGRAM_SET_IDOPT,
 "/HISTOGRAM/SET/SCALE_FACTOR_2D", "SCALE_FACTOR_2D", 0, 2, 2, 1,
 _HISTOGRAM_SET_SCALE_FACTOR_2D_parameters, 0, 0, pahset_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _HISTOGRAM_SET_SCALE_FACTOR_2D_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_SET_NORMALIZE_FACTOR_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_SET_NORMALIZE_FACTOR_XNORM_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_SET_NORMALIZE_FACTOR_XNORM = { "XNORM", 5,
 "Normalisation factor", "1", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_SET_NORMALIZE_FACTOR_XNORM_type };
static KmParameter *_HISTOGRAM_SET_NORMALIZE_FACTOR_parameters[] = {
 &_HISTOGRAM_SET_NORMALIZE_FACTOR_ID, &_HISTOGRAM_SET_NORMALIZE_FACTOR_XNORM };
static char *_HISTOGRAM_SET_NORMALIZE_FACTOR_guidance[] = {
 "Set the contents/errors normalisation factor.",
 "Only valid for histograms (1-Dim).",
 "(does not change contents, only presentation)." };
static KmCommand _HISTOGRAM_SET_NORMALIZE_FACTOR = {
 &_HISTOGRAM_SET_SCALE_FACTOR_2D, "/HISTOGRAM/SET/NORMALIZE_FACTOR",
 "NORMALIZE_FACTOR", 0, 2, 2, 1, _HISTOGRAM_SET_NORMALIZE_FACTOR_parameters,
 0, 0, pahset_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _HISTOGRAM_SET_NORMALIZE_FACTOR_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_SET_MINIMUM_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_SET_MINIMUM_VMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_SET_MINIMUM_VMIN = { "VMIN", 4, "Minimum value",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_HISTOGRAM_SET_MINIMUM_VMIN_type };
static KmParameter *_HISTOGRAM_SET_MINIMUM_parameters[] = {
 &_HISTOGRAM_SET_MINIMUM_ID, &_HISTOGRAM_SET_MINIMUM_VMIN };
static char *_HISTOGRAM_SET_MINIMUM_guidance[] = {
 "Set the minimum value on the Y axis.",
 "To select again an automatic scale, just set VMIN equal to", "the maximum.",
 "", "Example:", "    MIN id 0 ; MAX id 0", "Reset the default scaling." };
static KmCommand _HISTOGRAM_SET_MINIMUM = { &_HISTOGRAM_SET_NORMALIZE_FACTOR,
 "/HISTOGRAM/SET/MINIMUM", "MINIMUM", 0, 2, 2, 2,
 _HISTOGRAM_SET_MINIMUM_parameters, 1, 0, pahset_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 7, _HISTOGRAM_SET_MINIMUM_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_SET_MAXIMUM_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_SET_MAXIMUM_VMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_SET_MAXIMUM_VMAX = { "VMAX", 4, "Maximum value",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_HISTOGRAM_SET_MAXIMUM_VMAX_type };
static KmParameter *_HISTOGRAM_SET_MAXIMUM_parameters[] = {
 &_HISTOGRAM_SET_MAXIMUM_ID, &_HISTOGRAM_SET_MAXIMUM_VMAX };
static char *_HISTOGRAM_SET_MAXIMUM_guidance[] = {
 "Set the maximum value on the Y axis.",
 "To select again an automatic scale, just set VMAX equal to", "the minimum.",
 "", "Example:", "    MIN id 0 ; MAX id 0", "Reset the default scaling." };
static KmCommand _HISTOGRAM_SET_MAXIMUM = { &_HISTOGRAM_SET_MINIMUM,
 "/HISTOGRAM/SET/MAXIMUM", "MAXIMUM", 0, 2, 2, 2,
 _HISTOGRAM_SET_MAXIMUM_parameters, 1, 0, pahset_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 7, _HISTOGRAM_SET_MAXIMUM_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_HISTOGRAM_SET_guidance[] = { "Set histogram attributes." };
static KmMenu _HISTOGRAM_SET = {  (KmMenu*)0,  (KmMenu*)0, "/HISTOGRAM/SET",
 "SET", 2, &_HISTOGRAM_SET_MAXIMUM, 1, _HISTOGRAM_SET_guidance, 0, (char**)0,
 0, (char**)0 };

static char *_HISTOGRAM_PUT_VECT_guidance[] = {
 "Replace histogram contents with values in a vector." };
static KmMenu _HISTOGRAM_PUT_VECT = { &_HISTOGRAM_SET,  (KmMenu*)0,
 "/HISTOGRAM/PUT_VECT", "PUT_VECT", 2, &_HISTOGRAM_PUT_VECT_CONTENTS, 1,
 _HISTOGRAM_PUT_VECT_guidance, 0, (char**)0, 0, (char**)0 };

static char *_HISTOGRAM_GET_VECT_guidance[] = {
 "Fill a vector from values stored in HBOOK objects." };
static KmMenu _HISTOGRAM_GET_VECT = { &_HISTOGRAM_PUT_VECT,  (KmMenu*)0,
 "/HISTOGRAM/GET_VECT", "GET_VECT", 2, &_HISTOGRAM_GET_VECT_CONTENTS, 1,
 _HISTOGRAM_GET_VECT_guidance, 0, (char**)0, 0, (char**)0 };

static char *_HISTOGRAM_OPERATIONS_guidance[] = {
 "Histogram operations and comparisons." };
static KmMenu _HISTOGRAM_OPERATIONS = { &_HISTOGRAM_GET_VECT,  (KmMenu*)0,
 "/HISTOGRAM/OPERATIONS", "OPERATIONS", 2, &_HISTOGRAM_OPERATIONS_ADD, 1,
 _HISTOGRAM_OPERATIONS_guidance, 0, (char**)0, 0, (char**)0 };

static char *_HISTOGRAM_HIO_guidance[] = {
 "Input/Output operations of histograms." };
static KmMenu _HISTOGRAM_HIO = { &_HISTOGRAM_OPERATIONS,  (KmMenu*)0,
 "/HISTOGRAM/HIO", "HIO", 2, &_HISTOGRAM_HIO_HRIN, 1, _HISTOGRAM_HIO_guidance,
 0, (char**)0, 0, (char**)0 };

static char *_HISTOGRAM_CREATE_guidance[] = {
 "Creation ('booking') of HBOOK objects in memory." };
static KmMenu _HISTOGRAM_CREATE = { &_HISTOGRAM_HIO,  (KmMenu*)0,
 "/HISTOGRAM/CREATE", "CREATE", 2, &_HISTOGRAM_CREATE_1DHISTO, 1,
 _HISTOGRAM_CREATE_guidance, 0, (char**)0, 0, (char**)0 };

static char *_HISTOGRAM_2D_PLOT_guidance[] = {
 "Plotting of 2-Dim histograms in various formats." };
static KmMenu _HISTOGRAM_2D_PLOT = { &_HISTOGRAM_CREATE,  (KmMenu*)0,
 "/HISTOGRAM/2D_PLOT", "2D_PLOT", 2, &_HISTOGRAM_2D_PLOT_LEGO, 1,
 _HISTOGRAM_2D_PLOT_guidance, 0, (char**)0, 0, (char**)0 };

static KmParameter _HISTOGRAM_FIT_ID = { "ID", 2, "Histogram Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_FIT_FUNC = { "FUNC", 4, "Function name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_HISTOGRAM_FIT_CHOPT_range[] = { "", "0", "N", "Q", "V", "B",
 "L", "D", "W", "M", "E", "U", "K" };
static char *_HISTOGRAM_FIT_CHOPT_text[] = {
 "Do the fit, plot the result and print the parameters.",
 "Do not plot the result of the fit. By default the fitted function is drawn\
 unless the option 'N' below is specified.",
 "Do not store the result of the fit bin by bin with the histogram. By default\
 the function is calculated at the middle of each bin and the fit results\
 stored with the histogram data structure.", "Quiet mode. No print",
 "Verbose mode. Results after each iteration are printed By default only final\
 results are printed.",
 "Some or all parameters are bounded. The vectors STEP,PMIN,PMAX must be\
 specified. Default is: All parameters vary freely.",
 "Use Log Likelihood. Default is chisquare method.",
 "The user is assumed to compute derivatives analytically using the routine\
 HDERIV. By default, derivatives are computed numerically.",
 "Sets weights equal to 1. Default weights taken from the square root of the\
 contents or from HPAKE/HBARX (PUT/ERRORS). If the L option is given (Log\
 Likelihood), bins with errors=0 are excluded of the fit.",
 "The interactive Minuit is invoked. (see Application HMINUIT below).",
 "Performs a better Error evaluation (MIGRAD + HESSE + MINOS).",
 "User function value is taken from /HCFITD/FITPAD(24),FITFUN.",
 "Keep the settings of Application HMINUIT for a subsequent command." };
static KmParOption _HISTOGRAM_FIT_CHOPT_type = { _HISTOGRAM_FIT_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_FIT_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 13, _HISTOGRAM_FIT_CHOPT_range, 13, _HISTOGRAM_FIT_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_HISTOGRAM_FIT_CHOPT_type };
static KmParInt    _HISTOGRAM_FIT_NP_type = { "0", "34", "0", "34", 0 };
static KmParameter _HISTOGRAM_FIT_NP = { "NP", 2, "Number of parameters", "0",
 (char*)0, 3, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_HISTOGRAM_FIT_NP_type };
static KmParameter _HISTOGRAM_FIT_PAR = { "PAR", 3, "Vector of parameters",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_FIT_STEP = { "STEP", 4, "Vector of steps size",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_FIT_PMIN = { "PMIN", 4,
 "Vector of lower bounds", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_FIT_PMAX = { "PMAX", 4,
 "Vector of upper bounds", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_FIT_ERRPAR = { "ERRPAR", 6,
 "Vector of errors on parameters", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_FIT_parameters[] = { &_HISTOGRAM_FIT_ID,
 &_HISTOGRAM_FIT_FUNC, &_HISTOGRAM_FIT_CHOPT, &_HISTOGRAM_FIT_NP,
 &_HISTOGRAM_FIT_PAR, &_HISTOGRAM_FIT_STEP, &_HISTOGRAM_FIT_PMIN,
 &_HISTOGRAM_FIT_PMAX, &_HISTOGRAM_FIT_ERRPAR };
static char *_HISTOGRAM_FIT_guidance[] = {
 "Fit a user defined (and parameter dependent) function",
 "to a histogram ID (1-Dim or 2-Dim) in the specified range.", "FUNC may be:",
 " A- The name of a file which contains the user defined",
 "    function to be minimized. Function name and file name",
 "    must be the same. For example file FUNC.FOR is:",
 "      FUNCTION FUNC(X)   or FUNC(X,Y) for a 2-Dim histogram",
 "      COMMON/PAWPAR/PAR(2)", "      FUNC=PAR(1)*X +PAR(2)*EXP(-X)",
 "      END", "     Ex: His/fit 10 func.for ! 5 par", "",
 "    When the option U is given, the file FUNC.FOR should look like:",
 "      FUNCTION FUNC(X)   or FUNC(X,Y) for a 2-Dim histogram",
 "      DOUBLE PRECISION FITPAD(24),FITFUN",
 "      COMMON/HCFITD/FITPAD,FITFUN",
 "      FITFUN=FITPAD(1)*X +FITPAD(2)*EXP(-X)", "      FUNC=FITFUN",
 "      END", "", " B- One of the following keywords (1-Dim only):",
 "    G : to fit Func=par(1)*exp(-0.5*((x-par(2))/par(3))**2)",
 "    E : to fit Func=exp(par(1)+par(2)*x)",
 "    Pn: to fit Func=par(1)+par(2)*x+par(3)*x**2......+par(n+1)*x**n",
 "     Ex: His/fit 10 g", "",
 " C- A combination of the keywords in B with the 2 operators + or *.",
 "    Ex: His/Fit 10 p4+g ! 8 par", "        His/Fit 10 p2*g+g ! 9 par",
 "      Note that in this case, the order of parameters in PAR must",
 "      correspond to the order of the basic functions.",
 "      For example, in the first case above, par(1:5) apply to",
 "      the polynomial of degree 4 and par(6:8) to the gaussian while",
 "      in the second case par(1:3) apply to the polynomial of degree 2,",
 "      par(4:6) to the first gaussian and par(7:9) to the second gaussian.",
 "      Blanks are not allowed in the expression.",
 "For cases A and C, before the execution of this command, the vector PAR",
 "must be filled (via Vector/Input) with the initial values.",
 "For case B, if NP is set to 0, then the initial values of PAR",
 "will be calculated automatically.",
 "After the fit, the vector PAR contains the new values",
 "of parameters. If the vector ERRPAR is given, it will contain",
 "the errors on the fitted parameters.",
 "A bin range may be specified with ID.", "  Ex. Histo/Fit 10(25:56).", "",
 "When the Histo/it command is used in a macro, it might be convenient",
 "to specify MINUIT directives in the macro itself via the Application",
 "HMINUIT as described in this example:", "     Macro fit",
 "     Application HMINUIT exit", "     name 1 par_name1",
 "     name 2 par_name2", "     migrad", "     improve", "     exit",
 "     Histo/fit id fitfun.f M", "     Return" };
static KmCommand _HISTOGRAM_FIT = {  (KmCommand*)0, "/HISTOGRAM/FIT", "FIT",
 0, 1, 9, 2, _HISTOGRAM_FIT_parameters, 0, 0, pafith_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 58, _HISTOGRAM_FIT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_COPY_ID1 = { "ID1", 3,
 "First histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_COPY_ID2 = { "ID2", 3,
 "Second histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_COPY_TITLE = { "TITLE", 5, "New title", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_HISTOGRAM_COPY_parameters[] = { &_HISTOGRAM_COPY_ID1,
 &_HISTOGRAM_COPY_ID2, &_HISTOGRAM_COPY_TITLE };
static char *_HISTOGRAM_COPY_guidance[] = {
 "Copy a histogram onto another one.",
 "Bin definition, contents, errors, etc. are preserved.",
 "If TITLE is not given, ID2 has the same title as ID1.", "",
 "It is possible to copy a projection of a 2D histogram",
 "into a 1D histogram.", "",
 "Ranges can be specify in the first histogram identifier to",
 "reduce or enlarge the X or Y scale.", "", "Example:",
 "    Fun2 2 x*y 40 0 1 40 0 1 ' '  | Create a 2D histogram",
 "    Slix 2 10 ; H/proj 2          | Slices on X",
 "    H/Copy 2.slix.3 3             | Copy the slice 3",
 "    H/Copy 2(0.:.5,-1.:2.) 4      | Copy with new X and Y scales" };
static KmCommand _HISTOGRAM_COPY = { &_HISTOGRAM_FIT, "/HISTOGRAM/COPY",
 "COPY", 0, 1, 3, 2, _HISTOGRAM_COPY_parameters, 2, 0, pahist_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 15, _HISTOGRAM_COPY_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_PROJECT_ID = { "ID", 2, "Histogram Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_PROJECT_parameters[] = { &_HISTOGRAM_PROJECT_ID
 };
static char *_HISTOGRAM_PROJECT_guidance[] = {
 "Fill all booked projections of a 2-Dim histogram.",
 "Filling is done using the 2-D contents of ID." };
static KmCommand _HISTOGRAM_PROJECT = { &_HISTOGRAM_COPY,
 "/HISTOGRAM/PROJECT", "PROJECT", 0, 1, 1, 1, _HISTOGRAM_PROJECT_parameters,
 1, 0, pahist_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _HISTOGRAM_PROJECT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_MANY_PLOTS_IDLIST = { "IDLIST", 6,
 "List of histogram Identifiers", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)8, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_MANY_PLOTS_parameters[] = {
 &_HISTOGRAM_MANY_PLOTS_IDLIST };
static char *_HISTOGRAM_MANY_PLOTS_guidance[] = {
 "Plot one or several histograms into the same plot.",
 "Plotted histograms are superimposed on the same zone", "of the picture." };
static KmCommand _HISTOGRAM_MANY_PLOTS = { &_HISTOGRAM_PROJECT,
 "/HISTOGRAM/MANY_PLOTS", "MANY_PLOTS", 0, 1, 1, 1,
 _HISTOGRAM_MANY_PLOTS_parameters, 0, 0, pahist_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 3, _HISTOGRAM_MANY_PLOTS_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_ZOOM_ID = { "ID", 2, "Histogram Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)2,
 KmTYPE_CHAR,  (void*)0 };
static char *_HISTOGRAM_ZOOM_CHOPT_range[] = { "", "C", "S", "+", "B", "L",
 "P", "*" };
static char *_HISTOGRAM_ZOOM_CHOPT_text[] = { "Plot the zoomed histogram.",
 "Draw a smooth curve.", "Superimpose plot on top of existing picture.",
 "Add contents of ID to last plotted histogram.", "Select Bar chart format.",
 "Connect channels contents by a line.",
 "Draw the current polymarker at each channel.", "Draw a * at each channel." };
static KmParOption _HISTOGRAM_ZOOM_CHOPT_type = { _HISTOGRAM_ZOOM_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_ZOOM_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 8, _HISTOGRAM_ZOOM_CHOPT_range, 8, _HISTOGRAM_ZOOM_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_HISTOGRAM_ZOOM_CHOPT_type };
static KmParInt    _HISTOGRAM_ZOOM_ICMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_ZOOM_ICMIN = { "ICMIN", 5, "First channel", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_HISTOGRAM_ZOOM_ICMIN_type };
static KmParInt    _HISTOGRAM_ZOOM_ICMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_ZOOM_ICMAX = { "ICMAX", 5, "Last channel",
 "9999", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_HISTOGRAM_ZOOM_ICMAX_type };
static KmParameter *_HISTOGRAM_ZOOM_parameters[] = { &_HISTOGRAM_ZOOM_ID,
 &_HISTOGRAM_ZOOM_CHOPT, &_HISTOGRAM_ZOOM_ICMIN, &_HISTOGRAM_ZOOM_ICMAX };
static char *_HISTOGRAM_ZOOM_guidance[] = {
 "Plot a single histogram between channels ICMIN and ICMAX.",
 "Each plotted histogram will start either a new picture or a new zone",
 "in the current picture.",
 "If no parameters are given to the command, then the system waits",
 "for two points using the graphics cursor.",
 "To quit ZOOM, click the right button of the mouse or CRTL/E." };
static KmCommand _HISTOGRAM_ZOOM = { &_HISTOGRAM_MANY_PLOTS,
 "/HISTOGRAM/ZOOM", "ZOOM", 0, 1, 4, 0, _HISTOGRAM_ZOOM_parameters, 1, 0,
 pahist_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 6,
 _HISTOGRAM_ZOOM_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParameter _HISTOGRAM_PLOT_ID = { "ID", 2, "Histogram Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)2,
 KmTYPE_CHAR,  (void*)0 };
static char *_HISTOGRAM_PLOT_CHOPT_range[] = { "", "C", "S", "+", "-", "+-",
 "B", "L", "P", "*", "K", "U", "E", "E0", "E1", "E2", "E3", "E4", "A", "BOX",
 "COL", "Z", "SURF", "SURF1", "SURF2", "SURF3", "SURF4", "LEGO", "LEGO1",
 "LEGO2", "BB", "FB", "CONT", "TEXT", "CHAR", "HIST", "FUNC", "CYL", "POL",
 "SPH", "PSD" };
static char *_HISTOGRAM_PLOT_CHOPT_text[] = { "Draw the histogram.",
 "Draw a smooth curve.", "Superimpose plot on top of existing picture.",
 "Add contents of ID to last plotted histogram.",
 "Substract contents of ID to last plotted histogram.",
 "Draw the delta with the last plotted histogram.",
 "Select Bar chart format.", "Connect channels contents by a line.",
 "Draw the current polymarker at each channel or cell.",
 "Draw a * at each channel.", "Must be given if option 'U' is given later.",
 "Update channels modified since last call.",
 "Draw error bars and current marker.",
 "Draw error bars without symbols clipping.",
 "Draw small lines at the end of the error bars.", "Draw error rectangles.",
 "Draw a filled area through the end points of the vertical error bars.",
 "Draw a smoothed filled area through the end points of the vertical error\
 bars.", "Axis labels and tick marks are not drawn.",
 "Draw 2-Dim with proportional boxes.", "Draw 2-Dim with a color table.",
 "Used with COL or SURF, it draws the color map.",
 "Draw as a surface plot (angles are set via the command angle).",
 "Draw as a surface with color levels",
 "Same as SURF1 but without cell lines.",
 "Same as SURF but with the contour plot (in color) on top.",
 "Draw as a surface with Gouraud shading.",
 "Draw as a lego plot (angles are set via the command angle).",
 "Draw lego plot with light simulation.", "Draw lego plot with color levels.",
 "Suppress the Back Box on 3D plots.", "Suppress the Front Box on 3D plots.",
 "Draw 2-Dim as a contour plot (15 levels).", "Draw 2-Dim as a table.",
 "Draw 2-Dim with characters (a la HBOOK).",
 "Draw only histogram (no errors or associated function).",
 "Draw only the associated function (not the histogram).",
 "Cylindrical coordinates for 3D plots.", "Polar coordinates for 3D plots.",
 "Spherical coordinates for 3D plots.",
 "Pseudo-rapidity/phi coordinates for 3D plots." };
static KmParOption _HISTOGRAM_PLOT_CHOPT_type = { _HISTOGRAM_PLOT_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_PLOT_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 41, _HISTOGRAM_PLOT_CHOPT_range, 41,
 _HISTOGRAM_PLOT_CHOPT_range, (KmParFlag)2, KmTYPE_OPTION,
 &_HISTOGRAM_PLOT_CHOPT_type };
static KmParameter *_HISTOGRAM_PLOT_parameters[] = { &_HISTOGRAM_PLOT_ID,
 &_HISTOGRAM_PLOT_CHOPT };
static char *_HISTOGRAM_PLOT_guidance[] = {
 "Plot a single histogram or a 2-Dim projection.",
 "If ID=0 or ID=* all the histograms in the current directory are plotted.",
 "Each plotted histogram will start either a new picture or a new zone in",
 "the current picture.",
 " Histogram subranges can be specified in 2 different ways:",
 "  1- h/pl id(ic1:ic2) with ic1 and ic2 integers means plot",
 "                      from channel ic1 to channel ic2",
 "  2- h/pl id(x1:x2)   with x1 and x2 reals (with a .) means plot",
 "                      from channel corresponding to x1",
 "  Note that the mixed mode h/pl id(x1:ic2) is also accepted",
 "  This subrange works also for 2-DIM cases.",
 "  Ex: Histo/plot 10(25:1.) or Histo/plot 20(4:18,0.:0.5).",
 "A specific histogram cycle can be accessed:",
 "  PAW > h/pl id;nc | cycle number nc is used (default is highest cycle)",
 "1 Dim histograms could be plotted with option LEGO or SURF.",
 "In this case the angles are THETA=1 and PHI=-1.", "",
 "When option 'E' is used, the marker type can be changed with SET MTYP,",
 "the marker size with SET KSIZ, the marker color with SET PMCI.", "",
 "With Option E1, the size of the tick marks at the end of the error",
 "bars is equal to the marker size and can be changed with SET KSIZ.", "",
 "When the option E is used with the option SURF1, SURF2, SURF3 or LEGO1,",
 "the colors are mapped on the errors not on the content of the histogram.",
 "", " To plot projection X of ID type", "   PAW > HI/PLOT ID.PROX",
 " To plot band 1 in Y of ID type", "   PAW > HI/PLOT ID.BANY.1",
 " To plot slice 3 in Y of ID type", "   PAW > HI/PLOT ID.SLIY.3", "",
 "In addition to the Cartesian coordinate systems, Polar, cylindrical,",
 "spherical, pseudo-rapidity/phi coordinates are available for LEGO and",
 "SURFACE plots, including stacked lego plots.", "For example:",
 "      PAW > Histo/plot 10+20+30  LEGO1,CYL | stacked cylindrical lego plot",
 "      PAW > Histo/plot 10+20+30  LEGO1,POL |         polar",
 "      PAW > Histo/plot 10+20+30  LEGO1,SPH |         spherical",
 "      PAW > Histo/plot 10+20+30  LEGO1,PSD |         pseudo-rapidity/phi",
 "Note that the viewing angles may be changed via the command ANGLES.",
 "The axis, the front box, and the back box can be suppressed on 3D plots",
 "with the options 'A', 'FB' and 'BB'." };
static KmCommand _HISTOGRAM_PLOT = { &_HISTOGRAM_ZOOM, "/HISTOGRAM/PLOT",
 "PLOT", 0, 1, 2, 0, _HISTOGRAM_PLOT_parameters, 1, 0, pahist_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 44, _HISTOGRAM_PLOT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_DELETE_ID = { "ID", 2, "Histogram Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_DELETE_parameters[] = { &_HISTOGRAM_DELETE_ID };
static char *_HISTOGRAM_DELETE_guidance[] = {
 "Delete histogram/Ntuple ID in Current Directory (memory).",
 "If ID=0 delete all histograms and Ntuples.",
 "To delete histograms in disk files use command HIO/HSCRATCH." };
static KmCommand _HISTOGRAM_DELETE = { &_HISTOGRAM_PLOT, "/HISTOGRAM/DELETE",
 "DELETE", 0, 1, 1, 1, _HISTOGRAM_DELETE_parameters, 1, 0, pahist_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3, _HISTOGRAM_DELETE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_HISTOGRAM_LIST_CHOPT_range[] = { "", "I", "S" };
static char *_HISTOGRAM_LIST_CHOPT_text[] = {
 "List histograms and Ntuples in the current directory.",
 "A verbose format is used (HINDEX), (only for //PAWC).",
 "List with histograms sorted by increasing IDs." };
static KmParOption _HISTOGRAM_LIST_CHOPT_type = { _HISTOGRAM_LIST_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_LIST_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 3, _HISTOGRAM_LIST_CHOPT_range, 3, _HISTOGRAM_LIST_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_HISTOGRAM_LIST_CHOPT_type };
static KmParameter *_HISTOGRAM_LIST_parameters[] = { &_HISTOGRAM_LIST_CHOPT };
static char *_HISTOGRAM_LIST_guidance[] = {
 "List histograms and Ntuples in the current directory." };
static KmCommand _HISTOGRAM_LIST = { &_HISTOGRAM_DELETE, "/HISTOGRAM/LIST",
 "LIST", 0, 1, 1, 0, _HISTOGRAM_LIST_parameters, 0, 0, pahist_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _HISTOGRAM_LIST_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _HISTOGRAM_FILE_LUN_type = { "0", "128", "0", "128", 0 };
static KmParameter _HISTOGRAM_FILE_LUN = { "LUN", 3, "Logical unit number",
 (char*)0, (char*)0, 4, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_HISTOGRAM_FILE_LUN_type };
static KmParameter _HISTOGRAM_FILE_FNAME = { "FNAME", 5, "File name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_FILE_LRECL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_FILE_LRECL = { "LRECL", 5,
 "Record length in words", "1024", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_FILE_LRECL_type };
static char *_HISTOGRAM_FILE_CHOPT_range[] = { "", "N", "U", "D" };
static char *_HISTOGRAM_FILE_CHOPT_text[] = {
 "Existing file is opened (read mode only).", "A new file is opened.",
 "Existing file is opened to be modified.", "Reset lock." };
static KmParOption _HISTOGRAM_FILE_CHOPT_type = { _HISTOGRAM_FILE_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_FILE_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 4, _HISTOGRAM_FILE_CHOPT_range, 4, _HISTOGRAM_FILE_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_HISTOGRAM_FILE_CHOPT_type };
static KmParameter *_HISTOGRAM_FILE_parameters[] = { &_HISTOGRAM_FILE_LUN,
 &_HISTOGRAM_FILE_FNAME, &_HISTOGRAM_FILE_LRECL, &_HISTOGRAM_FILE_CHOPT };
static char *_HISTOGRAM_FILE_guidance[] = {
 "Open an HBOOK direct access file.",
 "If LUN is 0 the next free logical unit will be used.",
 "If LRECL is 0 the system will determine the correct",
 "record length of an existing file." };
static KmCommand _HISTOGRAM_FILE = { &_HISTOGRAM_LIST, "/HISTOGRAM/FILE",
 "FILE", 0, 1, 4, 2, _HISTOGRAM_FILE_parameters, 0, 0, pahist_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _HISTOGRAM_FILE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_HISTOGRAM_guidance[] = { "Manipulation of histograms, Ntuples.",
 "Interface to the HBOOK package." };
static KmMenu _HISTOGRAM = {  (KmMenu*)0, &_HISTOGRAM_2D_PLOT, "/HISTOGRAM",
 "HISTOGRAM", 1, &_HISTOGRAM_FILE, 2, _HISTOGRAM_guidance, 0, (char**)0, 0,
 (char**)0 };

  klnkmenu( &_HISTOGRAM, 950303 );
}


#ifdef F77_LCASE
#  define fundef_ fundef
#  define pafunc_ pafunc
#endif

#ifdef F77_UCASE
#  define fundef_ FUNDEF
#  define pafunc_ PAFUNC
#endif

#ifdef IBM370
#  pragma linkage(FUNDEF,FORTRAN)
#  pragma linkage(PAFUNC,FORTRAN)
#endif

extern void fundef_();
extern void pafunc_();

void fundef_()
{

static KmParReal   _FUNCTION_ANGLE_THETA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _FUNCTION_ANGLE_THETA = { "THETA", 5,
 "Angle THETA in degrees", "30.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_FUNCTION_ANGLE_THETA_type };
static KmParReal   _FUNCTION_ANGLE_PHI_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _FUNCTION_ANGLE_PHI = { "PHI", 3, "Angle PHI in degrees",
 "30.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_FUNCTION_ANGLE_PHI_type };
static KmParameter *_FUNCTION_ANGLE_parameters[] = { &_FUNCTION_ANGLE_THETA,
 &_FUNCTION_ANGLE_PHI };
static char *_FUNCTION_ANGLE_guidance[] = {
 "Change the angle used by FUN/DRAW and HISTO/PLOT." };
static KmCommand _FUNCTION_ANGLE = {  (KmCommand*)0, "/FUNCTION/ANGLE",
 "ANGLE", 0, 1, 2, 0, _FUNCTION_ANGLE_parameters, 0, 0, pafunc_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _FUNCTION_ANGLE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _FUNCTION_RANGE_XLOW_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _FUNCTION_RANGE_XLOW = { "XLOW", 4, "X Lower limit", "-1.",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_FUNCTION_RANGE_XLOW_type };
static KmParReal   _FUNCTION_RANGE_XUP_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _FUNCTION_RANGE_XUP = { "XUP", 3, "X Upper limit", "1.",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_FUNCTION_RANGE_XUP_type };
static KmParReal   _FUNCTION_RANGE_YLOW_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _FUNCTION_RANGE_YLOW = { "YLOW", 4, "Y Lower limit", "-1.",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_FUNCTION_RANGE_YLOW_type };
static KmParReal   _FUNCTION_RANGE_YUP_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _FUNCTION_RANGE_YUP = { "YUP", 3, "Y Upper limit", "1",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_FUNCTION_RANGE_YUP_type };
static KmParReal   _FUNCTION_RANGE_ZLOW_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _FUNCTION_RANGE_ZLOW = { "ZLOW", 4, "Z Lower limit", "-1.",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_FUNCTION_RANGE_ZLOW_type };
static KmParReal   _FUNCTION_RANGE_ZUP_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _FUNCTION_RANGE_ZUP = { "ZUP", 3, "Z Upper limit", "1.",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_FUNCTION_RANGE_ZUP_type };
static KmParameter *_FUNCTION_RANGE_parameters[] = { &_FUNCTION_RANGE_XLOW,
 &_FUNCTION_RANGE_XUP, &_FUNCTION_RANGE_YLOW, &_FUNCTION_RANGE_YUP,
 &_FUNCTION_RANGE_ZLOW, &_FUNCTION_RANGE_ZUP };
static char *_FUNCTION_RANGE_guidance[] = {
 "Change the range used by FUN/DRAW." };
static KmCommand _FUNCTION_RANGE = { &_FUNCTION_ANGLE, "/FUNCTION/RANGE",
 "RANGE", 0, 1, 6, 0, _FUNCTION_RANGE_parameters, 0, 0, pafunc_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _FUNCTION_RANGE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _FUNCTION_POINTS_NPX_type = { "2", "1000", "2", "1000", 0 };
static KmParameter _FUNCTION_POINTS_NPX = { "NPX", 3,
 "Number of points on X axis", "20", (char*)0, 5, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_FUNCTION_POINTS_NPX_type };
static KmParInt    _FUNCTION_POINTS_NPY_type = { "2", "1000", "2", "1000", 0 };
static KmParameter _FUNCTION_POINTS_NPY = { "NPY", 3,
 "Number of points on Y axis", "20", (char*)0, 5, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_FUNCTION_POINTS_NPY_type };
static KmParInt    _FUNCTION_POINTS_NPZ_type = { "2", "1000", "2", "1000", 0 };
static KmParameter _FUNCTION_POINTS_NPZ = { "NPZ", 3,
 "Number of points on Z axis", "20", (char*)0, 5, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_FUNCTION_POINTS_NPZ_type };
static KmParameter *_FUNCTION_POINTS_parameters[] = { &_FUNCTION_POINTS_NPX,
 &_FUNCTION_POINTS_NPY, &_FUNCTION_POINTS_NPZ };
static char *_FUNCTION_POINTS_guidance[] = {
 "Change the number of points to be used by FUN/DRAW",
 "and FUN/PLOT. Note that the default for NPX is 20 for 3-Dim plots",
 "(FUN/DRAW) but it is 100 for 1-Dim plots (FUN/PLOT)." };
static KmCommand _FUNCTION_POINTS = { &_FUNCTION_RANGE, "/FUNCTION/POINTS",
 "POINTS", 0, 1, 3, 0, _FUNCTION_POINTS_parameters, 0, 0, pafunc_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3, _FUNCTION_POINTS_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _FUNCTION_PLOT_UFUNC = { "UFUNC", 5, "Name of function",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParReal   _FUNCTION_PLOT_XLOW_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _FUNCTION_PLOT_XLOW = { "XLOW", 4, "Lower limit", (char*)0,
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_FUNCTION_PLOT_XLOW_type };
static KmParReal   _FUNCTION_PLOT_XUP_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _FUNCTION_PLOT_XUP = { "XUP", 3, "Upper limit", (char*)0,
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_FUNCTION_PLOT_XUP_type };
static char *_FUNCTION_PLOT_CHOPT_range[] = { "C", "S", "+", "L", "P", "*" };
static char *_FUNCTION_PLOT_CHOPT_text[] = { "Draw a smooth curve.",
 "Superimpose plot on top of existing picture.",
 "Add contents of ID to last plotted histogram.",
 "Connect channel contents by a line.",
 "Draw the current polymarker at each channel.", "Draw a * at each channel." };
static KmParOption _FUNCTION_PLOT_CHOPT_type = { _FUNCTION_PLOT_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _FUNCTION_PLOT_CHOPT = { "CHOPT", 5, "Options", "C",
 (char*)0, 8, 6, _FUNCTION_PLOT_CHOPT_range, 6, _FUNCTION_PLOT_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_FUNCTION_PLOT_CHOPT_type };
static KmParameter *_FUNCTION_PLOT_parameters[] = { &_FUNCTION_PLOT_UFUNC,
 &_FUNCTION_PLOT_XLOW, &_FUNCTION_PLOT_XUP, &_FUNCTION_PLOT_CHOPT };
static char *_FUNCTION_PLOT_guidance[] = {
 "Plot single-valued function UFUNC between XLOW and XUP.",
 "The function UFUNC may be given in two ways:", "",
 "-An expression of the variable x in case of a simple function.",
 " Ex: FUN/PLOT   sin(x)/x  0 10",
 "-UFUNC is the name of a COMIS function in a text file with the",
 "name UFUNC.FTN or UFUNC.FOR or UFUNC FORTRAN (Apollo, VAX, IBM).",
 "For example, if the file FTEST.FOR contains:", "      FUNCTION FTEST(X)",
 "      FTEST=SIN(X)*EXP(-0.1*X)", "      END",
 "Then, FUN/PLOT FTEST.FOR 0 10, will interpret the Fortran",
 "code in the file FTEST.FOR and draw the function for x",
 "between 0 and 10.", "",
 "The number of points to evaluate the function between XLOW and XUP",
 "can be changed by the command /FUN/POINTS. Only 1-Dim functions",
 "are supported. For 2-Dim use FUN2." };
static KmCommand _FUNCTION_PLOT = { &_FUNCTION_POINTS, "/FUNCTION/PLOT",
 "PLOT", 0, 1, 4, 3, _FUNCTION_PLOT_parameters, 0, 0, pafunc_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 18, _FUNCTION_PLOT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _FUNCTION_DRAW_UFUNC = { "UFUNC", 5, "Name of function",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParOption _FUNCTION_DRAW_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _FUNCTION_DRAW_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_FUNCTION_DRAW_CHOPT_type };
static KmParameter *_FUNCTION_DRAW_parameters[] = { &_FUNCTION_DRAW_UFUNC,
 &_FUNCTION_DRAW_CHOPT };
static char *_FUNCTION_DRAW_guidance[] = { "Draw the function UFUNC",
 "in the current ranges specified by the command:",
 "RANGE XLOW XUP YLOW YUP ZLOW ZUP and with THETHA and PHI angles",
 "specified by the command ANGLE THETA PHI. The number of points",
 "to evaluate the function between XLOW, XUP YLOW, YUP, and ZLOW, ZUP",
 "can be changed by the command POINTS NPX NPY NPZ.", "",
 "The function UFUNC may be given in two ways:", "",
 "- As an expression of the variables X, Y, Z in the case of a",
 "  simple function.", "  Ex:",
 "  PAW >  FUN/DRAW X*Y*Z         | equivalent to :",
 "  PAW >  FUN/DRAW X*Y*Z=0", "  PAW >  FUN/DRAW X**2+Y**2+Z**2=1",
 "  PAW >  FUN/DRAW X**2+Y**2=1-Z**2", "",
 "- As a COMIS function in a text file (ftest.f for example)", "  Ex:",
 "  The file ftest.f contains:", "", "  FUNCTION FTEST(X,Y,Z)",
 "  IF(X.LE.0..AND.Y.LE.0.)THEN",
 "    FTEST=(X+0.5)**2+(Y+0.5)**2+(Z+0.5)**2-0.2", "  ELSE",
 "    FTEST=(X-0.5)**2+(Y-0.5)**2+(Z-0.5)**2-0.1", "  ENDIF", "  END", "",
 "  PAW > RANGE -1 1 -1 1 -1 1  | Define the range as a cube between -1 1 in\
 the 3", "                                directions",
 "  PAW > POINTS 20 20 20       | FUN/DRAW will use 20 points in the 3\
 directions",
 "  PAW > FUN/DRAW FTEST.FOR    | Draw 2 spheres centered on\
 (-0.5,-0.5,-0.5)",
 "                                and (0.5,0.5,0.5) with the radius\
 SQRT(0.2)", "                                and SQRT(0.1)" };
static KmCommand _FUNCTION_DRAW = { &_FUNCTION_PLOT, "/FUNCTION/DRAW", "DRAW",
 0, 1, 2, 1, _FUNCTION_DRAW_parameters, 0, 0, pafunc_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 35, _FUNCTION_DRAW_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _FUNCTION_FUN2_ID = { "ID", 2,
 "Histogram (2-Dim) Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _FUNCTION_FUN2_UFUNC = { "UFUNC", 5,
 "Name of the function", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _FUNCTION_FUN2_NCX_type = { "1", (char*)0, "1", (char*)0, 0
 };
static KmParameter _FUNCTION_FUN2_NCX = { "NCX", 3, "Number of channels in X",
 "40", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_FUNCTION_FUN2_NCX_type };
static KmParReal   _FUNCTION_FUN2_XMIN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _FUNCTION_FUN2_XMIN = { "XMIN", 4, "Low edge in X", "0.",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_FUNCTION_FUN2_XMIN_type };
static KmParReal   _FUNCTION_FUN2_XMAX_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _FUNCTION_FUN2_XMAX = { "XMAX", 4, "Upper edge in X",
 "40.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_FUNCTION_FUN2_XMAX_type };
static KmParInt    _FUNCTION_FUN2_NCY_type = { "1", (char*)0, "1", (char*)0, 0
 };
static KmParameter _FUNCTION_FUN2_NCY = { "NCY", 3, "Number of channels in Y",
 "40", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_FUNCTION_FUN2_NCY_type };
static KmParReal   _FUNCTION_FUN2_YMIN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _FUNCTION_FUN2_YMIN = { "YMIN", 4, "Low edge in Y", "0.",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_FUNCTION_FUN2_YMIN_type };
static KmParReal   _FUNCTION_FUN2_YMAX_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _FUNCTION_FUN2_YMAX = { "YMAX", 4, "Upper edge in Y",
 "40.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_FUNCTION_FUN2_YMAX_type };
static char *_FUNCTION_FUN2_CHOPT_range[] = { "", "S", "A", "BOX", "COL", "Z",
 "SURF", "SURF1", "SURF2", "SURF3", "SURF4", "LEGO", "LEGO1", "LEGO2", "BB",
 "FB", "CONT", "TEXT", "CHAR", "CYL", "POL", "SPH", "PSD" };
static char *_FUNCTION_FUN2_CHOPT_text[] = {
 "Create the histogram (don't draw).",
 "Superimpose plot on top of existing picture.",
 "Axis labels and tick marks are not drawn.",
 "Draw 2-Dim with proportional boxes.", "Draw 2-Dim with a color table.",
 "Used with COL or SURF, it draws the color map.",
 "Draw as a surface plot (angles are set via the command angle).",
 "Draw as a surface with color levels",
 "Same as SURF1 but without cell lines.",
 "Same as SURF but with the contour plot (in color) on top.",
 "Draw as a surface with Gouraud shading.",
 "Draw as a lego plot (angles are set via the command angle).",
 "Draw lego plot with light simulation.", "Draw lego plot with color levels.",
 "Suppress the Back Box on 3D plots.", "Suppress the Front Box on 3D plots.",
 "Draw 2-Dim as a contour plot (15 levels).", "Draw 2-Dim as a table.",
 "Draw 2-Dim with characters (a la HBOOK).",
 "Cylindrical coordinates for 3D plots.", "Polar coordinates for 3D plots.",
 "Spherical coordinates for 3D plots.",
 "Pseudo-rapidity/phi coordinates for 3D plots." };
static KmParOption _FUNCTION_FUN2_CHOPT_type = { _FUNCTION_FUN2_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _FUNCTION_FUN2_CHOPT = { "CHOPT", 5, "Options", "SURF",
 (char*)0, 8, 23, _FUNCTION_FUN2_CHOPT_range, 23, _FUNCTION_FUN2_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_FUNCTION_FUN2_CHOPT_type };
static KmParameter *_FUNCTION_FUN2_parameters[] = { &_FUNCTION_FUN2_ID,
 &_FUNCTION_FUN2_UFUNC, &_FUNCTION_FUN2_NCX, &_FUNCTION_FUN2_XMIN,
 &_FUNCTION_FUN2_XMAX, &_FUNCTION_FUN2_NCY, &_FUNCTION_FUN2_YMIN,
 &_FUNCTION_FUN2_YMAX, &_FUNCTION_FUN2_CHOPT };
static char *_FUNCTION_FUN2_guidance[] = {
 "Create a two dimensional histogram and fill",
 "the bins with the values of a (two-valued) function.", "",
 "The function UFUNC may be given in two ways:", "",
 "- As an expression of the variables x and y in case of a simple function.",
 "  Ex:", "  PAW > FUN2 10 ABS(SIN(X**2+Y**2)) 40 -2 2 40 -2 2 CONT", "",
 "- As a COMIS function in a text file (ftest.f for example)", "  Ex:",
 "  The file FTEST.F contains:", "", "  FUNCTION FTEST(X,Y)",
 "  FTEST=ABS(SIN(X**2+Y**2))", "  END", "",
 "  PAW > FUN2 10 FTEST.F 40 -2 2 40 -2 2 CONT" };
static KmCommand _FUNCTION_FUN2 = { &_FUNCTION_DRAW, "/FUNCTION/FUN2", "FUN2",
 0, 1, 9, 8, _FUNCTION_FUN2_parameters, 0, 0, pafunc_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 18, _FUNCTION_FUN2_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _FUNCTION_FUN1_ID = { "ID", 2, "Histogram Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _FUNCTION_FUN1_UFUNC = { "UFUNC", 5,
 "Name of the function", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _FUNCTION_FUN1_NCX_type = { "1", (char*)0, "1", (char*)0, 0
 };
static KmParameter _FUNCTION_FUN1_NCX = { "NCX", 3, "Number of channels",
 "100", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_FUNCTION_FUN1_NCX_type };
static KmParReal   _FUNCTION_FUN1_XMIN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _FUNCTION_FUN1_XMIN = { "XMIN", 4, "Low edge", "0.",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_FUNCTION_FUN1_XMIN_type };
static KmParReal   _FUNCTION_FUN1_XMAX_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _FUNCTION_FUN1_XMAX = { "XMAX", 4, "Upper edge", "100.",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_FUNCTION_FUN1_XMAX_type };
static char *_FUNCTION_FUN1_CHOPT_range[] = { "", "C", "S", "E", "E0", "E1",
 "E2", "E3", "E4", "A" };
static char *_FUNCTION_FUN1_CHOPT_text[] = {
 "Create the histogram (don't draw).", "Draw a smooth curve.",
 "Superimpose plot on top of existing picture.",
 "Draw error bars and current marker.",
 "Draw error bars without symbols clipping.",
 "Draw small lines at the end of the error bars.", "Draw error rectangles.",
 "Draw a filled area through the end points of the vertical error bars.",
 "Draw a smoothed filled area through the end points of the vertical error\
 bars.", "Axis labels and tick marks are not drawn." };
static KmParOption _FUNCTION_FUN1_CHOPT_type = { _FUNCTION_FUN1_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _FUNCTION_FUN1_CHOPT = { "CHOPT", 5, "Options", "C",
 (char*)0, 8, 10, _FUNCTION_FUN1_CHOPT_range, 10, _FUNCTION_FUN1_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_FUNCTION_FUN1_CHOPT_type };
static KmParameter *_FUNCTION_FUN1_parameters[] = { &_FUNCTION_FUN1_ID,
 &_FUNCTION_FUN1_UFUNC, &_FUNCTION_FUN1_NCX, &_FUNCTION_FUN1_XMIN,
 &_FUNCTION_FUN1_XMAX, &_FUNCTION_FUN1_CHOPT };
static char *_FUNCTION_FUN1_guidance[] = {
 "Create a one dimensional histogram and fill the bins with the",
 "values of a (single-valued) function.", "",
 "The function UFUNC may be given in two ways:", "",
 "- As an expression of the variable X in case of a simple function.",
 "  Ex:", "  PAW > FUN1  10 SIN(X)/X  100 0 10", "",
 "- As a COMIS function in a text file (ftest.f for example)", "  Ex:",
 "  The file ftest.f contains:", "", "  FUNCTION FTEST(X)",
 "  FTEST=SIN(X)/X", "  END", "", "  PAW > FUN1 10 FTEST.F 100 0 10" };
static KmCommand _FUNCTION_FUN1 = { &_FUNCTION_FUN2, "/FUNCTION/FUN1", "FUN1",
 0, 1, 6, 5, _FUNCTION_FUN1_parameters, 0, 0, pafunc_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 18, _FUNCTION_FUN1_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_FUNCTION_guidance[] = {
 "Operations with Functions. Creation and plotting." };
static KmMenu _FUNCTION = {  (KmMenu*)0,  (KmMenu*)0, "/FUNCTION", "FUNCTION",
 1, &_FUNCTION_FUN1, 1, _FUNCTION_guidance, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_FUNCTION, 950303 );
}


#ifdef F77_LCASE
#  define ntudef_ ntudef
#  define pvmem_ pvmem
#  define palint_ palint
#  define pawuwf_ pawuwf
#  define pamask_ pamask
#  define pnutil_ pnutil
#  define pacuts_ pacuts
#  define pawave_ pawave
#  define pandra_ pandra
#  define pchain_ pchain
#  define pantup_ pantup
#  define pamerg_ pamerg
#  define pascan_ pascan
#  define mergin_ mergin
#endif

#ifdef F77_UCASE
#  define ntudef_ NTUDEF
#  define pvmem_ PVMEM
#  define palint_ PALINT
#  define pawuwf_ PAWUWF
#  define pamask_ PAMASK
#  define pnutil_ PNUTIL
#  define pacuts_ PACUTS
#  define pawave_ PAWAVE
#  define pandra_ PANDRA
#  define pchain_ PCHAIN
#  define pantup_ PANTUP
#  define pamerg_ PAMERG
#  define pascan_ PASCAN
#  define mergin_ MERGIN
#endif

#ifdef IBM370
#  pragma linkage(NTUDEF,FORTRAN)
#  pragma linkage(PVMEM,FORTRAN)
#  pragma linkage(PALINT,FORTRAN)
#  pragma linkage(PAWUWF,FORTRAN)
#  pragma linkage(PAMASK,FORTRAN)
#  pragma linkage(PNUTIL,FORTRAN)
#  pragma linkage(PACUTS,FORTRAN)
#  pragma linkage(PAWAVE,FORTRAN)
#  pragma linkage(PANDRA,FORTRAN)
#  pragma linkage(PCHAIN,FORTRAN)
#  pragma linkage(PANTUP,FORTRAN)
#  pragma linkage(PAMERG,FORTRAN)
#  pragma linkage(PASCAN,FORTRAN)
#  pragma linkage(MERGIN,FORTRAN)
#endif

extern void ntudef_();
extern void pvmem_();
extern void palint_();
extern void pawuwf_();
extern void pamask_();
extern void pnutil_();
extern void pacuts_();
extern void pawave_();
extern void pandra_();
extern void pchain_();
extern void pantup_();
extern void pamerg_();
extern void pascan_();
extern void mergin_();

void ntudef_()
{

static KmParInt    _NTUPLE_VMEM_MXSIZE_type = { "-2", "128", "-2", "128", 0 };
static KmParameter _NTUPLE_VMEM_MXSIZE = { "MXSIZE", 6,
 "Maximum size of dynamic memory buffer in MBytes", "-1", (char*)0, 4, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT, &_NTUPLE_VMEM_MXSIZE_type
 };
static KmParameter *_NTUPLE_VMEM_parameters[] = { &_NTUPLE_VMEM_MXSIZE };
static char *_NTUPLE_VMEM_guidance[] = {
 "Change or show the size of the dynamic memory buffer used to store",
 "Ntuple columns during Ntuple analysis. The default is 10 MB. Giving",
 "a value of 0 turns the buffer facility off. The upper limit is 128 MB,",
 "but be sure you have enough swap space and realize that when the buffer",
 "is swapped to disk you loose part of the benefit of the buffer facility",
 "(which is to reduce the number of disk accesses). Omitting the argument",
 "or specifying -1 will show you the current upper limit and used and free",
 "space. Giving -2 shows which columns are currently stored in memory." };
static KmCommand _NTUPLE_VMEM = {  (KmCommand*)0, "/NTUPLE/VMEM", "VMEM", 0,
 1, 1, 0, _NTUPLE_VMEM_parameters, 0, 0, pvmem_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 8, _NTUPLE_VMEM_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_LINTRA_IDN = { "IDN", 3, "Ntuple Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static char *_NTUPLE_LINTRA_CHOPT_range[] = { "N", "P" };
static char *_NTUPLE_LINTRA_CHOPT_text[] = {
 "The variables are normalized. This option is useful in the case the ranges\
 of variables are very different", "Print more results about the analysis" };
static KmParOption _NTUPLE_LINTRA_CHOPT_type = { _NTUPLE_LINTRA_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _NTUPLE_LINTRA_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 2, _NTUPLE_LINTRA_CHOPT_range, 2, _NTUPLE_LINTRA_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_NTUPLE_LINTRA_CHOPT_type };
static KmParInt    _NTUPLE_LINTRA_NEVENT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _NTUPLE_LINTRA_NEVENT = { "NEVENT", 6, "Number of events",
 "99999999", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_NTUPLE_LINTRA_NEVENT_type };
static KmParInt    _NTUPLE_LINTRA_IFIRST_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _NTUPLE_LINTRA_IFIRST = { "IFIRST", 6, "First event", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_LINTRA_IFIRST_type };
static KmParInt    _NTUPLE_LINTRA_NVARS_type = { "0", "20", "0", "20", 0 };
static KmParameter _NTUPLE_LINTRA_NVARS = { "NVARS", 5,
 "Number of the most significant variables ", "20", (char*)0, 3, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_INT, &_NTUPLE_LINTRA_NVARS_type };
static KmParameter _NTUPLE_LINTRA_VARLIS = { "VARLIS", 6,
 "Names of the NVARS most significant variables ", (char*)0, (char*)0, 20, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_NTUPLE_LINTRA_parameters[] = { &_NTUPLE_LINTRA_IDN,
 &_NTUPLE_LINTRA_CHOPT, &_NTUPLE_LINTRA_NEVENT, &_NTUPLE_LINTRA_IFIRST,
 &_NTUPLE_LINTRA_NVARS, &_NTUPLE_LINTRA_VARLIS };
static char *_NTUPLE_LINTRA_guidance[] = { "Data reduction on Ntuple.",
 "The method used is the PRINCIPAL COMPONENTS ANALYSIS.",
 "The Principal Components Analysis method consists in applying",
 "a linear transformation to the original variables of a ntuple.",
 "This transformation is described by an orthogonal matrix and",
 "is equivalent to a rotation of the original space to a new set",
 "of coordinates vectors, which hopefully provide easier identification",
 "and dimensionality reduction. This matrix is real positive definite",
 "and symmetric and has all its eigenvalues greater than zero.",
 "Among the family of all complete orthonormal bases, the basis",
 "formed by the eigenvectors of the covariance matrix and belonging",
 "to the largest eigenvalues corresponds to the most significant features",
 "for the description of the original ntuple.",
 "Reduction of the variables for NEVENT events starting at IFIRST",
 "The default is to take all the 20 first variables.",
 "This command creates a file : -> XTOXSI.FORTRAN or xtoxsi.for,xtoxsi.ftn.",
 "This file contains a Fortran function which computes the new variables.",
 "These new variables can be visualized in PAW with for example:",
 " PAW > Ntuple/plot id.xtoxsi.ftn(1)",
 " PAW > Ntuple/plot id.xtoxsi.ftn(1)%xtoxsi.ftn(3)" };
static KmCommand _NTUPLE_LINTRA = { &_NTUPLE_VMEM, "/NTUPLE/LINTRA", "LINTRA",
 0, 1, 6, 1, _NTUPLE_LINTRA_parameters, 0, 0, palint_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 20, _NTUPLE_LINTRA_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_UWFUNC_IDN = { "IDN", 3, "Ntuple Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_UWFUNC_FNAME = { "FNAME", 5, "File name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_NTUPLE_UWFUNC_CHOPT_range[] = { "", "E", "P", "T" };
static char *_NTUPLE_UWFUNC_CHOPT_text[] = {
 "Generate the FORTRAN skeleton of a selection function.",
 "Present the selection function in the local editor.",
 "Code to print events is generated (not valid for new Ntuples).",
 "Names of the Ntuple variables are generated in DATA statements (not valid\
 for new Ntuples)." };
static KmParOption _NTUPLE_UWFUNC_CHOPT_type = { _NTUPLE_UWFUNC_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _NTUPLE_UWFUNC_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 4, _NTUPLE_UWFUNC_CHOPT_range, 4, _NTUPLE_UWFUNC_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_NTUPLE_UWFUNC_CHOPT_type };
static KmParameter *_NTUPLE_UWFUNC_parameters[] = { &_NTUPLE_UWFUNC_IDN,
 &_NTUPLE_UWFUNC_FNAME, &_NTUPLE_UWFUNC_CHOPT };
static char *_NTUPLE_UWFUNC_guidance[] = {
 "To generate the FORTRAN skeleton of a selection function or the",
 "INCLUDE file with the columns declaration.", "",
 "A FORTRAN function is generated if the FNAME is of the form,",
 "xxx.f, xxx.for, xxx.fortran. Otherwise an INCLUDE file is generated.",
 "Example:",
 "If Ntuple ID=30 has variable names [X,Y,Z,ETOT,EMISS,etc] then:", "",
 "NTUPLE/UWFUNC 30 SELECT.FOR   will generate the file SELECT.FOR with:",
 "      FUNCTION SELECT(XDUMMY)",
 "      COMMON/PAWIDN/IDNEVT,VIDN1,VIDN2,VIDN3,X,Y,Z,ETOT,EMISS,etc",
 "      SELECT=1.", "      END",
 "Then using the command EDIT one can modify this file which could then",
 "look something like (IDNEVT is the event number):",
 "      FUNCTION SELECT(XDUMMY)",
 "      COMMON/PAWIDN/IDNEVT,VIDN1,VIDN2,VIDN3,X,Y,Z,ETOT,EMISS,etc",
 "      IF(X**2+Y**2.GT.Z**2.OR.ETOT.GT.20.)THEN", "         SELECT=1.",
 "      ELSE", "         SELECT=0.", "      ENDIF", "      END",
 "If in a subsequent command NTUPLE/PLOT, the selection function SELECT",
 "is used, then:", "   If NTUPLE/PLOT 30.ETOT SELECT.FOR", "      VIDN1=ETOT",
 "   If NTUPLE/PLOT 30.SQRT(X**2+Y**2)%(ETOT-EMISS)",
 "      VIDN1=ETOT-EMISS", "      VIDN2=SQRT(X**2+Y**2)", "",
 "NTUPLE/UWFUNC 30 SELECT.INC will generate an include file. This include\
 file", "may be referenced in a selection function in the following way:",
 "      FUNCTION SELECT(XDUMMY)", "      include 'select.inc'",
 "      SELECT=1.", "      IF(X.LE.Y)SELECT=0.", "      END", "",
 "Note that the command UWFUNC is not required if the SELECT function has\
 the", "following form:", "      FUNCTION SELECT(XDUMMY)", "      include ?",
 "      SELECT=1.", "      IF(X.LE.Y)SELECT=0.", "      END",
 "In this case (thanks to the statement 'include ?') the include file will\
 be", "generated automatically with the name 'comis.inc'." };
static KmCommand _NTUPLE_UWFUNC = { &_NTUPLE_LINTRA, "/NTUPLE/UWFUNC",
 "UWFUNC", 0, 1, 3, 2, _NTUPLE_UWFUNC_parameters, 0, 0, pawuwf_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 48, _NTUPLE_UWFUNC_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_MASK_MNAME = { "MNAME", 5, "Mask name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_NTUPLE_MASK_CHOPT_range[] = { "", "U", "N", "P", "C", "R" };
static char *_NTUPLE_MASK_CHOPT_text[] = {
 "Existing mask on file MNAME.MASK is attached for READ only.",
 "Existing mask on file MNAME.MASK is attached for UPDATE.",
 "A new mask on file MNAME.MASK is created for NUMBER events.",
 "The comments for all active bits is printed.", "Mask is closed.",
 "Reset bit number NUMBER.If NUMBER=99, resets all bits." };
static KmParOption _NTUPLE_MASK_CHOPT_type = { _NTUPLE_MASK_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _NTUPLE_MASK_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 6, _NTUPLE_MASK_CHOPT_range, 6, _NTUPLE_MASK_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_NTUPLE_MASK_CHOPT_type };
static KmParInt    _NTUPLE_MASK_NUMBER_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_MASK_NUMBER = { "NUMBER", 6, "Bit number", "0",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_MASK_NUMBER_type };
static KmParameter *_NTUPLE_MASK_parameters[] = { &_NTUPLE_MASK_MNAME,
 &_NTUPLE_MASK_CHOPT, &_NTUPLE_MASK_NUMBER };
static char *_NTUPLE_MASK_guidance[] = { "Perform Operations with masks.",
 "A mask is a direct-access file with the name MNAME.MASK.",
 "It must contain as many 32 bit words as there are events",
 "in the associated Ntuple.",
 "Masks are interesting when only a few events of a Ntuple are selected",
 "with a time consuming selection algorithm. For example if the command:",
 "   NT/PLOT 30.X  Z<0.4.AND.SELECT.FTN>>MNAME(6)",
 "then for all events in Ntuple 30 satisfying the condition above,",
 "the bit 6 in the corresponding mask words will be set. One can then use",
 "the mask as selection mechanism. Example:", "   NT/PLOT 30.X MNAME(6)",
 "will produce the same results than the NT/PLOT command above, but",
 "will be much faster if only a small fraction of all the events",
 "is selected.",
 "MASKS are automatically saved across PAW sessions on files.", "Example:",
 "   MASK  TEST N 10000",
 "      creates a new mask on file TEST.MASK with enough words to",
 "      process a Ntuple with 10000 events", "   MASK  TEST UP",
 "      opens an existing mask for update and",
 "      prints the active selection bits with explanation" };
static KmCommand _NTUPLE_MASK = { &_NTUPLE_UWFUNC, "/NTUPLE/MASK", "MASK", 0,
 1, 3, 1, _NTUPLE_MASK_parameters, 0, 0, pamask_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 22, _NTUPLE_MASK_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_NTUPLE_CSELECT_CHOPT_range[] = { "", "R", "C", "B", "N" };
static char *_NTUPLE_CSELECT_CHOPT_text[] = {
 "Comment is left adjusted to the current zone",
 "Comment is right adjusted to the current zone",
 "Comment is centered to the current zone",
 "Comment is drawn below the top zone line",
 "All subsequent NTUPLE/PLOT commands will print the selection mechanism with\
 the options specified in CHOPT." };
static KmParOption _NTUPLE_CSELECT_CHOPT_type = { _NTUPLE_CSELECT_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _NTUPLE_CSELECT_CHOPT = { "CHOPT", 5, "Options", "N",
 (char*)0, 8, 5, _NTUPLE_CSELECT_CHOPT_range, 5, _NTUPLE_CSELECT_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_NTUPLE_CSELECT_CHOPT_type };
static KmParReal   _NTUPLE_CSELECT_CSIZE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _NTUPLE_CSELECT_CSIZE = { "CSIZE", 5, "Comment size",
 "0.28", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_NTUPLE_CSELECT_CSIZE_type };
static KmParameter *_NTUPLE_CSELECT_parameters[] = { &_NTUPLE_CSELECT_CHOPT,
 &_NTUPLE_CSELECT_CSIZE };
static char *_NTUPLE_CSELECT_guidance[] = {
 "To write selection mechanism as a comment on the picture.",
 "By default, the comment is drawn left justified above the top zone line.",
 "Example:", " CSEL          All coming NT/PLOT commands will draw a comment",
 "               of size CSIZE=0.28cm Left justified.",
 " CSEL NRB 0.4  All coming NT/PLOT commands will draw a comment",
 "               of size 0.4 cm Right justified Below the top line.",
 " CSEL  CB      Draw previous selection mechanism Centered Below",
 "               the top zone line.",
 "The Global title font (SET GFON) with precision 1 is used to draw the",
 "text." };
static KmCommand _NTUPLE_CSELECT = { &_NTUPLE_MASK, "/NTUPLE/CSELECT",
 "CSELECT", 0, 1, 2, 0, _NTUPLE_CSELECT_parameters, 0, 0, pnutil_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 11, _NTUPLE_CSELECT_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_CUTS_CUTID = { "CUTID", 5, "Cut identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static char *_NTUPLE_CUTS_OPTION_range[] = { "G", "X", "P", "-", "R", "W", "D"
 };
static char *_NTUPLE_CUTS_OPTION_text[] = {
 "Define a new cut CUTID using graphics input on the latest 1-Dim or 2-Dim\
 projection of the Ntuple. For a 1-Dim projection, give 2 points\
 cutmin,cutmax. For a 2-Dim projection, give up to 20 points to delimit the\
 selected area. The polygon will automatically be closed by PAW.",
 "Same as G but with a tracking cross cursor.",
 "Print definition of cut CUTID.", "Reset cut CUTID.",
 "Read definition of cut CUTID from file FNAME.",
 "Write definition of cut CUTID on file FNAME (text file).",
 "Draw cut contour." };
static KmParOption _NTUPLE_CUTS_OPTION_type = { _NTUPLE_CUTS_OPTION_text,
 (int*)0, (int*)0 };
static KmParameter _NTUPLE_CUTS_OPTION = { "OPTION", 6, "Options", "P",
 (char*)0, 8, 7, _NTUPLE_CUTS_OPTION_range, 7, _NTUPLE_CUTS_OPTION_range,
 (KmParFlag)2, KmTYPE_OPTION, &_NTUPLE_CUTS_OPTION_type };
static KmParameter _NTUPLE_CUTS_FNAME = { "FNAME", 5, "File name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _NTUPLE_CUTS_WKID_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_CUTS_WKID = { "WKID", 4, "Workstation identifier",
 "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_CUTS_WKID_type };
static KmParameter *_NTUPLE_CUTS_parameters[] = { &_NTUPLE_CUTS_CUTID,
 &_NTUPLE_CUTS_OPTION, &_NTUPLE_CUTS_FNAME, &_NTUPLE_CUTS_WKID };
static char *_NTUPLE_CUTS_guidance[] = {
 "Define the CUTID with the format $nn.",
 "nn is an integer between 1 and 99.",
 "This cut can then be used in subsequent commands NTUPLE/PLOT, PROJECT.",
 "  OPTION='expression'  allows to define the cut CUTID. For example",
 "  the command:", "   PAW > CUTS $1 X<0.8.and.Y<SQRT(X)",
 "  defines the cut $1.",
 "Note that CUTID=$0 means all cuts except for 'G' option.",
 "When option G is selected, graphical cuts are only operational",
 "for plots of the original Ntuple variables, not for expressions",
 "of these variables.",
 "WKID allows to define in which window the locator is performed",
 "(option 'G' or 'X' only)." };
static KmCommand _NTUPLE_CUTS = { &_NTUPLE_CSELECT, "/NTUPLE/CUTS", "CUTS", 0,
 1, 4, 1, _NTUPLE_CUTS_parameters, 0, 0, pacuts_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 13, _NTUPLE_CUTS_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_WAVE_IDN = { "IDN", 3, "Ntuple Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _NTUPLE_WAVE_LUN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_WAVE_LUN = { "LUN", 3, "Logical unit no.", "-1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_WAVE_LUN_type };
static KmParameter *_NTUPLE_WAVE_parameters[] = { &_NTUPLE_WAVE_IDN,
 &_NTUPLE_WAVE_LUN };
static char *_NTUPLE_WAVE_guidance[] = {
 "Produce a formatted file suitable for Wavefront's Data Visualiser.",
 "Only for simple 3-variable ntuples which have been SMOOTHed.",
 "A file with logical unit no. LUN must previously have been opened with",
 "the FORTRAN/FILE command." };
static KmCommand _NTUPLE_WAVE = { &_NTUPLE_CUTS, "/NTUPLE/WAVE", "WAVE", 0, 1,
 2, 1, _NTUPLE_WAVE_parameters, 0, 0, pawave_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 4, _NTUPLE_WAVE_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_DRAW_IDN = { "IDN", 3, "Ntuple Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_DRAW_VALUE = { "VALUE", 5,
 "Isosurface value (for 3-D)", "0", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParOption _NTUPLE_DRAW_OPTION_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _NTUPLE_DRAW_OPTION = { "OPTION", 6, "Options", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_NTUPLE_DRAW_OPTION_type };
static KmParameter *_NTUPLE_DRAW_parameters[] = { &_NTUPLE_DRAW_IDN,
 &_NTUPLE_DRAW_VALUE, &_NTUPLE_DRAW_OPTION };
static char *_NTUPLE_DRAW_guidance[] = {
 "Draw a simple ntuple (1, 2 or 3 variables).",
 "For simple ntuples, with 1, 2 or 3 variables per event, this command will",
 "draw a histogram with HPLOT options.  If the ntuple has an associated",
 "functional representation, as the result, e.g., of using SMOOTH, it will",
 "also draw the function.  No selections are allowed.", "",
 "For 3-variable ntuples which have been SMOOTHed, give a VALUE for the",
 "isosurface of event density.  If VALUE=0, an isosurface value half way",
 "between the minimum and maximum fitted smoothing function values will be",
 "used." };
static KmCommand _NTUPLE_DRAW = { &_NTUPLE_WAVE, "/NTUPLE/DRAW", "DRAW", 0, 1,
 3, 1, _NTUPLE_DRAW_parameters, 0, 0, pandra_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 10, _NTUPLE_DRAW_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_CHAIN_CNAME = { "CNAME", 5, "Chain Name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter _NTUPLE_CHAIN_ENTRY = { "ENTRY", 5,
 "Chain Member(s) | -P Path", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)8, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_NTUPLE_CHAIN_parameters[] = { &_NTUPLE_CHAIN_CNAME,
 &_NTUPLE_CHAIN_ENTRY };
static char *_NTUPLE_CHAIN_guidance[] = {
 "Using the chain command one can build logical Ntuples of unlimited size.",
 "The chain command creates an Ntuple chain CNAME and add member(s) ENTRY.",
 "If the chain already exists the member is simply added.",
 "More than one member may be specified at a time.",
 "A chain can contain three different type of members: files,",
 "logical units and other chains. The member type is deduced from the format",
 "of the member. Entries containing the characters . / : ; $ are considered",
 "to be files, entries like //LUN4 are assumed to be logical units",
 "and all other type of entries are chains. Chain names must be unique.",
 "After a chain has been defined it can be traversed, by all Ntuple",
 "commands (NT/PLOT, NT/PROJ, NT/LOOP), by changing the current working",
 "directory to the chain: CD //CNAME.",
 "A member may be deleted from a chain by",
 "preceding it by a - sign. A complete chain can be deleted by preceding",
 "the chain name by a -. All chains can be deleted by giving a - as chain",
 "name. Not specifying any parameters results in the listing of all defined",
 "chains. A chain tree will be printed by appending a > character to the",
 "chain name.",
 "The path of all chain members, from chain CNAME downwards, can be changed",
 "by specifying a chain path. This is done by giving a chain name followed",
 "by the -P option and a path specification. The chain path will be\
 pre-pended",
 "to the member names. Chains down the tree can override a path specified",
 "higher up in the tree.", " Examples of chain (Ntuple tree) definition:",
 " CHAIN   Year93  Jan Feb March April May ...",
 " CHAIN   Jan     Week1 Week2 Week3 Week4",
 " CHAIN   Week1   file1.hbook file2.hbook ...",
 " CHAIN   Week2   file3.hbook file4.hbook ...", " CD //Jan",
 " NT/PLOT 10.e     ; loop over all files in chains Week1, Week2, Week3, ...",
 " CD //Year93      ; loop over all files in chains Jan, Feb, March, ...",
 " CHAIN Year93 -P /user/delphi   ; all files from chain Year93 downward\
 will",
 "                                  be changed to /user/delphi/file1.hbook,\
 ...", " CHAIN Year93>    ; print the chain tree Year93",
 " CHAIN -Feb       ; delete chain Feb",
 " CHAIN Jan -file3.hbook   ; delete file3.hbook from chain Jan" };
static KmCommand _NTUPLE_CHAIN = { &_NTUPLE_DRAW, "/NTUPLE/CHAIN", "CHAIN", 0,
 1, 2, 0, _NTUPLE_CHAIN_parameters, 0, 0, pchain_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 36, _NTUPLE_CHAIN_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_PLOT_IDN = { "IDN", 3, "Ntuple Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_PLOT_UWFUNC = { "UWFUNC", 6, "Selection function",
 "1.", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _NTUPLE_PLOT_NEVENT_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_PLOT_NEVENT = { "NEVENT", 6, "Number of events",
 "99999999", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_NTUPLE_PLOT_NEVENT_type };
static KmParInt    _NTUPLE_PLOT_IFIRST_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_PLOT_IFIRST = { "IFIRST", 6, "First event", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_PLOT_IFIRST_type };
static KmParInt    _NTUPLE_PLOT_NUPD_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_PLOT_NUPD = { "NUPD", 4,
 "Frequency to update histogram", "100000000", (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_NTUPLE_PLOT_NUPD_type };
static char *_NTUPLE_PLOT_OPTION_range[] = { " ", "C", "S", "+", "B", "L",
 "P", "*", "U", "E", "A", "", "PROF", "PROFS", "PROFI" };
static char *_NTUPLE_PLOT_OPTION_text[] = { (char*)0, "Draw a smooth curve.",
 "Superimpose plot on top of existing picture.",
 "Add contents of IDN to last plotted ntuple.", "Bar chart format.",
 "Connect channels contents by a line.",
 "Draw the current polymarker at each channel or cell.",
 "Draw a * at each channel.", "Update channels modified since last call.",
 "Compute (HBARX) and draw error bars with current marker.",
 "Axis labels and tick marks are not drawn.",
 "Draw the ntuple as an histogram.",
 "Fill a Profile histogram (mean option).",
 "Fill a Profile histogram (spread option).",
 "Fill a Profile histogram (integer spread option)." };
static KmParOption _NTUPLE_PLOT_OPTION_type = { _NTUPLE_PLOT_OPTION_text,
 (int*)0, (int*)0 };
static KmParameter _NTUPLE_PLOT_OPTION = { "OPTION", 6, "Options", " ",
 (char*)0, 8, 15, _NTUPLE_PLOT_OPTION_range, 15, _NTUPLE_PLOT_OPTION_range,
 (KmParFlag)0, KmTYPE_OPTION, &_NTUPLE_PLOT_OPTION_type };
static KmParInt    _NTUPLE_PLOT_IDH_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_PLOT_IDH = { "IDH", 3,
 "Identifier of histogram to fill", "1000000", (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_NTUPLE_PLOT_IDH_type };
static KmParameter *_NTUPLE_PLOT_parameters[] = { &_NTUPLE_PLOT_IDN,
 &_NTUPLE_PLOT_UWFUNC, &_NTUPLE_PLOT_NEVENT, &_NTUPLE_PLOT_IFIRST,
 &_NTUPLE_PLOT_NUPD, &_NTUPLE_PLOT_OPTION, &_NTUPLE_PLOT_IDH };
static char *_NTUPLE_PLOT_guidance[] = {
 "Project and plot an Ntuple as a (1-Dim or 2-Dim) histogram",
 "with automatic binning (ID=1000000), possibly using a selection",
 "algorithm. See parameter CHOPT in command HISTO/PLOT to have",
 "more details on the possible OPTION.", " IDN may be given as IDN",
 "                     IDN.X", "                     IDN.Y%X",
 "                     IDN.1", "                     IDN.2%1",
 "                     IDN.expression1",
 "                     IDN.expression1%expression2",
 "Y%X means a scatter-plot Y(I) versus X(I) where I is the event number.",
 "2%1 means a scatter-plot variable 2 versus variable 1.",
 "In this example, X and Y are the names of the variables 1 and 2",
 "respectively.",
 "Expression 1 is any numerical expression of the Ntuple variables.",
 "It may include a call to a COMIS function.",
 " UWFUNC may have the following forms:",
 " 1- UWFUNC='0' or missing (only IDN given). No selection is applied.",
 " 2- UWFUNC is a CUT or combination of valid CUTS created by the",
 "    command NTUPLE/CUTS. Ex:",
 "           UWFUNC=$1            means use cut $1",
 "           UWFUNC=$1.AND.$2", "           UWFUNC=.NOT.($1.AND.$2)",
 "           UWFUNC=($1.OR.$2).AND.$3", " 3- UWFUNC is a FORTRAN expression",
 "    Ex:    X>3.14.AND.(Y<Z+3.15)",
 " 4- UWFUNC is a variable name or an arithmetic expression",
 "    Ex:   NT/PLOT 30.X Y  weight of each event is variable Y",
 "          NT/PLOT 30.X X**2+Y**2",
 " 5- UWFUNC is the name of a selection function in a text file with",
 "    the name UWFUNC.FTN, UWFUNC.FOR, UWFUNC FORTRAN (Apollo, VAX, IBM).",
 "The command UWFUNC may be used to generate automatically this function.",
 "For example if IDN=30 is an Ntuple with 3 variables per event and 10000",
 "events, then", "    NTUPLE/PLOT 30.X SELECT.FOR",
 "will process the 10000 events of the Ntuple IDN=30. For each event,",
 "the function SELECT is called. It returns the weight of the event.",
 "Example:", "    FUNCTION SELECT(X)", "    DIMENSION X(3)",
 "    IF(X(1)**1+X(2)**2.LT.1.5)THEN", "       SELECT=0.", "    ELSE",
 "       SELECT=1.", "    ENDIF", "    END",
 "The file SELECT.FOR (VAX), SELECT.FTN (Apollo) or SELECT FORTRAN (IBM)",
 "can be edited from PAW using the command EDIT. Note that if the suffix",
 "(.FTN, .FORTRAN or .FOR) is omitted, then COMIS will start from the",
 "precompiled version in memory and not from the file. Results of a",
 "selection can be saved in a MASK (See NTUPLE/MASK).",
 " Ex: NT/PLOT 30.X Z<0.4>>MNAME(4)",
 "     means mark bit 4 in mask MNAME for all events satisfying",
 "     the condition Z<0.4",
 "A MASK may also be given as input to a selection expression.",
 " Ex:  NT/PLOT 30.X MNAME(4).and.Z<0.4",
 "      means all events satisfying bit 4 of MNAME AND Z<0.4",
 "It is possible to plot expressions of the original variables.",
 " Ex 1:  NT/PLOT 30.SIN(X)%SQRT(Y**2+Z**2)  Z<0.4",
 "     plots a scatter-plot of variable U versus V for all events",
 "     satisfying the condition Z<0.4. U and V are defined as being",
 "     U=SIN(X) and V=SQRT(X**2+Y**2)",
 " Ex 2:  NT/PLOT 30.FUNC.FTN(X)%(SIN(Y)+3.)  Z<0.2.and.TEST.FTN>6",
 "     plots a scatter-plot of variable U versus V for all events",
 "     satisfying the condition (Z<0.2 and the result of the COMIS",
 "     function TEST.FTN >6). U and V are defined as being",
 "     U=Result of the COMIS function FUNC.FTN,  V=SIN(Y)+3.",
 "The default identifier of the histogram being filled is IDH=1000000.",
 "At the next invocation of this command, it will be overwritten.",
 "If either NEVENT or IFIRST or NUPD are negative, then the identifier",
 "of the histogram being filled will be taken as IDH=-NEVENT or",
 "IDH=-IFIRST or IDH=-NUPD. IDH may have been created with H/CREATE.",
 "Before filling IDH, the contents of IDH are reset if IDH already",
 "exists. Use NTUPLE/PROJECT to cumulate several passes into IDH.",
 "Note that IDH not equal to 1000000 is a convenient way to force user",
 "binning.",
 "Every NUPD events, the current status of the  histogram is displayed." };
static KmCommand _NTUPLE_PLOT = { &_NTUPLE_CHAIN, "/NTUPLE/PLOT", "PLOT", 0,
 1, 7, 1, _NTUPLE_PLOT_parameters, 0, 0, pantup_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 78, _NTUPLE_PLOT_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_READ_IDN = { "IDN", 3, "Ntuple Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_READ_FNAME = { "FNAME", 5, "File name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter _NTUPLE_READ_FORMAT = { "FORMAT", 6, "Format", "*",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter _NTUPLE_READ_OPT = { "OPT", 3, "Options", " ", (char*)0,
 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _NTUPLE_READ_NEVENT_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_READ_NEVENT = { "NEVENT", 6, "Number of events",
 "1000000", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_READ_NEVENT_type };
static KmParameter _NTUPLE_READ_MATCH = { "MATCH", 5, "Matching pattern", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_NTUPLE_READ_parameters[] = { &_NTUPLE_READ_IDN,
 &_NTUPLE_READ_FNAME, &_NTUPLE_READ_FORMAT, &_NTUPLE_READ_OPT,
 &_NTUPLE_READ_NEVENT, &_NTUPLE_READ_MATCH };
static char *_NTUPLE_READ_guidance[] = {
 "Read Ntuple values from the alphanumeric file FNAME with",
 "the format specifications in FORMAT.", "",
 "This command works for row wise Ntuple only.", "",
 "Before executing this command, the Ntuple IDN must have been",
 "created with the command Ntuple/Create.", "",
 "MATCH is used to specify a pattern string, restricting",
 "the Ntuple filling only to the records in the file which",
 "verify the pattern. The possible patterns are:", "",
 "  /string/      match a string (starting in column 1)",
 " -/string/      do not match a string (starting in column 1)",
 "  /string/(n)   match a string, starting in column n",
 "  /string/(*)   match a string, starting at any column", "", "Example:",
 "    H/del *", "    Appl Data ntmatch.dat", "     101. 201. 301.   C",
 "     102. 202. 302.", "     103. 203. 303.   C", "     104. 204. 304.   C",
 "     105. 205. 305.", "     106. 206. 306.", "     107. 207. 307.",
 "     108. 208. 308.", "     109. 209. 309.", "    ntmatch.dat",
 "    Nt/Create 4 'Test of Match' 3 ! ! Xmatch Ymatch Zmatch",
 "    Nt/Read 4 ntmatch.dat ! ! ! -/C/(*)", "    Nt/SCAN 4",
 "In this macro all the lines with a C at the end are not read." };
static KmCommand _NTUPLE_READ = { &_NTUPLE_PLOT, "/NTUPLE/READ", "READ", 0, 1,
 6, 2, _NTUPLE_READ_parameters, 0, 0, pnutil_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 34, _NTUPLE_READ_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_PROJECT_IDH = { "IDH", 3,
 "Identifier of histogram to fill", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_PROJECT_IDN = { "IDN", 3, "Identifier of Ntuple",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_PROJECT_UWFUNC = { "UWFUNC", 6,
 "Selection function or cut identifier", "1.", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _NTUPLE_PROJECT_NEVENT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _NTUPLE_PROJECT_NEVENT = { "NEVENT", 6, "Number of events",
 "99999999", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_NTUPLE_PROJECT_NEVENT_type };
static KmParInt    _NTUPLE_PROJECT_IFIRST_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _NTUPLE_PROJECT_IFIRST = { "IFIRST", 6, "First event", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_PROJECT_IFIRST_type };
static KmParameter *_NTUPLE_PROJECT_parameters[] = { &_NTUPLE_PROJECT_IDH,
 &_NTUPLE_PROJECT_IDN, &_NTUPLE_PROJECT_UWFUNC, &_NTUPLE_PROJECT_NEVENT,
 &_NTUPLE_PROJECT_IFIRST };
static char *_NTUPLE_PROJECT_guidance[] = {
 "Project an Ntuple onto a 1-Dim or 2-Dim histogram,",
 "possibly using a selection function or predefined cuts.",
 "IDN may be given as IDN or IDN.X , IDN.Y%X , IDN.1, IDN.2%1.",
 "Y%X means variable Y of Ntuple IDN versus variable X.",
 "For more information about UWFUNC, see command NTUPLE/PLOT.",
 "The histogram IDH is not reset before filling. This allows",
 "several PROJECTs from different Ntuples." };
static KmCommand _NTUPLE_PROJECT = { &_NTUPLE_READ, "/NTUPLE/PROJECT",
 "PROJECT", 0, 1, 5, 2, _NTUPLE_PROJECT_parameters, 0, 0, pantup_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 7, _NTUPLE_PROJECT_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_MERGE_IDN1 = { "IDN1", 4,
 "Identifier of first Ntuple", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_MERGE_IDN2 = { "IDN2", 4,
 "Identifier of second Ntuple", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_MERGE_UWFUNC = { "UWFUNC", 6,
 "Selection function or cut identifier", "1.", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _NTUPLE_MERGE_NEVENT_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_MERGE_NEVENT = { "NEVENT", 6, "Number of events",
 "99999999", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_NTUPLE_MERGE_NEVENT_type };
static KmParInt    _NTUPLE_MERGE_IFIRST_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_MERGE_IFIRST = { "IFIRST", 6, "First event", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_MERGE_IFIRST_type };
static KmParameter *_NTUPLE_MERGE_parameters[] = { &_NTUPLE_MERGE_IDN1,
 &_NTUPLE_MERGE_IDN2, &_NTUPLE_MERGE_UWFUNC, &_NTUPLE_MERGE_NEVENT,
 &_NTUPLE_MERGE_IFIRST };
static char *_NTUPLE_MERGE_guidance[] = {
 "Merge two Disk-Resident Row-Wise-Ntuples.",
 "Invoke the selection function UWFUNC for each of the NEVENT events",
 "starting at event IFIRST of Ntuple IDN1.",
 "Suppose you have 4 files containing Ntuple ID=10 and you want to merge",
 "the 4 files into the file 4, the sequence is:", " PAW >Histo/file 1 file1",
 " PAW >Histo/file 2 file2", " PAW >Histo/file 3 file3",
 " PAW >Histo/file 4 file4 1024 U", " PAW >Ntuple/Merge //lun1/10 //lun4/10",
 " PAW >Ntuple/Merge //lun2/10 //lun4/10",
 " PAW >Ntuple/Merge //lun3/10 //lun4/10", " PAW >Ntuple/plot 10.x .........",
 "Only the events with UWFUNC>0 are appended to IDN2. IDN2 may be empty.",
 "Note that the Ntuple variables may be redefined inside UWFUNC.",
 "For more information about UWFUNC, see command NTUPLE/PLOT.",
 "Note that this command cannot be used for memory resident ntuples or CWNs.",
 "Use instead the command HMERGE." };
static KmCommand _NTUPLE_MERGE = { &_NTUPLE_PROJECT, "/NTUPLE/MERGE", "MERGE",
 0, 1, 5, 2, _NTUPLE_MERGE_parameters, 0, 0, pamerg_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 18, _NTUPLE_MERGE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_LOOP_IDN = { "IDN", 3, "Identifier of Ntuple",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_LOOP_UWFUNC = { "UWFUNC", 6,
 "Selection function or cut identifier", "1.", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _NTUPLE_LOOP_NEVENT_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_LOOP_NEVENT = { "NEVENT", 6, "Number of events",
 "99999999", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_NTUPLE_LOOP_NEVENT_type };
static KmParInt    _NTUPLE_LOOP_IFIRST_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_LOOP_IFIRST = { "IFIRST", 6, "First event", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_LOOP_IFIRST_type };
static KmParameter *_NTUPLE_LOOP_parameters[] = { &_NTUPLE_LOOP_IDN,
 &_NTUPLE_LOOP_UWFUNC, &_NTUPLE_LOOP_NEVENT, &_NTUPLE_LOOP_IFIRST };
static char *_NTUPLE_LOOP_guidance[] = {
 "Invoke the selection function UWFUNC for each event starting",
 "at event IFIRST.",
 "In UWFUNC, the user can fill one or several histograms previously booked.",
 "The loop will be terminated if UWFUNC returns a negative value.",
 "For more information about UWFUNC, see command NTUPLE/PLOT." };
static KmCommand _NTUPLE_LOOP = { &_NTUPLE_MERGE, "/NTUPLE/LOOP", "LOOP", 0,
 1, 4, 2, _NTUPLE_LOOP_parameters, 0, 0, pantup_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 5, _NTUPLE_LOOP_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_SCAN_IDN = { "IDN", 3, "Ntuple Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_SCAN_UWFUNC = { "UWFUNC", 6, "User cut function",
 "1.", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _NTUPLE_SCAN_NEVENT_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_SCAN_NEVENT = { "NEVENT", 6, "Number of events",
 "99999999", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_NTUPLE_SCAN_NEVENT_type };
static KmParInt    _NTUPLE_SCAN_IFIRST_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_SCAN_IFIRST = { "IFIRST", 6, "First event", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_SCAN_IFIRST_type };
static char *_NTUPLE_SCAN_OPTION_range[] = { " ", "S", "", "S2", "A" };
static char *_NTUPLE_SCAN_OPTION_text[] = { (char*)0,
 "Graphical scan (spider plot).", "Alphanumeric output of the Ntuple.",
 "Graphical scan (segments plot).",
 "Used with 'S' it displays the average spider." };
static KmParOption _NTUPLE_SCAN_OPTION_type = { _NTUPLE_SCAN_OPTION_text,
 (int*)0, (int*)0 };
static KmParameter _NTUPLE_SCAN_OPTION = { "OPTION", 6, "Options", " ",
 (char*)0, 8, 5, _NTUPLE_SCAN_OPTION_range, 5, _NTUPLE_SCAN_OPTION_range,
 (KmParFlag)0, KmTYPE_OPTION, &_NTUPLE_SCAN_OPTION_type };
static KmParameter _NTUPLE_SCAN_VARLIS = { "VARLIS", 6,
 "Names of the NVARS variables to scan", " ", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)8, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_NTUPLE_SCAN_parameters[] = { &_NTUPLE_SCAN_IDN,
 &_NTUPLE_SCAN_UWFUNC, &_NTUPLE_SCAN_NEVENT, &_NTUPLE_SCAN_IFIRST,
 &_NTUPLE_SCAN_OPTION, &_NTUPLE_SCAN_VARLIS };
static char *_NTUPLE_SCAN_guidance[] = {
 "Scan the entries of an Ntuple subject to user cuts.",
 "Scan the variables for NEVENT events starting at IFIRST, requiring that",
 "the events satisfy cut UWFUNC. In the case of Alphanumeric output",
 "Up to 8 variables may be scanned, the default is to scan the first 8",
 "variables.", "",
 "When the option S (Spider plot) is specified, each event is presented",
 "in a graphical form (R versus PHI plot) to give a multi dimensional view\
 of",
 "the event. Each variable is represented on a separate axis with a scale",
 "ranging from the minimum to the maximum value of the variable. A line\
 joins",
 "all the current points on every axis where each point corresponds to",
 "the current value of the variable. When the HCOL parameter is specified",
 "(eg SET HCOL 1002) a fill area is drawn.", "",
 "VARLIS may contain a list of the original variables, expressions",
 "of the original variables or/and ranges of variables.",
 "A range can be given in the following form:",
 " :          means all variables (default).",
 " var1:var2  means from variable var1 to variable var2 included.",
 " var1:      means from variable var1 to the last.",
 " :var2      means from variable 1 to variable var2", "",
 "For example, if IDN=30 has the 3 variables X,Y,Z,U,V,W one can do:",
 " PAW > scan 30", " PAW > scan 30 option=s",
 "       each event is drawn as a spider plot.", " PAW > scan 30 option=sa",
 "       each event is drawn as a spider plot and the average spider",
 "       plot is also drawn.", " PAW > set 2BUF 1",
 " PAW > scan 30 option=s2", " More...? ( <CR>/N/G ) G",
 "       answering 'G' with double buffer on, create a graphical",
 "       animation of the ntuple content.", " PAW > scan 30 option=s  X:Z W",
 " PAW > scan 30 z>10", " PAW > scan 30 z>10 ! ! ! z abs(x) y+z x func.for",
 "       where func.for is a COMIS function returning an expression",
 "       of the original variables. This function func.for may be",
 "       generated automatically by the PAW command:",
 " PAW > uwfunc 30 func.for" };
static KmCommand _NTUPLE_SCAN = { &_NTUPLE_LOOP, "/NTUPLE/SCAN", "SCAN", 0, 1,
 6, 1, _NTUPLE_SCAN_parameters, 0, 0, pascan_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 41, _NTUPLE_SCAN_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _NTUPLE_RECOVER_IDN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_RECOVER_IDN = { "IDN", 3, "Ntuple Identifier",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_RECOVER_IDN_type };
static KmParameter *_NTUPLE_RECOVER_parameters[] = { &_NTUPLE_RECOVER_IDN };
static char *_NTUPLE_RECOVER_guidance[] = {
 "To recover Ntuple ID. If the job producing the Ntuple crashed",
 "or the header was not stored correctly in the file with HROUT,",
 "RECOVER will scan the Ntuple to rebuild the header table and",
 "recompute the number of entries. The file on which the Ntuple",
 "resides must be open in Update mode." };
static KmCommand _NTUPLE_RECOVER = { &_NTUPLE_SCAN, "/NTUPLE/RECOVER",
 "RECOVER", 0, 1, 1, 1, _NTUPLE_RECOVER_parameters, 0, 0, pnutil_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 5, _NTUPLE_RECOVER_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_DUPLICATE_ID1 = { "ID1", 3, "Source Ntuple",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _NTUPLE_DUPLICATE_ID2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _NTUPLE_DUPLICATE_ID2 = { "ID2", 3, "New Ntuple", (char*)0,
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_DUPLICATE_ID2_type };
static KmParInt    _NTUPLE_DUPLICATE_NEWBUF_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _NTUPLE_DUPLICATE_NEWBUF = { "NEWBUF", 6, "Buffer size",
 "-1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_DUPLICATE_NEWBUF_type };
static KmParameter _NTUPLE_DUPLICATE_TITLE = { "TITLE", 5, "Title of ID2",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_NTUPLE_DUPLICATE_OPTION_range[] = { " ", "A", "M", "" };
static char *_NTUPLE_DUPLICATE_OPTION_text[] = { (char*)0,
 "Set the Addresses of variables in common /PAWCR4,etc/.",
 "Create ID2 as a Memory resident Ntuple.",
 "Copy ID1 structure in ID2. Reset addresses of variables." };
static KmParOption _NTUPLE_DUPLICATE_OPTION_type = {
 _NTUPLE_DUPLICATE_OPTION_text, (int*)0, (int*)0 };
static KmParameter _NTUPLE_DUPLICATE_OPTION = { "OPTION", 6, "Options", "A",
 (char*)0, 8, 4, _NTUPLE_DUPLICATE_OPTION_range, 4,
 _NTUPLE_DUPLICATE_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_NTUPLE_DUPLICATE_OPTION_type };
static KmParameter *_NTUPLE_DUPLICATE_parameters[] = { &_NTUPLE_DUPLICATE_ID1,
 &_NTUPLE_DUPLICATE_ID2, &_NTUPLE_DUPLICATE_NEWBUF, &_NTUPLE_DUPLICATE_TITLE,
 &_NTUPLE_DUPLICATE_OPTION };
static char *_NTUPLE_DUPLICATE_guidance[] = {
 "The structure of Ntuple ID1 is duplicated in a new ntuple ID2.",
 "This command is useful when one wants to create an ntuple with the same",
 "variables but only a subset of the events. NEWBUF is the buffer size",
 "for ID2. If NEWBUF<0 the buffer size of ID1 is taken. If NEWBUF=0 the\
 current",
 "buffer size is taken (10000 words for RWNs). NEWBUF>0 will be the new",
 "buffer size. If TITLE=' ' ID2 has the same title as ID1.",
 "In case of a disk-resident ntuple (default), ID2 is created into the",
 "current working directory which must be open in WRITE mode.", "",
 "Example with a Row Wise Ntuple:", "    Macro DUPRWN", "    Close 0",
 "    Hi/File 1 source.hbook", "    Hi/File 2 new.hbook ! N",
 "    Nt/Dup //lun1/30 2", "    *", "    Application Comis Quit",
 "          Real Function Dup(dum)", "          Include ?",
 "          If (X.gt.0..Or.Y.gt.0.) call hfn(2,X)", "          dup=1.",
 "          end", "    Quit", "    *", "    nt/loop //lun1/30 dup",
 "    hrout 2",
 "Note that the statement 'include ?' allows to create automatically the\
 inlude",
 "file (comis.inc) corresponding to the ntuple structure. The command UWFUNC",
 "is not required in this case.", "", "Example with a Column Wise Ntuple:",
 "    Macro DUPCWN", "    *",
 "     Close 0                    | Close all the currently opened file",
 "     H/file 1 source.hbook",
 "     Uwfunc //lun1/1 source.inc | generate source.inc",
 "     H/file 2 new.hbook ! N     | Create a new hbook file",
 "     Nt/Dup //lun1/1 2          | Duplicate the ntuple 1 in the ntuple 2",
 "    *",
 "    * Comis routine which Loop on all events of Id1 and select some events",
 "    * to be written in the new ntuple Id2.", "    *",
 "    Application COMIS quit", "          Subroutine ntdup(Id1,Id2)",
 "          Include 'source.inc'", "          Call Hnoent(Id1,Noent)",
 "          Do Ievent=1,Noent", "             Call Hgnt(Id1,Ievent,Ierr)",
 "             If (Ierr.ne.0) Goto 20",
 "             If (X.Gt.0..Or.Y.Gt.0.) Then",
 "                Call Hfnt(Id2)", "             Endif", "          Enddo",
 "      20  Continue", "    *", "          End", "    Quit", "    *",
 "     Call Ntdup(1,2)             | Execute the routine Ntdup",
 "     Hrout 2                     | Write Id2 on disk" };
static KmCommand _NTUPLE_DUPLICATE = { &_NTUPLE_RECOVER, "/NTUPLE/DUPLICATE",
 "DUPLICATE", 0, 1, 5, 2, _NTUPLE_DUPLICATE_parameters, 0, 0, pnutil_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 60, _NTUPLE_DUPLICATE_guidance,
 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_HMERGE_OUTFILE = { "OUTFILE", 7,
 "Output file name", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_HMERGE_INFILES = { "INFILES", 7,
 "Input file names", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)8, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_NTUPLE_HMERGE_parameters[] = { &_NTUPLE_HMERGE_OUTFILE,
 &_NTUPLE_HMERGE_INFILES };
static char *_NTUPLE_HMERGE_guidance[] = {
 "Merge HBOOK files containing histograms and/or ntuples. Ntuples are merged",
 "and histograms with the same ID are added. The INFILES are merged into a\
 new", "file OUTFILE. If OUTFILE already exists, it is overwritten.", "",
 "Note that if there is a histogram in PAW memory that has the",
 "same identifier as a histogram in one of the files to be merged,",
 "then the contents of the histogram in memory are added to those of",
 "the histogram in the file. This can be avoided by deleting the",
 "memory histogram (using H/DEL) before issuing the HMERGE command." };
static KmCommand _NTUPLE_HMERGE = { &_NTUPLE_DUPLICATE, "/NTUPLE/HMERGE",
 "HMERGE", 0, 1, 2, 2, _NTUPLE_HMERGE_parameters, 0, 0, mergin_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 9, _NTUPLE_HMERGE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_PRINT_IDN = { "IDN", 3, "Ntuple Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_NTUPLE_PRINT_parameters[] = { &_NTUPLE_PRINT_IDN };
static char *_NTUPLE_PRINT_guidance[] = { "Print a summary about Ntuple IDN.",
 "Number of entries, variables names and limits are listed." };
static KmCommand _NTUPLE_PRINT = { &_NTUPLE_HMERGE, "/NTUPLE/PRINT", "PRINT",
 0, 1, 1, 1, _NTUPLE_PRINT_parameters, 0, 0, pnutil_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _NTUPLE_PRINT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_NTUPLE_LIST_guidance[] = {
 "List all Ntuples in the Current Directory.",
 "Note that the command HISTO/LIST lists all histograms and Ntuples",
 "in the Current Directory." };
static KmCommand _NTUPLE_LIST = { &_NTUPLE_PRINT, "/NTUPLE/LIST", "LIST", 0,
 1, 0, 0, (KmParameter**)0, 0, 0, pnutil_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 3, _NTUPLE_LIST_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_CREATE_IDN = { "IDN", 3, "Ntuple Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_CREATE_TITLE = { "TITLE", 5, "Ntuple title", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _NTUPLE_CREATE_NVAR_type = { "1", "512", "1", "512", 0 };
static KmParameter _NTUPLE_CREATE_NVAR = { "NVAR", 4, "Number of variables",
 "1", (char*)0, 4, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_CREATE_NVAR_type };
static KmParameter _NTUPLE_CREATE_CHRZPA = { "CHRZPA", 6, "RZ path", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _NTUPLE_CREATE_NPRIME_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _NTUPLE_CREATE_NPRIME = { "NPRIME", 6,
 "Primary allocation", "1000", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_NTUPLE_CREATE_NPRIME_type };
static KmParameter _NTUPLE_CREATE_VARLIST = { "VARLIST", 7,
 "Names of the NVAR variables", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)8, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_NTUPLE_CREATE_parameters[] = { &_NTUPLE_CREATE_IDN,
 &_NTUPLE_CREATE_TITLE, &_NTUPLE_CREATE_NVAR, &_NTUPLE_CREATE_CHRZPA,
 &_NTUPLE_CREATE_NPRIME, &_NTUPLE_CREATE_VARLIST };
static char *_NTUPLE_CREATE_guidance[] = {
 "Create a Row_Wise_Ntuple. (See below how to create a Column_Wise_Ntuple).",
 "The Ntuple may be created either purely in memory or possibly",
 "using an automatic overflow to an RZ file.",
 "Memory allocation works in the following way.",
 "If CHRZPA = '  ', then a bank of NPRIME",
 "words is created. When the space in this bank is exhausted at filling\
 time,",
 "a new linear structure of length NPRIME is created and this process will\
 be", "repeated should the structure become exhausted.",
 "If CHRZPA contains the top directory name of an already existing RZ file\
 (as",
 "declared with HISTO/FILE), then a bank of length NPRIME is also created,",
 "but at filling time, this bank is moved to the RZ file when full, and",
 "then it is overwritten by any new entries.",
 "The Ntuple can be filled by calling HFN from an interactively",
 "defined subroutine called by the command NTUPLE/LOOP or by NTUPLE/READ.",
 "The number of variables per data point is given in the parameter NVAR.", "",
 "To create a Column_Wise_Ntuple, create a file, eg. newnt.f  with:",
 "      Subroutine Newnt", "      character*8 mother,in1,in2",
 "      common/ntupc/mother,in1,in2", "      common/ntupr/xover",
 "      lin=41", "      lout=42", "      id=1",
 "      open(unit=lin,file='datafile.dat',status='old')",
 "      call hropen(lout,'NTUPLE','New_Ntuple.hbook','N',1024,istat)",
 "      call hbnt(id,'New Ntuple',' ')",
 "      call hbname(id,'ntupr',xover,'XOVER')",
 "      call hbnamc(id,'ntupc',mother,'MOTHER:c*8,in1:c*8,in2:c*8')",
 "  10  read(lin,1000,end=20,err=20)xover,mother,in1,in2",
 "1000  format(e15.7,2x,a,7x,a,7x,a)", "      call hfnt(1)", "      go to 10",
 "  20  call hrout(id,icycle,' ')", "      call hrend('NTUPLE')",
 "      close (lin)", "      close (lout)", "      end",
 "and then call this routine via the CALL command:", "   PAW > call newnt.f" };
static KmCommand _NTUPLE_CREATE = { &_NTUPLE_LIST, "/NTUPLE/CREATE", "CREATE",
 0, 1, 6, 6, _NTUPLE_CREATE_parameters, 0, 0, pnutil_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 40, _NTUPLE_CREATE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_NTUPLE_guidance[] = { "Ntuple creation and related operations."
 };
static KmMenu _NTUPLE = {  (KmMenu*)0,  (KmMenu*)0, "/NTUPLE", "NTUPLE", 1,
 &_NTUPLE_CREATE, 1, _NTUPLE_guidance, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_NTUPLE, 950303 );
}


#ifdef F77_LCASE
#  define gradef_ gradef
#  define pagraf_ pagraf
#  define pagpri_ pagpri
#  define pafeyn_ pafeyn
#  define pagksa_ pagksa
#  define paghpl_ paghpl
#  define pawork_ pawork
#  define pahelp_ pahelp
#endif

#ifdef F77_UCASE
#  define gradef_ GRADEF
#  define pagraf_ PAGRAF
#  define pagpri_ PAGPRI
#  define pafeyn_ PAFEYN
#  define pagksa_ PAGKSA
#  define paghpl_ PAGHPL
#  define pawork_ PAWORK
#  define pahelp_ PAHELP
#endif

#ifdef IBM370
#  pragma linkage(GRADEF,FORTRAN)
#  pragma linkage(PAGRAF,FORTRAN)
#  pragma linkage(PAGPRI,FORTRAN)
#  pragma linkage(PAFEYN,FORTRAN)
#  pragma linkage(PAGKSA,FORTRAN)
#  pragma linkage(PAGHPL,FORTRAN)
#  pragma linkage(PAWORK,FORTRAN)
#  pragma linkage(PAHELP,FORTRAN)
#endif

extern void gradef_();
extern void pagraf_();
extern void pagpri_();
extern void pafeyn_();
extern void pagksa_();
extern void paghpl_();
extern void pawork_();
extern void pahelp_();

void gradef_()
{

static char *_GRAPHICS_MISC_HMOVE_guidance[] = {
 "Change the contents of a histogram channel using the cursor.",
 "Position the cursor to the channel to be changed, trigger graphics",
 "input, position the cursor to the new channel value",
 "(a rubber band box is used to visualize the change), trigger graphics",
 "input to fix the new value." };
static KmCommand _GRAPHICS_MISC_HMOVE = {  (KmCommand*)0,
 "/GRAPHICS/MISC/HMOVE", "HMOVE", 0, 2, 0, 0, (KmParameter**)0, 0, 0, pagraf_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 5, _GRAPHICS_MISC_HMOVE_guidance,
 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GRAPHICS_MISC_VLOCATE_VECX = { "VECX", 4,
 "Vector for coordinates X", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GRAPHICS_MISC_VLOCATE_VECY = { "VECY", 4,
 "Vector for coordinates Y", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_GRAPHICS_MISC_VLOCATE_CHOPT_range[] = { "", "+", "-", "L", "P",
 "*", "S" };
static char *_GRAPHICS_MISC_VLOCATE_CHOPT_text[] = { "Use the cross-hair",
 "Use the tracking cross", "Use the rubber line",
 "Connect points by a polyline", "Draw the current polymarker at each point",
 "Draw a * at each point",
 "Sample mode is used. Allows to see the coordinates of point before clicking"
 };
static KmParOption _GRAPHICS_MISC_VLOCATE_CHOPT_type = {
 _GRAPHICS_MISC_VLOCATE_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GRAPHICS_MISC_VLOCATE_CHOPT = { "CHOPT", 5, "Options",
 " ", (char*)0, 8, 7, _GRAPHICS_MISC_VLOCATE_CHOPT_range, 7,
 _GRAPHICS_MISC_VLOCATE_CHOPT_range, (KmParFlag)2, KmTYPE_OPTION,
 &_GRAPHICS_MISC_VLOCATE_CHOPT_type };
static KmParInt    _GRAPHICS_MISC_VLOCATE_NTPRI_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_MISC_VLOCATE_NTPRI = { "NTPRI", 5,
 "Transformation with highest priority", "-1", (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GRAPHICS_MISC_VLOCATE_NTPRI_type };
static KmParInt    _GRAPHICS_MISC_VLOCATE_WKID_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_MISC_VLOCATE_WKID = { "WKID", 4,
 "Workstation identifier", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GRAPHICS_MISC_VLOCATE_WKID_type };
static KmParameter *_GRAPHICS_MISC_VLOCATE_parameters[] = {
 &_GRAPHICS_MISC_VLOCATE_VECX, &_GRAPHICS_MISC_VLOCATE_VECY,
 &_GRAPHICS_MISC_VLOCATE_CHOPT, &_GRAPHICS_MISC_VLOCATE_NTPRI,
 &_GRAPHICS_MISC_VLOCATE_WKID };
static char *_GRAPHICS_MISC_VLOCATE_guidance[] = {
 "Locate a set of points using the graphics cursor.",
 "Return corresponding coordinates in vectors X and Y.",
 "If vectors X or Y do not exist, they are automatically created.",
 "Control is returned when the point is outside picture limits",
 "or when the BREAK (right) mouse button is clicked (or CRTL/E).",
 "The optional parameter NTPRI may be specified to locate",
 "a point in the specific transformation number NTPRI (see LOCATE).",
 "WKID allows to define in which window the locator is performed." };
static KmCommand _GRAPHICS_MISC_VLOCATE = { &_GRAPHICS_MISC_HMOVE,
 "/GRAPHICS/MISC/VLOCATE", "VLOCATE", 0, 2, 5, 2,
 _GRAPHICS_MISC_VLOCATE_parameters, 0, 0, pagraf_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 8, _GRAPHICS_MISC_VLOCATE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GRAPHICS_MISC_LOCATE_NTPRI = { "NTPRI", 5,
 "Transformation with highest priority", "-1", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_GRAPHICS_MISC_LOCATE_CHOPT_range[] = { "R", "S", "I", "+", "T" };
static char *_GRAPHICS_MISC_LOCATE_CHOPT_text[] = {
 "Request mode is used to locate the points (default)",
 "Sample mode is used to locate the points",
 "Integrate an histogram between 2 bins",
 "Use the tracking cross (default is cross-hair)",
 "The output is done on the terminal." };
static KmParOption _GRAPHICS_MISC_LOCATE_CHOPT_type = {
 _GRAPHICS_MISC_LOCATE_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GRAPHICS_MISC_LOCATE_CHOPT = { "CHOPT", 5, "Options", "R",
 (char*)0, 8, 5, _GRAPHICS_MISC_LOCATE_CHOPT_range, 5,
 _GRAPHICS_MISC_LOCATE_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GRAPHICS_MISC_LOCATE_CHOPT_type };
static KmParInt    _GRAPHICS_MISC_LOCATE_WKID_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_MISC_LOCATE_WKID = { "WKID", 4,
 "Workstation identifier", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GRAPHICS_MISC_LOCATE_WKID_type };
static KmParameter *_GRAPHICS_MISC_LOCATE_parameters[] = {
 &_GRAPHICS_MISC_LOCATE_NTPRI, &_GRAPHICS_MISC_LOCATE_CHOPT,
 &_GRAPHICS_MISC_LOCATE_WKID };
static char *_GRAPHICS_MISC_LOCATE_guidance[] = {
 "Locate points on the screen using the graphics cursor",
 "and output coordinates on terminal.",
 "Control is returned when the BREAK (right) mouse button is",
 "clicked (or CRTL/E) or when 20 points are located.",
 "The optional parameter NTPRI may be specified to locate",
 "a point in the specific transformation number NTPRI.",
 "NTPRI=-1 (default) means that all the histogram transformation",
 "numbers (10, 20, etc.) have priority on transformation number 1.",
 "WKID allows to define in which window the locator is performed.",
 " Note: With the Motif version of PAW the locator is automatically",
 "invoke when the mouse cursor enter the window." };
static KmCommand _GRAPHICS_MISC_LOCATE = { &_GRAPHICS_MISC_VLOCATE,
 "/GRAPHICS/MISC/LOCATE", "LOCATE", 0, 2, 3, 0,
 _GRAPHICS_MISC_LOCATE_parameters, 0, 0, pagraf_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 11, _GRAPHICS_MISC_LOCATE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_GRAPHICS_MISC_CLR_guidance[] = { "Clear the screen." };
static KmCommand _GRAPHICS_MISC_CLR = { &_GRAPHICS_MISC_LOCATE,
 "/GRAPHICS/MISC/CLR", "CLR", 0, 2, 0, 0, (KmParameter**)0, 0, 0, pagraf_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1, _GRAPHICS_MISC_CLR_guidance,
 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_GRAPHICS_MISC_NEXT_guidance[] = { "Clear the screen.",
 "Initialize a new HIGZ picture if option ZFL or ZFL1 has been selected.",
 "Select the Normalisation Transformation number 1 (cm)." };
static KmCommand _GRAPHICS_MISC_NEXT = { &_GRAPHICS_MISC_CLR,
 "/GRAPHICS/MISC/NEXT", "NEXT", 0, 2, 0, 0, (KmParameter**)0, 0, 0, pagraf_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3, _GRAPHICS_MISC_NEXT_guidance,
 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GRAPHICS_VIEWING_SELNT_NT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_VIEWING_SELNT_NT = { "NT", 2,
 "Normalisation transformation number", (char*)0, (char*)0, 8, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_INT, &_GRAPHICS_VIEWING_SELNT_NT_type };
static KmParameter *_GRAPHICS_VIEWING_SELNT_parameters[] = {
 &_GRAPHICS_VIEWING_SELNT_NT };
static char *_GRAPHICS_VIEWING_SELNT_guidance[] = {
 "Select a normalisation transformation number.",
 "  If ZONE 2 2 is active , then:        If ZONE 1 1 is active, then:",
 " +------------------------------+    +-----------------------------+",
 " |                              |    |                             |",
 " |  +----------+   +---------+  |    |  +-----------------------+  |",
 " |  |          |   |         |  |    |  |                       |  |",
 " |  |   NT=10  |   |  NT=20  |  |    |  |                       |  |",
 " |  |          |   |         |  |    |  |                       |  |",
 " |  +----------+   +---------+  |    |  |                       |  |",
 " |                              |    |  |         NT=10         |  |",
 " |  +----------+   +---------+  |    |  |                       |  |",
 " |  |          |   |         |  |    |  |                       |  |",
 " |  |   NT=30  |   |  NT=40  |  |    |  |                       |  |",
 " |  |          |   |         |  |    |  |                       |  |",
 " |  +----------+   +---------+  |    |  |                       |  |",
 " |                              |    |  +-----------------------+  |",
 " |             NT=1             |    |             NT=1            |",
 " +------------------------------+    +-----------------------------+", "",
 "Example:", "    Zone 1 2          | Define 2 zones.",
 "    Nul 0 1 -1 1      | Draw an empty frame in the first zone",
 "    Nul 0 1 -1 1      | Draw an empty frame in the second zone",
 "    Line 0 0 1 1      | Draw a line in second zone",
 "    Selnt 10          | select the first zone",
 "    Line 0 0 1 1      | Draw a line in the first zone" };
static KmCommand _GRAPHICS_VIEWING_SELNT = {  (KmCommand*)0,
 "/GRAPHICS/VIEWING/SELNT", "SELNT", 0, 2, 1, 1,
 _GRAPHICS_VIEWING_SELNT_parameters, 0, 0, pagraf_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 26, _GRAPHICS_VIEWING_SELNT_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GRAPHICS_VIEWING_SWN_NT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_VIEWING_SWN_NT = { "NT", 2,
 "Normalize transformation number", (char*)0, (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GRAPHICS_VIEWING_SWN_NT_type };
static KmParReal   _GRAPHICS_VIEWING_SWN_X1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_VIEWING_SWN_X1 = { "X1", 2,
 "Low X  of window in WC", "0", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_VIEWING_SWN_X1_type };
static KmParReal   _GRAPHICS_VIEWING_SWN_X2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_VIEWING_SWN_X2 = { "X2", 2,
 "High X of window in WC", "20", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_VIEWING_SWN_X2_type };
static KmParReal   _GRAPHICS_VIEWING_SWN_Y1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_VIEWING_SWN_Y1 = { "Y1", 2,
 "Low Y  of window in WC", "0", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_VIEWING_SWN_Y1_type };
static KmParReal   _GRAPHICS_VIEWING_SWN_Y2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_VIEWING_SWN_Y2 = { "Y2", 2,
 "High Y of window in WC", "20", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_VIEWING_SWN_Y2_type };
static KmParameter *_GRAPHICS_VIEWING_SWN_parameters[] = {
 &_GRAPHICS_VIEWING_SWN_NT, &_GRAPHICS_VIEWING_SWN_X1,
 &_GRAPHICS_VIEWING_SWN_X2, &_GRAPHICS_VIEWING_SWN_Y1,
 &_GRAPHICS_VIEWING_SWN_Y2 };
static char *_GRAPHICS_VIEWING_SWN_guidance[] = {
 "Set the window of the normalisation transformation NT",
 "in World Coordinates (WC). Note that the command SELNT should",
 "be invoke in order to validate the window parameters.", "", "Example:",
 "    Nul 0 1 -1 1      | Draw an empty frame (0,1)x(-1,1)",
 "    Line 0 0 1 1      | Draw a line in (0,1)x(-1,1)",
 "    Swn 10 0 10 0 10  | Change the coordinates to (0,10)x(0,10)",
 "    Selnt 10          | Activate the coordinates (0,10)x(0,10)",
 "    Line 0 0 1 1      | Draw a line in (0,10)x(0,10)", "",
 "This command, and also SVP, should not be used for",
 "a common PAW usage (H/PLOT, GRAPH etc ...). Commands like",
 "ZONE and SIZE should be used." };
static KmCommand _GRAPHICS_VIEWING_SWN = { &_GRAPHICS_VIEWING_SELNT,
 "/GRAPHICS/VIEWING/SWN", "SWN", 0, 2, 5, 5, _GRAPHICS_VIEWING_SWN_parameters,
 0, 0, pagraf_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 14,
 _GRAPHICS_VIEWING_SWN_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _GRAPHICS_VIEWING_SVP_NT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_VIEWING_SVP_NT = { "NT", 2,
 "Normalisation transformation number", (char*)0, (char*)0, 8, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_INT, &_GRAPHICS_VIEWING_SVP_NT_type };
static KmParReal   _GRAPHICS_VIEWING_SVP_X1_type = { "0", "1", "0", "1", 0 };
static KmParameter _GRAPHICS_VIEWING_SVP_X1 = { "X1", 2,
 "Low X  of viewport in NDC", "0", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_VIEWING_SVP_X1_type };
static KmParReal   _GRAPHICS_VIEWING_SVP_X2_type = { "0", "1", "0", "1", 0 };
static KmParameter _GRAPHICS_VIEWING_SVP_X2 = { "X2", 2,
 "High X of viewport in NDC", "1", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_VIEWING_SVP_X2_type };
static KmParReal   _GRAPHICS_VIEWING_SVP_Y1_type = { "0", "1", "0", "1", 0 };
static KmParameter _GRAPHICS_VIEWING_SVP_Y1 = { "Y1", 2,
 "Low Y  of viewport in NDC", "0", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_VIEWING_SVP_Y1_type };
static KmParReal   _GRAPHICS_VIEWING_SVP_Y2_type = { "0", "1", "0", "1", 0 };
static KmParameter _GRAPHICS_VIEWING_SVP_Y2 = { "Y2", 2,
 "High Y of viewport in NDC", "1", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_VIEWING_SVP_Y2_type };
static KmParameter *_GRAPHICS_VIEWING_SVP_parameters[] = {
 &_GRAPHICS_VIEWING_SVP_NT, &_GRAPHICS_VIEWING_SVP_X1,
 &_GRAPHICS_VIEWING_SVP_X2, &_GRAPHICS_VIEWING_SVP_Y1,
 &_GRAPHICS_VIEWING_SVP_Y2 };
static char *_GRAPHICS_VIEWING_SVP_guidance[] = {
 "Set the viewport of the normalisation transformation NT",
 "in the Normalized Device Coordinates (NDC). Note that the command",
 "SELNT should be invoke in order to validate the viewport parameters.", "",
 "This command, and also SWN, should not be used for",
 "a common PAW usage (H/PLOT, GRAPH etc ...). Commands like",
 "ZONE and SIZE should be used." };
static KmCommand _GRAPHICS_VIEWING_SVP = { &_GRAPHICS_VIEWING_SWN,
 "/GRAPHICS/VIEWING/SVP", "SVP", 0, 2, 5, 5, _GRAPHICS_VIEWING_SVP_parameters,
 0, 0, pagraf_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 7,
 _GRAPHICS_VIEWING_SVP_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParReal   _GRAPHICS_VIEWING_SIZE_XSIZE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_VIEWING_SIZE_XSIZE = { "XSIZE", 5,
 "Size along X", "20.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_VIEWING_SIZE_XSIZE_type };
static KmParReal   _GRAPHICS_VIEWING_SIZE_YSIZE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_VIEWING_SIZE_YSIZE = { "YSIZE", 5,
 "Size along Y", "20.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_VIEWING_SIZE_YSIZE_type };
static KmParameter *_GRAPHICS_VIEWING_SIZE_parameters[] = {
 &_GRAPHICS_VIEWING_SIZE_XSIZE, &_GRAPHICS_VIEWING_SIZE_YSIZE };
static char *_GRAPHICS_VIEWING_SIZE_guidance[] = {
 "Set the size of the picture.",
 "On the terminal, the pictures will have the ratio YSIZE/XSIZE, and,",
 "if a metafile is produced, pictures will be YSIZE by XSIZE cm.",
 "This command sets the parameters for the normalisation transformation",
 "number 1 to [0-XSIZE], [0-YSIZE]." };
static KmCommand _GRAPHICS_VIEWING_SIZE = { &_GRAPHICS_VIEWING_SVP,
 "/GRAPHICS/VIEWING/SIZE", "SIZE", 0, 2, 2, 0,
 _GRAPHICS_VIEWING_SIZE_parameters, 0, 0, pagraf_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _GRAPHICS_VIEWING_SIZE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GRAPHICS_VIEWING_ZONE_NX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_VIEWING_ZONE_NX = { "NX", 2,
 "Number of divisions along X", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GRAPHICS_VIEWING_ZONE_NX_type };
static KmParInt    _GRAPHICS_VIEWING_ZONE_NY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_VIEWING_ZONE_NY = { "NY", 2,
 "Number of divisions along Y", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GRAPHICS_VIEWING_ZONE_NY_type };
static KmParInt    _GRAPHICS_VIEWING_ZONE_IFIRST_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_VIEWING_ZONE_IFIRST = { "IFIRST", 6,
 "First division number", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GRAPHICS_VIEWING_ZONE_IFIRST_type };
static char *_GRAPHICS_VIEWING_ZONE_CHOPT_range[] = { " ", "S", "" };
static char *_GRAPHICS_VIEWING_ZONE_CHOPT_text[] = { (char*)0,
 "Redefine zones on current picture",
 "Define the zones for all subsequent pictures." };
static KmParOption _GRAPHICS_VIEWING_ZONE_CHOPT_type = {
 _GRAPHICS_VIEWING_ZONE_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GRAPHICS_VIEWING_ZONE_CHOPT = { "CHOPT", 5, "Option", " ",
 (char*)0, 8, 3, _GRAPHICS_VIEWING_ZONE_CHOPT_range, 3,
 _GRAPHICS_VIEWING_ZONE_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GRAPHICS_VIEWING_ZONE_CHOPT_type };
static KmParameter *_GRAPHICS_VIEWING_ZONE_parameters[] = {
 &_GRAPHICS_VIEWING_ZONE_NX, &_GRAPHICS_VIEWING_ZONE_NY,
 &_GRAPHICS_VIEWING_ZONE_IFIRST, &_GRAPHICS_VIEWING_ZONE_CHOPT };
static char *_GRAPHICS_VIEWING_ZONE_guidance[] = {
 "Subdivide the picture into NX by NY zones,",
 "starting at zone IFIRST (count along X first).", "",
 "Note that the command ZONE doesn't define the normalisation",
 "transformations (see SWN, SVP and SELNT). They are define",
 "only when commands like H/PLOT, NULL etc .. are performed." };
static KmCommand _GRAPHICS_VIEWING_ZONE = { &_GRAPHICS_VIEWING_SIZE,
 "/GRAPHICS/VIEWING/ZONE", "ZONE", 0, 2, 4, 0,
 _GRAPHICS_VIEWING_ZONE_parameters, 0, 0, pagraf_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 6, _GRAPHICS_VIEWING_ZONE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GRAPHICS_PRIMITIVES_GRAPH_N_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_GRAPH_N = { "N", 1,
 "Number of values", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GRAPHICS_PRIMITIVES_GRAPH_N_type };
static KmParameter _GRAPHICS_PRIMITIVES_GRAPH_X = { "X", 1,
 "Vector name for X coordinates", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GRAPHICS_PRIMITIVES_GRAPH_Y = { "Y", 1,
 "Vector name for Y coordinates", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_GRAPHICS_PRIMITIVES_GRAPH_CHOPT_range[] = { "A", "L", "W", "C",
 "F", "R", "B", "*", "P" };
static char *_GRAPHICS_PRIMITIVES_GRAPH_CHOPT_text[] = {
 "X and Y axes are drawn (default).",
 "Every point is connected with a straight line. (default)",
 "The Window/Viewport parameters are automatically computed from the X and Y\
 values (default).",
 "The values in Y are plotted in the form of a smooth curve. A Spline\
 approximation algorithm is used.",
 "A fill area is drawn. If the option 'CF' is used the contour of the fill\
 area is smooth. The border of the fill area is drawn if the command SET BORD\
 1 has been typed. The fill area type may be changed via the SET parameters\
 FASI and FASI",
 "The graph is Rotated, i.e. the values in X are used for the ordinate and the\
 values in Y for the abscissa (default is the contrary).",
 "A Bar chart with equidistant bins is drawn as fill areas. (Contours are\
 drawn). The bar origin and the bar width can be controlled by the routine SET\
 using the options BARO and BARW respectively.",
 "A star is plotted at every point.",
 "A marker is plotted at every point, according to current marker type and\
 polymarker colour index." };
static KmParOption _GRAPHICS_PRIMITIVES_GRAPH_CHOPT_type = {
 _GRAPHICS_PRIMITIVES_GRAPH_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GRAPHICS_PRIMITIVES_GRAPH_CHOPT = { "CHOPT", 5, "Options",
 "ALW", (char*)0, 8, 9, _GRAPHICS_PRIMITIVES_GRAPH_CHOPT_range, 9,
 _GRAPHICS_PRIMITIVES_GRAPH_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GRAPHICS_PRIMITIVES_GRAPH_CHOPT_type };
static KmParameter *_GRAPHICS_PRIMITIVES_GRAPH_parameters[] = {
 &_GRAPHICS_PRIMITIVES_GRAPH_N, &_GRAPHICS_PRIMITIVES_GRAPH_X,
 &_GRAPHICS_PRIMITIVES_GRAPH_Y, &_GRAPHICS_PRIMITIVES_GRAPH_CHOPT };
static char *_GRAPHICS_PRIMITIVES_GRAPH_guidance[] = {
 "Draw a curve through a set of points.",
 "To set Log scales in X and/or Y, use OPT LOGX/LOGY.",
 "Note that when an option is specified, it is also",
 "necessary to specify the options 'AW' or 'ALW' in order to start a new",
 "zone or/and draw the axes.", "", "Example",
 "    SET * ; OPT *                           | Reset the defaults",
 "    ZONE 1 2", " * This command needs vectors",
 "    V/CREATE Y(10) r 1 2 3 4 5 5 4 3 2 1",
 "    V/CREATE X(11) r 1 2 4 6 8 10 15 16 20 21",
 "    GRAPH 10 X Y 'WC*L'                     | Draw an 'open' graph",
 "    SET FAIS 3                              | Interior style: hatched",
 "    SET FASI 245                            | Define hatches type",
 "    SET BORD 1                              | Border requested",
 "    NULL 0 22 0 6                           | define new scales",
 "    GRAPH 10 X Y 'CF*'                      | Draw an 'closed' graph" };
static KmCommand _GRAPHICS_PRIMITIVES_GRAPH = {  (KmCommand*)0,
 "/GRAPHICS/PRIMITIVES/GRAPH", "GRAPH", 0, 2, 4, 3,
 _GRAPHICS_PRIMITIVES_GRAPH_parameters, 0, 0, pagpri_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 18, _GRAPHICS_PRIMITIVES_GRAPH_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GRAPHICS_PRIMITIVES_HIST_N_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_HIST_N = { "N", 1, "Number of values",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GRAPHICS_PRIMITIVES_HIST_N_type };
static KmParameter _GRAPHICS_PRIMITIVES_HIST_X = { "X", 1,
 "Vector name for X coordinates", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GRAPHICS_PRIMITIVES_HIST_Y = { "Y", 1,
 "Vector name for Y coordinates", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_GRAPHICS_PRIMITIVES_HIST_CHOPT_range[] = { "A", "H", "W", "R",
 "N", "F", "C", "L", "*", "P", "B" };
static char *_GRAPHICS_PRIMITIVES_HIST_CHOPT_text[] = {
 "X and Y axes are drawn (default).",
 "An histogram is drawn as a contour (default).",
 "The Window/Viewport parameters are automatically computed from the X and Y\
 values (default).",
 "The histogram is Rotated, i.e. the values in X are used for the ordinate and\
 the values in Y for the abscissa (default is the contrary). If option R is\
 selected (and option 'N' is not selected), the user must give: 2 values for Y\
 (Y(1)=YMIN and Y(2)=YMAX) N values for X, one for each bin. Otherwise the\
 user must give: N values for Y, one for each bin. 2 values for X (X(1)=XMIN\
 and X(2)=XMAX) If option 'N' is selected see below.",
 "Non equidistant bins (default is equidistant). The arrays X and Y must be\
 dimensioned as follows: If option R is not selected (default) then give:\
 (N+1) values for X (limits of bins). N values for Y, one for each bin.\
 Otherwise give: (N+1) values for Y (limits of bins). N values for X, one for\
 each bin.",
 "The area delimited by the histogram is filled according to the fill area\
 interior style and the fill area style index or colour index. Contour is not\
 drawn unless CHOPT='H' is also selected.",
 "A Smooth curve is drawn across points at the centre of each bin of the\
 histogram.",
 "A straight Line is drawn across points at the centre of each bin of the\
 histogram.", "A star is plotted at the center of each bin of the histogram.",
 "Idem as '*' but with the current marker.",
 "A Bar chart with equidistant bins is drawn as fill areas. (Contours are\
 drawn). The bar origin and the bar width can be controlled by the routine SET\
 using the options BARO and BARW respectively." };
static KmParOption _GRAPHICS_PRIMITIVES_HIST_CHOPT_type = {
 _GRAPHICS_PRIMITIVES_HIST_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GRAPHICS_PRIMITIVES_HIST_CHOPT = { "CHOPT", 5, "Options",
 "AHW", (char*)0, 8, 11, _GRAPHICS_PRIMITIVES_HIST_CHOPT_range, 11,
 _GRAPHICS_PRIMITIVES_HIST_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GRAPHICS_PRIMITIVES_HIST_CHOPT_type };
static KmParameter *_GRAPHICS_PRIMITIVES_HIST_parameters[] = {
 &_GRAPHICS_PRIMITIVES_HIST_N, &_GRAPHICS_PRIMITIVES_HIST_X,
 &_GRAPHICS_PRIMITIVES_HIST_Y, &_GRAPHICS_PRIMITIVES_HIST_CHOPT };
static char *_GRAPHICS_PRIMITIVES_HIST_guidance[] = {
 "Draw an histogram defined by arrays X and Y.",
 "The number of components needed in vectors X and/or in Y may be",
 "dependent upon the value of CHOPT (see options 'R' and 'N').",
 "To set Log scales in X and/or Y, use OPT LOGX/LOGY.",
 "Note that when an option is specified, it is also necessary to",
 "specify the options 'W' or 'HW' in order to start a new zone",
 "or/and draw the axes.", "", "Example",
 "    SET * ; OPT *                         | Reset the defaults",
 "    Zone 1 2", " * This command needs vectors",
 "    V/CREATE Y(10) r 1 2 3 4 5 5 4 3 2 1",
 "    V/CREATE X(11) r 1 2 4 6 8 10 15 16 20 21 30",
 "    HIST 10 X Y 'WH'                      | Equidistant bins",
 "    HIST 10 X Y 'HWN'                     | Non Equidistant bins" };
static KmCommand _GRAPHICS_PRIMITIVES_HIST = { &_GRAPHICS_PRIMITIVES_GRAPH,
 "/GRAPHICS/PRIMITIVES/HIST", "HIST", 0, 2, 4, 3,
 _GRAPHICS_PRIMITIVES_HIST_parameters, 0, 0, pagpri_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 16, _GRAPHICS_PRIMITIVES_HIST_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GRAPHICS_PRIMITIVES_PAVE_X1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_PAVE_X1 = { "X1", 2,
 "X bottom left corner of box", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_PAVE_X1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_PAVE_X2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_PAVE_X2 = { "X2", 2,
 "X top right corner of box", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_PAVE_X2_type };
static KmParReal   _GRAPHICS_PRIMITIVES_PAVE_Y1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_PAVE_Y1 = { "Y1", 2,
 "Y bottom left corner of box", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_PAVE_Y1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_PAVE_Y2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_PAVE_Y2 = { "Y2", 2,
 "Y top right corner of box", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_PAVE_Y2_type };
static KmParReal   _GRAPHICS_PRIMITIVES_PAVE_DZ_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_PAVE_DZ = { "DZ", 2, "Box width",
 "0.4", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GRAPHICS_PRIMITIVES_PAVE_DZ_type };
static KmParInt    _GRAPHICS_PRIMITIVES_PAVE_ISBOX_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_PAVE_ISBOX = { "ISBOX", 5,
 "Box style", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_GRAPHICS_PRIMITIVES_PAVE_ISBOX_type };
static KmParInt    _GRAPHICS_PRIMITIVES_PAVE_ISFRAM_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_PAVE_ISFRAM = { "ISFRAM", 6,
 "Frame style", "5", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_GRAPHICS_PRIMITIVES_PAVE_ISFRAM_type };
static char *_GRAPHICS_PRIMITIVES_PAVE_CHOPT_range[] = { "TR", "TL", "BR",
 "BL", "L", "R", "T-", "B-", "S", "K" };
static char *_GRAPHICS_PRIMITIVES_PAVE_CHOPT_text[] = {
 "Top and Right frame are drawn", "Top and Left frame",
 "Bottom and Right frame", "Bottom and Left frame", "Left frame only",
 "Right frame only", "Top frame only pointing left",
 "Bottom frame only pointing left", "Shadow mode", "Key mode" };
static KmParOption _GRAPHICS_PRIMITIVES_PAVE_CHOPT_type = {
 _GRAPHICS_PRIMITIVES_PAVE_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GRAPHICS_PRIMITIVES_PAVE_CHOPT = { "CHOPT", 5, "Option",
 "TR", (char*)0, 8, 10, _GRAPHICS_PRIMITIVES_PAVE_CHOPT_range, 10,
 _GRAPHICS_PRIMITIVES_PAVE_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GRAPHICS_PRIMITIVES_PAVE_CHOPT_type };
static KmParameter *_GRAPHICS_PRIMITIVES_PAVE_parameters[] = {
 &_GRAPHICS_PRIMITIVES_PAVE_X1, &_GRAPHICS_PRIMITIVES_PAVE_X2,
 &_GRAPHICS_PRIMITIVES_PAVE_Y1, &_GRAPHICS_PRIMITIVES_PAVE_Y2,
 &_GRAPHICS_PRIMITIVES_PAVE_DZ, &_GRAPHICS_PRIMITIVES_PAVE_ISBOX,
 &_GRAPHICS_PRIMITIVES_PAVE_ISFRAM, &_GRAPHICS_PRIMITIVES_PAVE_CHOPT };
static char *_GRAPHICS_PRIMITIVES_PAVE_guidance[] = {
 "Draw a paving-block (box with 3D effect).",
 "ISBOX (ISFRAM) may be 1000+ICOLOR where ICOLOR is the color index",
 "of the box (frame), otherwise the style index.",
 "If ISBOX (ISFRAM) = 0, only the box contour is drawn with the current",
 "polyline attributes.", "", "Example:",
 "    SET * ; OPT *                         | Reset the defaults",
 "    NULL 0 10 0 10                        | Draw a frame",
 "    PAVE 1 4 1 4 ! ! 1001 CHOPT=TRS", "    PAVE 5 9 1 4 ! ! 1001 CHOPT=BLS",
 "    PAVE 1 4 5 9 ! !    3 CHOPT=TR", "    PAVE 5 9 5 9 ! !    3 CHOPT=BL" };
static KmCommand _GRAPHICS_PRIMITIVES_PAVE = { &_GRAPHICS_PRIMITIVES_HIST,
 "/GRAPHICS/PRIMITIVES/PAVE", "PAVE", 0, 2, 8, 4,
 _GRAPHICS_PRIMITIVES_PAVE_parameters, 0, 0, pagpri_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 13, _GRAPHICS_PRIMITIVES_PAVE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GRAPHICS_PRIMITIVES_LABELS_LABNUM_type = { "1", "9", "1",
 "9", 0 };
static KmParameter _GRAPHICS_PRIMITIVES_LABELS_LABNUM = { "LABNUM", 6,
 "Label identifier", "1", (char*)0, 2, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GRAPHICS_PRIMITIVES_LABELS_LABNUM_type };
static KmParInt    _GRAPHICS_PRIMITIVES_LABELS_NLABS_type = { "0", "50", "0",
 "50", 0 };
static KmParameter _GRAPHICS_PRIMITIVES_LABELS_NLABS = { "NLABS", 5,
 "Number of labels", "0", (char*)0, 3, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GRAPHICS_PRIMITIVES_LABELS_NLABS_type };
static KmParameter _GRAPHICS_PRIMITIVES_LABELS_CHLABS = { "CHLABS", 6,
 "List of labels", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)8, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GRAPHICS_PRIMITIVES_LABELS_parameters[] = {
 &_GRAPHICS_PRIMITIVES_LABELS_LABNUM, &_GRAPHICS_PRIMITIVES_LABELS_NLABS,
 &_GRAPHICS_PRIMITIVES_LABELS_CHLABS };
static char *_GRAPHICS_PRIMITIVES_LABELS_guidance[] = {
 "Define a list of alphanumeric labels",
 "to be used by subsequent commands such as PIE and AXIS. The position of",
 "the labels on the axis may be changed with SET NDVX (NDVY).", "",
 "Example:", "    SET * ; OPT *                 | Reset the defaults",
 "    ZONE 1 3", "    LABEL 1 3 AAAAA BBBBB CCCCC   | Define labels",
 "    SET NDVX 3.15                 | 3 div, lab id 1, 5=center on bin",
 "    NULL 0 10 0 1                 | Draw a frame",
 "    SET NDVX 3.11                 | 3 div, lab id 1, 1=center on tick",
 "    NULL 0 10 0 1                 | Draw a frame",
 "    SET NDVX 3.18                 | 3 div, lab id 1, 8=bottom -> up",
 "    NULL 0 10 0 1                 | Draw a frame", "",
 "A full description of the possible alignments is given in the PAW",
 "manual (see NDVX in the index)." };
static KmCommand _GRAPHICS_PRIMITIVES_LABELS = { &_GRAPHICS_PRIMITIVES_PAVE,
 "/GRAPHICS/PRIMITIVES/LABELS", "LABELS", 0, 2, 3, 3,
 _GRAPHICS_PRIMITIVES_LABELS_parameters, 0, 0, pagpri_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 17, _GRAPHICS_PRIMITIVES_LABELS_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GRAPHICS_PRIMITIVES_ITX_X_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ITX_X = { "X", 1, "X coordinate",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ITX_X_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ITX_Y_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ITX_Y = { "Y", 1, "Y coordinate",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ITX_Y_type };
static KmParameter _GRAPHICS_PRIMITIVES_ITX_TEXT = { "TEXT", 4,
 "Text to be drawn", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GRAPHICS_PRIMITIVES_ITX_parameters[] = {
 &_GRAPHICS_PRIMITIVES_ITX_X, &_GRAPHICS_PRIMITIVES_ITX_Y,
 &_GRAPHICS_PRIMITIVES_ITX_TEXT };
static char *_GRAPHICS_PRIMITIVES_ITX_guidance[] = {
 "Draw text at position X,Y in the current Normalisation transformation,",
 "using the current font parameters.",
 "The font and the precision can be changed by SET TXFP.",
 "The character size can be changed by SET CHHE.",
 "The text color can be changed by SET TXCI.",
 "The text orientation can be changed with SET TXAL.",
 "The text angle can be changed by SET TANG.", "", "Example:",
 "    SET * ; OPT *                         | Reset the defaults",
 "    NULL 0 10 0 6                         | Draw a frame",
 "    SET TXFP -20                          | Times bold",
 "    SET CHHE .5                           | Text size 0.5 cm",
 "    SET TXAL 10                           | Horizontal align. Left",
 "    ITX 5 1 'Left justified'",
 "    SET TXAL 20                           | Horizontal align. Center",
 "    ITX 5 2 'Centered'",
 "    SET TXAL 30                           | Horizontal align. Right",
 "    ITX 5 3 'Right justified'",
 "    SET TXAL 12                           | Vertical align. Top",
 "    ITX .2 4 'Top justified'",
 "    SET TXAL 13                           | Vertical align. Middle",
 "    ITX .2 5 'Middle justified'",
 "    SET TXAL  0                           | Default align.",
 "    SET TANG 30                           | Angle 30 degrees",
 "    ITX 5 4 '-- 30 degrees --'" };
static KmCommand _GRAPHICS_PRIMITIVES_ITX = { &_GRAPHICS_PRIMITIVES_LABELS,
 "/GRAPHICS/PRIMITIVES/ITX", "ITX", 0, 2, 3, 3,
 _GRAPHICS_PRIMITIVES_ITX_parameters, 0, 0, pagpri_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 26, _GRAPHICS_PRIMITIVES_ITX_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GRAPHICS_PRIMITIVES_TEXT_X_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_TEXT_X = { "X", 1, "X coordinate",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_TEXT_X_type };
static KmParReal   _GRAPHICS_PRIMITIVES_TEXT_Y_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_TEXT_Y = { "Y", 1, "Y coordinate",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_TEXT_Y_type };
static KmParameter _GRAPHICS_PRIMITIVES_TEXT_TEXT = { "TEXT", 4,
 "Text to be drawn", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _GRAPHICS_PRIMITIVES_TEXT_SIZE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_TEXT_SIZE = { "SIZE", 4, "Text size",
 "0.3", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GRAPHICS_PRIMITIVES_TEXT_SIZE_type };
static KmParReal   _GRAPHICS_PRIMITIVES_TEXT_ANGLE_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_TEXT_ANGLE = { "ANGLE", 5,
 "Comment angle", "0", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_TEXT_ANGLE_type };
static char *_GRAPHICS_PRIMITIVES_TEXT_CHOPT_range[] = { "L", "C", "R" };
static char *_GRAPHICS_PRIMITIVES_TEXT_CHOPT_text[] = {
 "Text is Left justified.", "Text is Centered.", "Text is Right justified." };
static KmParOption _GRAPHICS_PRIMITIVES_TEXT_CHOPT_type = {
 _GRAPHICS_PRIMITIVES_TEXT_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GRAPHICS_PRIMITIVES_TEXT_CHOPT = { "CHOPT", 5,
 "Justification option", "L", (char*)0, 8, 3,
 _GRAPHICS_PRIMITIVES_TEXT_CHOPT_range, 3,
 _GRAPHICS_PRIMITIVES_TEXT_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GRAPHICS_PRIMITIVES_TEXT_CHOPT_type };
static KmParameter *_GRAPHICS_PRIMITIVES_TEXT_parameters[] = {
 &_GRAPHICS_PRIMITIVES_TEXT_X, &_GRAPHICS_PRIMITIVES_TEXT_Y,
 &_GRAPHICS_PRIMITIVES_TEXT_TEXT, &_GRAPHICS_PRIMITIVES_TEXT_SIZE,
 &_GRAPHICS_PRIMITIVES_TEXT_ANGLE, &_GRAPHICS_PRIMITIVES_TEXT_CHOPT };
static char *_GRAPHICS_PRIMITIVES_TEXT_guidance[] = {
 "Draw text at position X,Y",
 "in the current normalisation transformation using the software font",
 "IGTEXT. SIZE is always given in centimeters (as defined by the command",
 "SIZE). A boldface effect can be obtained using the parameters PASS and",
 "CSHI of the command SET. The text color can be changed by SET TXCI.", "",
 "Example:",
 "    SET * ; OPT *                                   | Reset the defaults",
 "    NULL 0 10 0 10                                  | Draw a frame",
 "    TEXT 5 1 'Left justified' .5 0. L", "    TEXT 5 2 'Centered' .5 0. C",
 "    TEXT 5 3 'Right justified' .5 0. R",
 "    TEXT 5 4 '-- 30 degrees' .5 30. L",
 "    TEXT 5 4 '-- 60 degrees' .5 60. L",
 "    TEXT 5 4 '-- 90 degrees' .5 90. L",
 "    TEXT 5 4 '-- 120 degrees' .5 120. L",
 "    TEXT 5 4 '-- 150 degrees' .5 150. L",
 "    TEXT 5 8 'Some Greek ... [a, b, c, d]' .5 0. C",
 "    Set PASS 7                                      | Number of passes",
 "    TEXT 5 9 'Bold TEXT' .5 0. C" };
static KmCommand _GRAPHICS_PRIMITIVES_TEXT = { &_GRAPHICS_PRIMITIVES_ITX,
 "/GRAPHICS/PRIMITIVES/TEXT", "TEXT", 0, 2, 6, 4,
 _GRAPHICS_PRIMITIVES_TEXT_parameters, 0, 0, pagpri_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 20, _GRAPHICS_PRIMITIVES_TEXT_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GRAPHICS_PRIMITIVES_PIE_X0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_PIE_X0 = { "X0", 2,
 "X coordinate of centre of the pie", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_PIE_X0_type };
static KmParReal   _GRAPHICS_PRIMITIVES_PIE_Y0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_PIE_Y0 = { "Y0", 2,
 "Y coordinate of centre of the pie", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_PIE_Y0_type };
static KmParReal   _GRAPHICS_PRIMITIVES_PIE_RADIUS_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_PIE_RADIUS = { "RADIUS", 6,
 "Radius of the pie chart", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_PIE_RADIUS_type };
static KmParInt    _GRAPHICS_PRIMITIVES_PIE_N_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_PIE_N = { "N", 1, "Number of values",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GRAPHICS_PRIMITIVES_PIE_N_type };
static KmParameter _GRAPHICS_PRIMITIVES_PIE_VALUES = { "VALUES", 6,
 "Vector name for N values", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_GRAPHICS_PRIMITIVES_PIE_CHOPT_range[] = { "", "C", "L", "O",
 "N", "P", "S", "H", "R" };
static char *_GRAPHICS_PRIMITIVES_PIE_CHOPT_text[] = {
 "Draw a Pie Chart with default values.", "Colours array is present.",
 "Alphanumeric labels are required.", "Offset array is present.",
 "The label of each slice will be the corresponding numeric value in array\
 VALUES.", "The label of each slice will be in expressed in percentage.",
 "Style array is present.",
 "Force the labels size to be the current character height. Without this\
 option the labels size is computed automatically.",
 "Draw the labels aligned on the radius of each slice." };
static KmParOption _GRAPHICS_PRIMITIVES_PIE_CHOPT_type = {
 _GRAPHICS_PRIMITIVES_PIE_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GRAPHICS_PRIMITIVES_PIE_CHOPT = { "CHOPT", 5, "Options",
 " ", (char*)0, 8, 9, _GRAPHICS_PRIMITIVES_PIE_CHOPT_range, 9,
 _GRAPHICS_PRIMITIVES_PIE_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GRAPHICS_PRIMITIVES_PIE_CHOPT_type };
static KmParameter _GRAPHICS_PRIMITIVES_PIE_IAO = { "IAO", 3,
 "Name of vector with offsets", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GRAPHICS_PRIMITIVES_PIE_IAS = { "IAS", 3,
 "Name of vector with styles", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GRAPHICS_PRIMITIVES_PIE_IAC = { "IAC", 3,
 "Name of vector with colors", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GRAPHICS_PRIMITIVES_PIE_parameters[] = {
 &_GRAPHICS_PRIMITIVES_PIE_X0, &_GRAPHICS_PRIMITIVES_PIE_Y0,
 &_GRAPHICS_PRIMITIVES_PIE_RADIUS, &_GRAPHICS_PRIMITIVES_PIE_N,
 &_GRAPHICS_PRIMITIVES_PIE_VALUES, &_GRAPHICS_PRIMITIVES_PIE_CHOPT,
 &_GRAPHICS_PRIMITIVES_PIE_IAO, &_GRAPHICS_PRIMITIVES_PIE_IAS,
 &_GRAPHICS_PRIMITIVES_PIE_IAC };
static char *_GRAPHICS_PRIMITIVES_PIE_guidance[] = { "Draw a pie chart",
 "in the current Normalisation transformation.", "", "Example:",
 "    SET * ; OPT *                                 | Reset the defaults",
 "    NULL 0 20 0 20 'AB'                           | Draw a frame",
 "    LABEL 1 5 'Lab1' 'Lab2' 'Lab3' 'Lab4' 'Lab5'  | define labels",
 " * Initialize vectors", "    V/CRE VWS(5) R 28.3 18.6 16.9 13.5 22.7",
 "    V/CRE OFFSET(5)  R 2*0. 2*20. 0.", "    V/CRE COLOUR(5)  R 2 3 4 5 6",
 "    SET FAIS 1                                    | Fill solid",
 "    SET BORD 1                                    | Draw the border",
 "    PIE 10. 10. 7.  5 VWS 'L' OFFSET ! COLOUR     | Draw the pie chart" };
static KmCommand _GRAPHICS_PRIMITIVES_PIE = { &_GRAPHICS_PRIMITIVES_TEXT,
 "/GRAPHICS/PRIMITIVES/PIE", "PIE", 0, 2, 9, 5,
 _GRAPHICS_PRIMITIVES_PIE_parameters, 0, 0, pagpri_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 14, _GRAPHICS_PRIMITIVES_PIE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GRAPHICS_PRIMITIVES_ELLIPSE_XC_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ELLIPSE_XC = { "XC", 2,
 "X coord of centre", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ELLIPSE_XC_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ELLIPSE_YC_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ELLIPSE_YC = { "YC", 2,
 "Y coord of centre", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ELLIPSE_YC_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ELLIPSE_RX_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ELLIPSE_RX = { "RX", 2,
 "X radius of ellipse", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ELLIPSE_RX_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ELLIPSE_RY_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ELLIPSE_RY = { "RY", 2,
 "Y radius of ellipse", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ELLIPSE_RY_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ELLIPSE_PHIMIN_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ELLIPSE_PHIMIN = { "PHIMIN", 6,
 "Minimum angle (degrees)", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ELLIPSE_PHIMIN_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ELLIPSE_PHIMAX_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ELLIPSE_PHIMAX = { "PHIMAX", 6,
 "Maximum angle (degrees)", "360.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ELLIPSE_PHIMAX_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ELLIPSE_THETA_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ELLIPSE_THETA = { "THETA", 5,
 "Rotation of axes of (degrees)", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GRAPHICS_PRIMITIVES_ELLIPSE_THETA_type };
static KmParameter *_GRAPHICS_PRIMITIVES_ELLIPSE_parameters[] = {
 &_GRAPHICS_PRIMITIVES_ELLIPSE_XC, &_GRAPHICS_PRIMITIVES_ELLIPSE_YC,
 &_GRAPHICS_PRIMITIVES_ELLIPSE_RX, &_GRAPHICS_PRIMITIVES_ELLIPSE_RY,
 &_GRAPHICS_PRIMITIVES_ELLIPSE_PHIMIN, &_GRAPHICS_PRIMITIVES_ELLIPSE_PHIMAX,
 &_GRAPHICS_PRIMITIVES_ELLIPSE_THETA };
static char *_GRAPHICS_PRIMITIVES_ELLIPSE_guidance[] = {
 "Draws an ellipse in the current normalization transformation.",
 "The parameter THETA rotates the ellipse major and minor axes",
 "(RX and RY) relative to the coordinates by the given angle.",
 "The a filled area is used, so the ellipse may be filled by",
 "changing the appropriate SET parameters.", "", "Example:",
 "    SET * ; OPT *          | Reset the defaults",
 "    NULL 0 10 0 10 'AB'    | Draw a frame (cf HELP NULL)",
 "    SET PLCI 2             | Line color is red",
 "    SET LWID 6             | Line width is 6",
 "    SET BORD 1             | Border on",
 "    SET FAIS 1             | Filled area",
 "    SET FACI 3             | Filled area are green",
 "    ELLIPSE  5 5 3 5       | Draw an ellipse" };
static KmCommand _GRAPHICS_PRIMITIVES_ELLIPSE = { &_GRAPHICS_PRIMITIVES_PIE,
 "/GRAPHICS/PRIMITIVES/ELLIPSE", "ELLIPSE", 0, 2, 7, 3,
 _GRAPHICS_PRIMITIVES_ELLIPSE_parameters, 0, 0, pagpri_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 15, _GRAPHICS_PRIMITIVES_ELLIPSE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GRAPHICS_PRIMITIVES_ARC_X1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARC_X1 = { "X1", 2,
 "X coordinate of centre", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARC_X1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ARC_Y1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARC_Y1 = { "Y1", 2,
 "Y coordinate of centre", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARC_Y1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ARC_R1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARC_R1 = { "R1", 2, "Inner radius",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARC_R1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ARC_R2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARC_R2 = { "R2", 2, "Outer radius",
 "-1.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GRAPHICS_PRIMITIVES_ARC_R2_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ARC_PHIMIN_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARC_PHIMIN = { "PHIMIN", 6,
 "Minimum angle", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARC_PHIMIN_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ARC_PHIMAX_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARC_PHIMAX = { "PHIMAX", 6,
 "Maximum angle", "360.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARC_PHIMAX_type };
static KmParameter *_GRAPHICS_PRIMITIVES_ARC_parameters[] = {
 &_GRAPHICS_PRIMITIVES_ARC_X1, &_GRAPHICS_PRIMITIVES_ARC_Y1,
 &_GRAPHICS_PRIMITIVES_ARC_R1, &_GRAPHICS_PRIMITIVES_ARC_R2,
 &_GRAPHICS_PRIMITIVES_ARC_PHIMIN, &_GRAPHICS_PRIMITIVES_ARC_PHIMAX };
static char *_GRAPHICS_PRIMITIVES_ARC_guidance[] = { "Draw an arc of circle",
 "with the current fill area and line attributes.",
 "Use the current Normalisation transformation.",
 "If R1 is not equal to R2 the area between the two arcs of radius",
 "R1 and R2 is filled according to the current fill area attributes.",
 "The border is never drawn unless the interior style is hollow or",
 "the command SET BORD 1 has been called. If R1 is equal to R2 a",
 "polyline is drawn.", "", "Example:",
 "    SET * ; OPT *          | Reset the defaults",
 "    NULL 0 20 0 20 'AB'    | Draw a frame (cf HELP NULL)",
 "    SET PLCI 2             | Line color is red",
 "    SET LWID 6             | Line width is 6",
 "    ARC  5  5 4 4 ! !      | Draw an circle",
 "    ARC  5 15 4 4 30 260   | Draw an arc of circle",
 "    SET FAIS 3             | Fill area with hatches",
 "    SET FASI 3             | Type of hatches",
 "    ARC 15 15 1 4 ! !      | Draw an arc",
 "    SET BORD 1             | Border is requested",
 "    ARC 15  5 1 4 30 !     | Draw an arc" };
static KmCommand _GRAPHICS_PRIMITIVES_ARC = { &_GRAPHICS_PRIMITIVES_ELLIPSE,
 "/GRAPHICS/PRIMITIVES/ARC", "ARC", 0, 2, 6, 3,
 _GRAPHICS_PRIMITIVES_ARC_parameters, 0, 0, pagpri_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 21, _GRAPHICS_PRIMITIVES_ARC_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GRAPHICS_PRIMITIVES_AXIS_X0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_AXIS_X0 = { "X0", 2,
 "X axis origin in WC", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_AXIS_X0_type };
static KmParReal   _GRAPHICS_PRIMITIVES_AXIS_X1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_AXIS_X1 = { "X1", 2,
 "X end axis in WC", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_AXIS_X1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_AXIS_Y0_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_AXIS_Y0 = { "Y0", 2,
 "Y axis origin in WC", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_AXIS_Y0_type };
static KmParReal   _GRAPHICS_PRIMITIVES_AXIS_Y1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_AXIS_Y1 = { "Y1", 2,
 "Y end axis in WC", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_AXIS_Y1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_AXIS_WMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_AXIS_WMIN = { "WMIN", 4,
 "Lowest value for labels", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_AXIS_WMIN_type };
static KmParReal   _GRAPHICS_PRIMITIVES_AXIS_WMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_AXIS_WMAX = { "WMAX", 4,
 "Highest value for labels", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_AXIS_WMAX_type };
static KmParInt    _GRAPHICS_PRIMITIVES_AXIS_NDIV_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_AXIS_NDIV = { "NDIV", 4,
 "Number of divisions", "510", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GRAPHICS_PRIMITIVES_AXIS_NDIV_type };
static char *_GRAPHICS_PRIMITIVES_AXIS_CHOPT_range[] = { "", "G", "B", "U",
 "+", "-", "=", "P", "O", "0", "R", "L", "C", "M", "Y", ".", "T", "S", "H",
 "D", "N", "I" };
static char *_GRAPHICS_PRIMITIVES_AXIS_CHOPT_text[] = {
 "Draw an axis with default values.", "Logarithmic scale, default is linear.",
 "Blank axis. Useful to superpose axis.",
 "Unlabeled axis, default is labeled.",
 "Tick marks are drawn on Positive side. (default)",
 "Tick marks are drawn on the negative side.",
 "Tick marks are drawn on Equal side",
 "Labels are drawn Parallel to the axis",
 "Labels are drawn Orthogonal to the axis (Top to Down).",
 "Labels are drawn Orthogonal to the axis (Down to Top).",
 "labels are Right adjusted on tick mark.",
 "labels are Left adjusted on tick mark.",
 "labels are Centered on tick mark.", "In the Middle of the divisions.",
 "Direction of labels DOWN . Default is RIGHT", "Dot obligatory",
 "Alphanumeric labels .", "Tick marks Size", "Labels Height",
 "Distance labels-axis", "No bining optimisation", "Integer labeling" };
static KmParOption _GRAPHICS_PRIMITIVES_AXIS_CHOPT_type = {
 _GRAPHICS_PRIMITIVES_AXIS_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GRAPHICS_PRIMITIVES_AXIS_CHOPT = { "CHOPT", 5, "Options",
 " ", (char*)0, 8, 22, _GRAPHICS_PRIMITIVES_AXIS_CHOPT_range, 22,
 _GRAPHICS_PRIMITIVES_AXIS_CHOPT_range, (KmParFlag)2, KmTYPE_OPTION,
 &_GRAPHICS_PRIMITIVES_AXIS_CHOPT_type };
static KmParameter *_GRAPHICS_PRIMITIVES_AXIS_parameters[] = {
 &_GRAPHICS_PRIMITIVES_AXIS_X0, &_GRAPHICS_PRIMITIVES_AXIS_X1,
 &_GRAPHICS_PRIMITIVES_AXIS_Y0, &_GRAPHICS_PRIMITIVES_AXIS_Y1,
 &_GRAPHICS_PRIMITIVES_AXIS_WMIN, &_GRAPHICS_PRIMITIVES_AXIS_WMAX,
 &_GRAPHICS_PRIMITIVES_AXIS_NDIV, &_GRAPHICS_PRIMITIVES_AXIS_CHOPT };
static char *_GRAPHICS_PRIMITIVES_AXIS_guidance[] = {
 "Draw an axis in the current Normalisation transformation.",
 "        NDIV=N1 + 100*N2 + 10000*N3",
 "        N1, N2, N3 = Number of 1st, 2nd, 3rd divisions respectively, eg:.",
 "            NDIV=0 --> no tick marks.",
 "            NDIV=2 --> 2 divisions, one tick mark in the middle",
 "                     of the axis.",
 "  Orientation of tick marks on axis: Tick marks are normally drawn",
 "  on the positive side of the axis.However, if X0=X1, then Negative .",
 "        CHOPT='+': tick marks are drawn on Positive side. (default)",
 "        CHOPT='-': tick marks are drawn on the negative side.",
 "        i.e: '+-' --> tick marks are drawn on both sides of the axis.",
 "  Position of labels on axis: Labels are normally drawn on side",
 "  opposite to tick marks.However:", "        CHOPT= '='   on Equal side",
 "  Orientation of labels on axis: Labels are normally drawn",
 "  parallel to the axis. However if X0=X1, then Orthogonal",
 "                                if Y0=Y1, then Parallel",
 "        CHOPT= 'P' : Parallel to the axis",
 "        CHOPT= 'O' : Orthogonal to the axis (Top to Down).",
 "        CHOPT= '0' : Orthogonal to the axis (Down to Top).",
 "  Position of labels on tick marks: Labels are centered on",
 "  tick marks. However , if X0=X1, then they are right adjusted.",
 "        CHOPT='R': labels are Right adjusted on tick mark.",
 "                   (default is centered)",
 "        CHOPT='L': labels are Left adjusted on tick mark.",
 "        CHOPT='C': labels are Centered on tick mark.",
 "        CHOPT='M': In the Middle of the divisions.",
 "  Direction of labels: Default is RIGHT", "        CHOPT='Y':   Down",
 "  Format of labels: Blank characters are stripped, and then the",
 "  label is correctly aligned. The dot,if last character of the",
 "  string, is also stripped, unless", "        CHOPT='.'     Dot obligatory",
 "  In the following, we have some parameters, like",
 "  tick marks length and characters height (in percentage",
 "  of the length of the axis).The default values are as follows:",
 "     Primary tick marks: 3.0 %", "     Secondary tick marks: 1.5 %",
 "     Third order tick marks: .75 %",
 "     Characters height for labels: 2%",
 "     Characters spacing (related to height): 40%",
 "     Labels offset: 4.0 %",
 "  Type of labels: Labels are normally numeric . However, alphanumeric",
 "  labels can be drawn (see command LABEL).",
 "        CHOPT='T':   Alphanumeric labels .",
 "  Intrinsic parameters: These values can be changed with the command",
 "  SET. The default value is used unless the corresponding option is",
 "  selected by CHOPT:",
 "        CHOPT='D' The distance between the labels and the axis",
 "                  (the offset) is given by the preceding command",
 "                  SET with the parameter LAOF.",
 "        CHOPT='H' The size (height) of the labels is given by the",
 "                  preceding command SET with the parameter LASI.",
 "        CHOPT='S' The size of the tick marks is given by the preceding",
 "                  command SET with the parameter TMSI.",
 "  Axis bining optimisation: By default the axis bining is optimized .",
 "        CHOPT='N': No bining optimisation",
 "        CHOPT='I': Integer labeling", "", "Example:",
 "    SET * ; OPT *                          | Reset the defaults",
 "    NUL 0 12 0 12 'A'                      | Draw a frame (cf HELP NULL)",
 "    AXIS 1  11  1  1  0  100  510 'A'      | Axis with arrow",
 "    AXIS 1  11  3  3  1  10000  510 'G'    | LOG axis",
 "    LABEL 1 11 a b c d e f g h i j k       | define alphanumeric labels",
 "    AXIS 1  11  5  5  0  12  11 'NATY'     | alphanumeric labeling",
 "    AXIS 1  11  6  6  -100  0  510 'A'",
 "    AXIS 11  1  7  7  -100  0  810 'A+-'   | Double side tick marks",
 "    AXIS 1  11  8  11  0  1234567  615 'A' | exponent is required", "",
 "Note that the command TIC provides a simpler interface to redraw axis",
 "on the current plot. Moreover it use the NDVX, NDVY etc .. attributes." };
static KmCommand _GRAPHICS_PRIMITIVES_AXIS = { &_GRAPHICS_PRIMITIVES_ARC,
 "/GRAPHICS/PRIMITIVES/AXIS", "AXIS", 0, 2, 8, 7,
 _GRAPHICS_PRIMITIVES_AXIS_parameters, 0, 0, pagpri_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 72, _GRAPHICS_PRIMITIVES_AXIS_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GRAPHICS_PRIMITIVES_FPOINT_X_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_FPOINT_X = { "X", 1, "X      ", "0.",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GRAPHICS_PRIMITIVES_FPOINT_X_type };
static KmParReal   _GRAPHICS_PRIMITIVES_FPOINT_Y_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_FPOINT_Y = { "Y", 1, "Y      ", "0.",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GRAPHICS_PRIMITIVES_FPOINT_Y_type };
static KmParReal   _GRAPHICS_PRIMITIVES_FPOINT_R_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_FPOINT_R = { "R", 1, "Radius ", ".5",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GRAPHICS_PRIMITIVES_FPOINT_R_type };
static KmParameter *_GRAPHICS_PRIMITIVES_FPOINT_parameters[] = {
 &_GRAPHICS_PRIMITIVES_FPOINT_X, &_GRAPHICS_PRIMITIVES_FPOINT_Y,
 &_GRAPHICS_PRIMITIVES_FPOINT_R };
static char *_GRAPHICS_PRIMITIVES_FPOINT_guidance[] = {
 "Draw a filled point (vertex)", "with the current fill area attributes.",
 "Use the current Normalisation transformation.", "", "Example:",
 "    SET * ; OPT *          | Reset the defaults",
 "    NULL 0 10 0 10         | Draw a frame (cf HELP NULL)",
 "    SET FAIS 1             | Fill area interior style solid",
 "    FPOINT 5 1 .1          | Draw a filled point",
 "    FPOINT 5 3 .2          | Draw a filled point",
 "    FPOINT 5 5 .3          | Draw a filled point",
 "    SET FACI 4             | The fill area color is blue",
 "    FPOINT 5 7 .4          | Draw a filled point",
 "    FPOINT 5 9 .5          | Draw a filled point" };
static KmCommand _GRAPHICS_PRIMITIVES_FPOINT = { &_GRAPHICS_PRIMITIVES_AXIS,
 "/GRAPHICS/PRIMITIVES/FPOINT", "FPOINT", 0, 2, 3, 0,
 _GRAPHICS_PRIMITIVES_FPOINT_parameters, 0, 0, pafeyn_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 14, _GRAPHICS_PRIMITIVES_FPOINT_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GRAPHICS_PRIMITIVES_ARLINE_X1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARLINE_X1 = { "X1", 2,
 "X coordinate of the begin", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARLINE_X1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ARLINE_Y1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARLINE_Y1 = { "Y1", 2,
 "Y coordinate of the begin", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARLINE_Y1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ARLINE_X2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARLINE_X2 = { "X2", 2,
 "X coordinate of the end", "10.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARLINE_X2_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ARLINE_Y2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARLINE_Y2 = { "Y2", 2,
 "Y coordinate of the end", "10.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARLINE_Y2_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ARLINE_H_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARLINE_H = { "H", 1, "arrow size",
 ".5", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GRAPHICS_PRIMITIVES_ARLINE_H_type };
static KmParameter *_GRAPHICS_PRIMITIVES_ARLINE_parameters[] = {
 &_GRAPHICS_PRIMITIVES_ARLINE_X1, &_GRAPHICS_PRIMITIVES_ARLINE_Y1,
 &_GRAPHICS_PRIMITIVES_ARLINE_X2, &_GRAPHICS_PRIMITIVES_ARLINE_Y2,
 &_GRAPHICS_PRIMITIVES_ARLINE_H };
static char *_GRAPHICS_PRIMITIVES_ARLINE_guidance[] = {
 "Draw a line with arrow in middle (fermion line)",
 "with the current line and fill area attributes.",
 "Use the current Normalisation transformation.", "", "Example:",
 "    SET * ; OPT *          | Reset the defaults",
 "    NULL 0 10 0 6          | Draw a frame (cf HELP NULL)",
 "    ARLINE 1 1 9 1 .2      | Draw a arrow line (left to right)",
 "    ARLINE 9 2 1 2 .4      | Draw a arrow line (right to left)",
 "    SET PLCI 2             | Arrow color is red",
 "    SET FAIS 1             | Fill area interior style solid",
 "    ARLINE 9 3 1 3 .4      | Draw a arrow line (right to left)",
 "    SET LWID 8             | Arrow line width is 8",
 "    SET FACI 4             | The fill area color is blue",
 "    ARLINE 9 4 1 4 .4      | Draw a arrow line (right to left)",
 "    SET LTYP 3             | Arrow line type is dotted",
 "    ARLINE 9 5 1 5 .4      | Draw a arrow line (right to left)" };
static KmCommand _GRAPHICS_PRIMITIVES_ARLINE = { &_GRAPHICS_PRIMITIVES_FPOINT,
 "/GRAPHICS/PRIMITIVES/ARLINE", "ARLINE", 0, 2, 5, 0,
 _GRAPHICS_PRIMITIVES_ARLINE_parameters, 0, 0, pafeyn_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 17, _GRAPHICS_PRIMITIVES_ARLINE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GRAPHICS_PRIMITIVES_ARCHELIX_X1_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARCHELIX_X1 = { "X1", 2,
 "X coordinate of the begin of helix", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARCHELIX_X1_type
 };
static KmParReal   _GRAPHICS_PRIMITIVES_ARCHELIX_Y1_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARCHELIX_Y1 = { "Y1", 2,
 "Y coordinate of the begin of helix", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARCHELIX_Y1_type
 };
static KmParReal   _GRAPHICS_PRIMITIVES_ARCHELIX_X2_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARCHELIX_X2 = { "X2", 2,
 "X coordinate of the end of helix", "10.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARCHELIX_X2_type
 };
static KmParReal   _GRAPHICS_PRIMITIVES_ARCHELIX_Y2_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARCHELIX_Y2 = { "Y2", 2,
 "Y coordinate of the end of helix", "10.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARCHELIX_Y2_type
 };
static KmParReal   _GRAPHICS_PRIMITIVES_ARCHELIX_R_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARCHELIX_R = { "R", 1,
 "Radius of helix", ".3", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARCHELIX_R_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ARCHELIX_WI_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARCHELIX_WI = { "WI", 2,
 "Number of turns  ", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARCHELIX_WI_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ARCHELIX_PHI_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARCHELIX_PHI = { "PHI", 3,
 "Projection angle ", "30.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARCHELIX_PHI_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ARCHELIX_RL_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARCHELIX_RL = { "RL", 2,
 "Radius   of loop ", "15.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARCHELIX_RL_type };
static KmParameter *_GRAPHICS_PRIMITIVES_ARCHELIX_parameters[] = {
 &_GRAPHICS_PRIMITIVES_ARCHELIX_X1, &_GRAPHICS_PRIMITIVES_ARCHELIX_Y1,
 &_GRAPHICS_PRIMITIVES_ARCHELIX_X2, &_GRAPHICS_PRIMITIVES_ARCHELIX_Y2,
 &_GRAPHICS_PRIMITIVES_ARCHELIX_R, &_GRAPHICS_PRIMITIVES_ARCHELIX_WI,
 &_GRAPHICS_PRIMITIVES_ARCHELIX_PHI, &_GRAPHICS_PRIMITIVES_ARCHELIX_RL };
static char *_GRAPHICS_PRIMITIVES_ARCHELIX_guidance[] = { "Draw an archelix",
 "with the current line attributes.",
 "Use the current Normalisation transformation.",
 "Feynman graph: gluon phi = 30, photon phi = 0.", "", "Example:",
 "    SET * ; OPT *               | Reset the defaults",
 "    NUL 0 10 0 10 'AB'          | Draw a frame (cf HELP NULL)",
 "    ARCHELIX 1 1 3 3 ! 9 ! 1    | Draw an helix",
 "    SET LWID 8                  | Helix line width is 8",
 "    ARCHELIX 3 3 7 7 ! 9 ! 1    | Draw an helix",
 "    SET PLCI 2                  | Arrow color is red",
 "    SET LTYP 2                  | Helix line type is dashed",
 "    ARCHELIX 7 7 10 10 ! 9 ! 3  | Draw an helix" };
static KmCommand _GRAPHICS_PRIMITIVES_ARCHELIX = {
 &_GRAPHICS_PRIMITIVES_ARLINE, "/GRAPHICS/PRIMITIVES/ARCHELIX", "ARCHELIX", 0,
 2, 8, 0, _GRAPHICS_PRIMITIVES_ARCHELIX_parameters, 0, 0, pafeyn_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 14,
 _GRAPHICS_PRIMITIVES_ARCHELIX_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParReal   _GRAPHICS_PRIMITIVES_HELIX_X1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_HELIX_X1 = { "X1", 2,
 "X coordinate of the begin of helix", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_HELIX_X1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_HELIX_Y1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_HELIX_Y1 = { "Y1", 2,
 "Y coordinate of the begin of helix", "0.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_HELIX_Y1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_HELIX_X2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_HELIX_X2 = { "X2", 2,
 "X coordinate of the end of helix", "10.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_HELIX_X2_type };
static KmParReal   _GRAPHICS_PRIMITIVES_HELIX_Y2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_HELIX_Y2 = { "Y2", 2,
 "Y coordinate of the end of helix", "10.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_HELIX_Y2_type };
static KmParReal   _GRAPHICS_PRIMITIVES_HELIX_R_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_HELIX_R = { "R", 1, "Radius of helix",
 ".3", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GRAPHICS_PRIMITIVES_HELIX_R_type };
static KmParReal   _GRAPHICS_PRIMITIVES_HELIX_WI_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_HELIX_WI = { "WI", 2,
 "Number of turns  ", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_HELIX_WI_type };
static KmParReal   _GRAPHICS_PRIMITIVES_HELIX_PHI_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_HELIX_PHI = { "PHI", 3,
 "Projection angle ", "15.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_HELIX_PHI_type };
static KmParameter *_GRAPHICS_PRIMITIVES_HELIX_parameters[] = {
 &_GRAPHICS_PRIMITIVES_HELIX_X1, &_GRAPHICS_PRIMITIVES_HELIX_Y1,
 &_GRAPHICS_PRIMITIVES_HELIX_X2, &_GRAPHICS_PRIMITIVES_HELIX_Y2,
 &_GRAPHICS_PRIMITIVES_HELIX_R, &_GRAPHICS_PRIMITIVES_HELIX_WI,
 &_GRAPHICS_PRIMITIVES_HELIX_PHI };
static char *_GRAPHICS_PRIMITIVES_HELIX_guidance[] = { "Draw an helix",
 "with the current line attributes.",
 "Use the current Normalisation transformation.",
 "Feynman graph: gluon phi = 30, photon phi = 0.", "", "Example:",
 "    SET * ; OPT *             | Reset the defaults",
 "    NUL 0 10 0 10 'AB'        | Draw a frame (cf HELP NULL)",
 "    HELIX 1 1 3 3 ! 10 !      | Draw an helix",
 "    SET LWID 8                | Helix line width is 8",
 "    HELIX 3 3 7 7 1  5 !      | Draw an helix",
 "    SET PLCI 2                | Arrow color is red",
 "    SET LTYP 2                | Helix line type is dashed",
 "    HELIX 7 7 10 10 .2 5 10   | Draw an helix" };
static KmCommand _GRAPHICS_PRIMITIVES_HELIX = {
 &_GRAPHICS_PRIMITIVES_ARCHELIX, "/GRAPHICS/PRIMITIVES/HELIX", "HELIX", 0, 2,
 7, 0, _GRAPHICS_PRIMITIVES_HELIX_parameters, 0, 0, pafeyn_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 14, _GRAPHICS_PRIMITIVES_HELIX_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GRAPHICS_PRIMITIVES_ARROW_X1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARROW_X1 = { "X1", 2,
 "X coordinate of start point", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARROW_X1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ARROW_X2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARROW_X2 = { "X2", 2,
 "X coordinate of end point", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARROW_X2_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ARROW_Y1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARROW_Y1 = { "Y1", 2,
 "Y coordinate of start point", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARROW_Y1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ARROW_Y2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARROW_Y2 = { "Y2", 2,
 "Y coordinate of end point", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARROW_Y2_type };
static KmParReal   _GRAPHICS_PRIMITIVES_ARROW_SIZE_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_ARROW_SIZE = { "SIZE", 4,
 "Arrow size", "0.4", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_ARROW_SIZE_type };
static KmParameter *_GRAPHICS_PRIMITIVES_ARROW_parameters[] = {
 &_GRAPHICS_PRIMITIVES_ARROW_X1, &_GRAPHICS_PRIMITIVES_ARROW_X2,
 &_GRAPHICS_PRIMITIVES_ARROW_Y1, &_GRAPHICS_PRIMITIVES_ARROW_Y2,
 &_GRAPHICS_PRIMITIVES_ARROW_SIZE };
static char *_GRAPHICS_PRIMITIVES_ARROW_guidance[] = { "Draw an arrow",
 "Use the current Normalisation transformation.",
 "The ARROW attributes can be changed with the command SET.",
 "ARROW and LINE attributes are the same.", "",
 "    (X1,Y1) ----> (X2,Y2) if SIZE>0.",
 "    (X1,Y1) <---> (X2,Y2) if SIZE<0.", "", "Example:",
 "    SET * ; OPT *          | Reset the defaults",
 "    NULL 0 10 0 7          | Draw a frame (cf HELP NULL)",
 "    ARROW 1 9 1 1 .2       | Draw a simple arrow (left to right)",
 "    ARROW 9 1 2 2 .4       | Draw a simple arrow (right to left)",
 "    ARROW 1 9 3 3 -.8      | Draw a double arrow",
 "    SET PLCI 2             | Arrow color is red",
 "    ARROW 1 9 4 4 -.8      | Draw a double arrow",
 "    SET LWID 8             | Arrow line width is 8",
 "    ARROW 1 9 5 5 -.8      | Draw a double arrow",
 "    SET LTYP 3             | Arrow line type is dotted",
 "    ARROW 1 9 6 6 -.8      | Draw a double arrow" };
static KmCommand _GRAPHICS_PRIMITIVES_ARROW = { &_GRAPHICS_PRIMITIVES_HELIX,
 "/GRAPHICS/PRIMITIVES/ARROW", "ARROW", 0, 2, 5, 4,
 _GRAPHICS_PRIMITIVES_ARROW_parameters, 0, 0, pagpri_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 20, _GRAPHICS_PRIMITIVES_ARROW_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GRAPHICS_PRIMITIVES_FBOX_X1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_FBOX_X1 = { "X1", 2,
 "X coord of first corner of ext box", (char*)0, (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_FBOX_X1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_FBOX_X2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_FBOX_X2 = { "X2", 2,
 "X coord of second corner of ext box", (char*)0, (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_FBOX_X2_type };
static KmParReal   _GRAPHICS_PRIMITIVES_FBOX_Y1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_FBOX_Y1 = { "Y1", 2,
 "Y coord of first corner of ext box", (char*)0, (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_FBOX_Y1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_FBOX_Y2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_FBOX_Y2 = { "Y2", 2,
 "Y coord of second corner of ext box", (char*)0, (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_FBOX_Y2_type };
static KmParReal   _GRAPHICS_PRIMITIVES_FBOX_X3_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_FBOX_X3 = { "X3", 2,
 "X coord of first corner of int box", (char*)0, (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_FBOX_X3_type };
static KmParReal   _GRAPHICS_PRIMITIVES_FBOX_X4_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_FBOX_X4 = { "X4", 2,
 "X coord of second corner of int box", (char*)0, (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_FBOX_X4_type };
static KmParReal   _GRAPHICS_PRIMITIVES_FBOX_Y3_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_FBOX_Y3 = { "Y3", 2,
 "Y coord of first corner of int box", (char*)0, (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_FBOX_Y3_type };
static KmParReal   _GRAPHICS_PRIMITIVES_FBOX_Y4_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_FBOX_Y4 = { "Y4", 2,
 "Y coord of second corner of int box", (char*)0, (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_FBOX_Y4_type };
static KmParameter *_GRAPHICS_PRIMITIVES_FBOX_parameters[] = {
 &_GRAPHICS_PRIMITIVES_FBOX_X1, &_GRAPHICS_PRIMITIVES_FBOX_X2,
 &_GRAPHICS_PRIMITIVES_FBOX_Y1, &_GRAPHICS_PRIMITIVES_FBOX_Y2,
 &_GRAPHICS_PRIMITIVES_FBOX_X3, &_GRAPHICS_PRIMITIVES_FBOX_X4,
 &_GRAPHICS_PRIMITIVES_FBOX_Y3, &_GRAPHICS_PRIMITIVES_FBOX_Y4 };
static char *_GRAPHICS_PRIMITIVES_FBOX_guidance[] = {
 "Draw and fill a frame (2 nested boxes)",
 "with the current fill area and line attributes.",
 "Use the current Normalisation transformation.",
 "The FBOX attributes can be changed with the command SET.", "", "Example:",
 "    SET * ; OPT *          | Reset the defaults",
 "    NULL 0 10 0 10         | Draw a frame (cf HELP NULL)",
 "    SET FAIS 3             | Fill area interior style hatched",
 "    SET FASI 3             | Changes the type of hatches",
 "    SET FACI 2             | Fill are color is red",
 "    SET PLCI 4             | Line color is blue",
 "    SET LWID 8             | The line width is 8",
 "    SET BORD 1             | The border is requested",
 "    FBOX 1 9 1 9 3 7 3 7   | Draw a frame box" };
static KmCommand _GRAPHICS_PRIMITIVES_FBOX = { &_GRAPHICS_PRIMITIVES_ARROW,
 "/GRAPHICS/PRIMITIVES/FBOX", "FBOX", 0, 2, 8, 8,
 _GRAPHICS_PRIMITIVES_FBOX_parameters, 0, 0, pagpri_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 15, _GRAPHICS_PRIMITIVES_FBOX_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GRAPHICS_PRIMITIVES_DBOX_X1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_DBOX_X1 = { "X1", 2,
 "X first coordinate", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_DBOX_X1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_DBOX_X2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_DBOX_X2 = { "X2", 2,
 "X second coordinate", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_DBOX_X2_type };
static KmParReal   _GRAPHICS_PRIMITIVES_DBOX_Y1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_DBOX_Y1 = { "Y1", 2,
 "Y first coordinate", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_DBOX_Y1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_DBOX_Y2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_DBOX_Y2 = { "Y2", 2,
 "Y second coordinate", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_DBOX_Y2_type };
static KmParameter *_GRAPHICS_PRIMITIVES_DBOX_parameters[] = {
 &_GRAPHICS_PRIMITIVES_DBOX_X1, &_GRAPHICS_PRIMITIVES_DBOX_X2,
 &_GRAPHICS_PRIMITIVES_DBOX_Y1, &_GRAPHICS_PRIMITIVES_DBOX_Y2 };
static char *_GRAPHICS_PRIMITIVES_DBOX_guidance[] = { "Draw and fill a box",
 "with the current fill area and line attributes.",
 "Use the current Normalisation transformation",
 "taking care of logarithmic scales.",
 "The BOX attributes can be changed with the command SET.", "", "Example:",
 "    SET * ; OPT *          | Reset the defaults",
 "    OPT LOGY ; OPT LOGX    | Use log scale",
 "    NULL 0 10 0 10         | Draw a frame (cf HELP NULL)",
 "    SET FAIS 0             | Fill area interior style hollow",
 "    DBOX 1 3 1 3           | Draw a box" };
static KmCommand _GRAPHICS_PRIMITIVES_DBOX = { &_GRAPHICS_PRIMITIVES_FBOX,
 "/GRAPHICS/PRIMITIVES/DBOX", "DBOX", 0, 2, 4, 4,
 _GRAPHICS_PRIMITIVES_DBOX_parameters, 0, 0, pagpri_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 12, _GRAPHICS_PRIMITIVES_DBOX_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GRAPHICS_PRIMITIVES_BOX_X1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_BOX_X1 = { "X1", 2,
 "X coordinate of first corner", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_BOX_X1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_BOX_X2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_BOX_X2 = { "X2", 2,
 "X coordinate of second corner", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_BOX_X2_type };
static KmParReal   _GRAPHICS_PRIMITIVES_BOX_Y1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_BOX_Y1 = { "Y1", 2,
 "Y coordinate of first corner", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_BOX_Y1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_BOX_Y2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_BOX_Y2 = { "Y2", 2,
 "Y coordinate of second corner", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_BOX_Y2_type };
static KmParameter *_GRAPHICS_PRIMITIVES_BOX_parameters[] = {
 &_GRAPHICS_PRIMITIVES_BOX_X1, &_GRAPHICS_PRIMITIVES_BOX_X2,
 &_GRAPHICS_PRIMITIVES_BOX_Y1, &_GRAPHICS_PRIMITIVES_BOX_Y2 };
static char *_GRAPHICS_PRIMITIVES_BOX_guidance[] = { "Draw and fill a box",
 "with the current fill area and line attributes.",
 "Use the current Normalisation transformation.",
 "The BOX attributes can be changed with the command SET.", "", "Example:",
 "    SET * ; OPT *          | Reset the defaults",
 "    NULL 0 10 0 10         | Draw a frame (cf HELP NULL)",
 "    SET FAIS 0             | Fill area interior style hollow",
 "    BOX 1 3 1 3            | Draw a box",
 "    SET FAIS 1             | Fill area interior style solid",
 "    BOX 1 3 3 5            | Draw a box",
 "    SET FAIS 3             | Fill area interior style hatched",
 "    SET FASI 245           | Changes the type of hatches",
 "    BOX 1 3 5 7            | Draw a box",
 "    SET FASI 3             | Changes the type of hatches",
 "    BOX 3 5 5 7            | Draw a box",
 "    SET BORD 1             | The border is requested",
 "    SET PLCI 2             | Line color is red",
 "    SET FASI 4             | Changes the type of hatches",
 "    BOX 5 7 5 7            | Draw a box" };
static KmCommand _GRAPHICS_PRIMITIVES_BOX = { &_GRAPHICS_PRIMITIVES_DBOX,
 "/GRAPHICS/PRIMITIVES/BOX", "BOX", 0, 2, 4, 4,
 _GRAPHICS_PRIMITIVES_BOX_parameters, 0, 0, pagpri_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 21, _GRAPHICS_PRIMITIVES_BOX_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GRAPHICS_PRIMITIVES_PMARKER_N_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_PMARKER_N = { "N", 1,
 "Number of points", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GRAPHICS_PRIMITIVES_PMARKER_N_type };
static KmParameter _GRAPHICS_PRIMITIVES_PMARKER_X = { "X", 1,
 "Vector name for X coordinates", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GRAPHICS_PRIMITIVES_PMARKER_Y = { "Y", 1,
 "Vector name for Y coordinates", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GRAPHICS_PRIMITIVES_PMARKER_parameters[] = {
 &_GRAPHICS_PRIMITIVES_PMARKER_N, &_GRAPHICS_PRIMITIVES_PMARKER_X,
 &_GRAPHICS_PRIMITIVES_PMARKER_Y };
static char *_GRAPHICS_PRIMITIVES_PMARKER_guidance[] = {
 "Draw polymarkers at the N points X,Y",
 "in the current Normalisation transformation.",
 "The PMARKER attributes can be changed with the command SET.", "",
 "Example:", "    SET * ; OPT *          | Reset the defaults",
 "    NUL -3.2 3.2 -1 1      | Draw a frame (cf HELP NULL)",
 " * Create vector X and Y (cf HELP SIGMA)",
 "    SIGMA X=ARRAY(100,-3.14#3.14)", "    SIGMA Y=SIN(X)*COS(X)",
 "    SET PMCI 6             | The marker color is magenta",
 "    SET MTYP 3             | The marker type is *",
 "    SET MSCF 2             | The marker size is 2",
 "    PMARKER 100 X Y        | Draw a 100 points polymarker" };
static KmCommand _GRAPHICS_PRIMITIVES_PMARKER = { &_GRAPHICS_PRIMITIVES_BOX,
 "/GRAPHICS/PRIMITIVES/PMARKER", "PMARKER", 0, 2, 3, 3,
 _GRAPHICS_PRIMITIVES_PMARKER_parameters, 0, 0, pagpri_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 14, _GRAPHICS_PRIMITIVES_PMARKER_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GRAPHICS_PRIMITIVES_FAREA_N_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_FAREA_N = { "N", 1,
 "Number of points", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GRAPHICS_PRIMITIVES_FAREA_N_type };
static KmParameter _GRAPHICS_PRIMITIVES_FAREA_X = { "X", 1,
 "Vector name for X coordinates", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GRAPHICS_PRIMITIVES_FAREA_Y = { "Y", 1,
 "Vector name for Y coordinates", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GRAPHICS_PRIMITIVES_FAREA_parameters[] = {
 &_GRAPHICS_PRIMITIVES_FAREA_N, &_GRAPHICS_PRIMITIVES_FAREA_X,
 &_GRAPHICS_PRIMITIVES_FAREA_Y };
static char *_GRAPHICS_PRIMITIVES_FAREA_guidance[] = {
 "Fill the area defined by the N points X,Y",
 "in the current Normalisation transformation.",
 "The FAREA attributes can be changed with the command SET.", "", "Example:",
 "    SET * ; OPT *          | Reset the defaults",
 "    NUL -1.1 1.1 -1.1 1.1  | Draw a frame (cf HELP NULL)",
 " * Create vector X and Y (cf HELP SIGMA)",
 "    SIGMA X=ARRAY(100,-3.14#3.14)", "    SIGMA Y=SIN(X)*COS(X)",
 "    SIGMA X=COS(X)",
 "    SET FACI 2             | The fill area color is red",
 "    SET FAIS 1             | The fill area interior style is solid",
 "    FAREA 100 X Y          | Draw a 100 points line",
 "    SET FACI 1             | The fill area color is black",
 "    SET FAIS 0             | The fill area interior style is hollow",
 "    FAREA 100 X Y          | Draw a 100 points line",
 "    SET FAIS 3             | The fill area interior style is hatched",
 "    SET FASI 245           | Defines the type of hatches",
 "    FAREA 100 X Y          | Draw a 100 points line" };
static KmCommand _GRAPHICS_PRIMITIVES_FAREA = { &_GRAPHICS_PRIMITIVES_PMARKER,
 "/GRAPHICS/PRIMITIVES/FAREA", "FAREA", 0, 2, 3, 3,
 _GRAPHICS_PRIMITIVES_FAREA_parameters, 0, 0, pagpri_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 20, _GRAPHICS_PRIMITIVES_FAREA_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GRAPHICS_PRIMITIVES_DLINE_X1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_DLINE_X1 = { "X1", 2,
 "X first coordinate", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_DLINE_X1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_DLINE_X2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_DLINE_X2 = { "X2", 2,
 "X second coordinate", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_DLINE_X2_type };
static KmParReal   _GRAPHICS_PRIMITIVES_DLINE_Y1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_DLINE_Y1 = { "Y1", 2,
 "Y first coordinate", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_DLINE_Y1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_DLINE_Y2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_DLINE_Y2 = { "Y2", 2,
 "Y second coordinate", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_DLINE_Y2_type };
static KmParameter *_GRAPHICS_PRIMITIVES_DLINE_parameters[] = {
 &_GRAPHICS_PRIMITIVES_DLINE_X1, &_GRAPHICS_PRIMITIVES_DLINE_X2,
 &_GRAPHICS_PRIMITIVES_DLINE_Y1, &_GRAPHICS_PRIMITIVES_DLINE_Y2 };
static char *_GRAPHICS_PRIMITIVES_DLINE_guidance[] = {
 "Draw a line connecting points (X1,Y1) and (X2,Y2)",
 "in the current Normalisation transformation taking care of",
 "logarithmic scales. The DLINE attributes can be",
 "changed with the command SET.", "", "Example:",
 "    SET * ; OPT *          | Reset the defaults",
 "    OPTION LOGY            | Log scale on the Y axis.",
 "    NUL 0 5 1 100          | Draw a frame (cf HELP NULL)",
 "    SET PLCI 2             | The line color is red",
 "    SET LWID 6             | The line width is 6",
 "    SET LTYP 1             | The line type is solid",
 "    DLINE 0 5 1 10         | Draw a line" };
static KmCommand _GRAPHICS_PRIMITIVES_DLINE = { &_GRAPHICS_PRIMITIVES_FAREA,
 "/GRAPHICS/PRIMITIVES/DLINE", "DLINE", 0, 2, 4, 4,
 _GRAPHICS_PRIMITIVES_DLINE_parameters, 0, 0, pagpri_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 13, _GRAPHICS_PRIMITIVES_DLINE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GRAPHICS_PRIMITIVES_LINE_X1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_LINE_X1 = { "X1", 2,
 "X first coordinate", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_LINE_X1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_LINE_Y1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_LINE_Y1 = { "Y1", 2,
 "Y first coordinate", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_LINE_Y1_type };
static KmParReal   _GRAPHICS_PRIMITIVES_LINE_X2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_LINE_X2 = { "X2", 2,
 "X second coordinate", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_LINE_X2_type };
static KmParReal   _GRAPHICS_PRIMITIVES_LINE_Y2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_LINE_Y2 = { "Y2", 2,
 "Y second coordinate", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_PRIMITIVES_LINE_Y2_type };
static KmParameter *_GRAPHICS_PRIMITIVES_LINE_parameters[] = {
 &_GRAPHICS_PRIMITIVES_LINE_X1, &_GRAPHICS_PRIMITIVES_LINE_Y1,
 &_GRAPHICS_PRIMITIVES_LINE_X2, &_GRAPHICS_PRIMITIVES_LINE_Y2 };
static char *_GRAPHICS_PRIMITIVES_LINE_guidance[] = {
 "Draw a line connecting points (X1,Y1) and (X2,Y2)",
 "in the current Normalisation transformation. This command is kept",
 "for backward compatibility. It has a reverse calling sequence compare",
 "to BOX or ARROW and it doesn't take LOG scales into account. It is",
 "recommended to use DLINE instead. The LINE attributes can be",
 "changed with the command SET.", "", "Example:",
 "    SET * ; OPT *          | Reset the defaults",
 "    NUL 0 5 0 5            | Draw a frame (cf HELP NULL)",
 "    SET PLCI 2             | The line color is red",
 "    SET LWID 6             | The line width is 6",
 "    SET LTYP 3             | The line type is dotted",
 "    LINE 0 0 5 5           | Draw a line" };
static KmCommand _GRAPHICS_PRIMITIVES_LINE = { &_GRAPHICS_PRIMITIVES_DLINE,
 "/GRAPHICS/PRIMITIVES/LINE", "LINE", 0, 2, 4, 4,
 _GRAPHICS_PRIMITIVES_LINE_parameters, 0, 0, pagpri_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 14, _GRAPHICS_PRIMITIVES_LINE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GRAPHICS_PRIMITIVES_PLINE_N_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_PRIMITIVES_PLINE_N = { "N", 1,
 "Number of points", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GRAPHICS_PRIMITIVES_PLINE_N_type };
static KmParameter _GRAPHICS_PRIMITIVES_PLINE_X = { "X", 1,
 "Vector name for X coordinates", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GRAPHICS_PRIMITIVES_PLINE_Y = { "Y", 1,
 "Vector name for Y coordinates", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_GRAPHICS_PRIMITIVES_PLINE_parameters[] = {
 &_GRAPHICS_PRIMITIVES_PLINE_N, &_GRAPHICS_PRIMITIVES_PLINE_X,
 &_GRAPHICS_PRIMITIVES_PLINE_Y };
static char *_GRAPHICS_PRIMITIVES_PLINE_guidance[] = {
 "Draw a polyline of N points X,Y",
 "in the current Normalisation transformation.",
 "The PLINE attributes can be changed with the command SET.", "", "Example:",
 "    SET * ; OPT *          | Reset the defaults",
 "    NUL -1 1 0 1           | Draw a frame (cf HELP NULL)",
 " * Create vector X and Y (cf HELP SIGMA)", "    SIGMA X=ARRAY(100,-1#1)",
 "    SIGMA Y=X*X", "    SET PLCI 4             | The line color is blue",
 "    SET LWID 6             | The line width is 6",
 "    SET LTYP 2             | The line type is dashed",
 "    PLINE 100 X Y          | Draw a 100 points line" };
static KmCommand _GRAPHICS_PRIMITIVES_PLINE = { &_GRAPHICS_PRIMITIVES_LINE,
 "/GRAPHICS/PRIMITIVES/PLINE", "PLINE", 0, 2, 3, 3,
 _GRAPHICS_PRIMITIVES_PLINE_parameters, 0, 0, pagpri_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 14, _GRAPHICS_PRIMITIVES_PLINE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GRAPHICS_ATTRIBUTES_PALETTE_PALNB_type = { "0", "9", "0",
 "9", 0 };
static KmParameter _GRAPHICS_ATTRIBUTES_PALETTE_PALNB = { "PALNB", 5,
 "Palette number", "0", (char*)0, 2, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_GRAPHICS_ATTRIBUTES_PALETTE_PALNB_type };
static KmParInt    _GRAPHICS_ATTRIBUTES_PALETTE_NEL_type = { "0", "50", "0",
 "50", 0 };
static KmParameter _GRAPHICS_ATTRIBUTES_PALETTE_NEL = { "NEL", 3,
 "Number of elements in the palette", "0", (char*)0, 3, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_GRAPHICS_ATTRIBUTES_PALETTE_NEL_type };
static KmParInt    _GRAPHICS_ATTRIBUTES_PALETTE_LIST_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_ATTRIBUTES_PALETTE_LIST = { "LIST", 4,
 "List of the palette elements", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GRAPHICS_ATTRIBUTES_PALETTE_LIST_type };
static KmParameter *_GRAPHICS_ATTRIBUTES_PALETTE_parameters[] = {
 &_GRAPHICS_ATTRIBUTES_PALETTE_PALNB, &_GRAPHICS_ATTRIBUTES_PALETTE_NEL,
 &_GRAPHICS_ATTRIBUTES_PALETTE_LIST };
static char *_GRAPHICS_ATTRIBUTES_PALETTE_guidance[] = {
 "Define a palette of attributes.",
 "The palette number is used in the command SET. The command",
 "SET HCOL 0.1 defines the palette number 1 as colour indices",
 "used by the command LEGO in case of stacked lego plots and",
 "plotting of SURFACE with options 1 or 2, LEGO with option 2",
 "and CONTOUR with option 3.", "",
 "By default the palettes are initialized with 6 elements:", "2,3,4,5,6,7.",
 "", "If the number of elements (NEL) is equal to 0 (default), the",
 "palette is filled automatically according to the number of",
 "colours defined with the command SET NCOL:", "",
 " a) If NCOL is smaller or equal to 8, the palette is filled with a",
 "    subset of the 8 basic colours.", "    Examples:",
 "    PAW > SET NCOL 8        | Define the number of colours",
 "    PAW > PALETTE 1         | The palette 1 is filled with",
 "                            | 8 elements: 0,5,7,3,6,2,4,1",
 "    PAW > SET NCOL 4        | Define the number of colours",
 "    PAW > PALETTE 1         | The palette 1 is filled with",
 "                            | 4 elements: 0,5,7,3", "",
 " b) If NCOL is greater than 8, the palette is filled",
 "    with colours varying continuously from blue to red. This is",
 "    called a 'geographical palette'.", "    Examples:",
 "    PAW > SET NCOL 16     | Define the number of colours",
 "    PAW > PALETTE 1         | Fill palette 1 with 8 elements",
 "                            | (8,9,10,11,12,13,14,15) varying",
 "                            | continuously from blue to red",
 "    Note that after the command SET NCOL, the color indices from",
 "    8 to NCOL are set with gray levels. The command PALETTE 1",
 "    reset the same indices with a 'geographical palette' varying",
 "    continuously from blue to red." };
static KmCommand _GRAPHICS_ATTRIBUTES_PALETTE = {  (KmCommand*)0,
 "/GRAPHICS/ATTRIBUTES/PALETTE", "PALETTE", 0, 2, 3, 1,
 _GRAPHICS_ATTRIBUTES_PALETTE_parameters, 0, 0, pagksa_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 36, _GRAPHICS_ATTRIBUTES_PALETTE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GRAPHICS_ATTRIBUTES_COLOR_TABLE_ICOL_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_ATTRIBUTES_COLOR_TABLE_ICOL = { "ICOL", 4,
 "Color Index", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_GRAPHICS_ATTRIBUTES_COLOR_TABLE_ICOL_type };
static KmParReal   _GRAPHICS_ATTRIBUTES_COLOR_TABLE_RED_type = { "0.", "1.",
 "0.", "1.", 0 };
static KmParameter _GRAPHICS_ATTRIBUTES_COLOR_TABLE_RED = { "RED", 3,
 "Weight of red", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_ATTRIBUTES_COLOR_TABLE_RED_type };
static KmParReal   _GRAPHICS_ATTRIBUTES_COLOR_TABLE_GREEN_type = { "0.", "1.",
 "0.", "1.", 0 };
static KmParameter _GRAPHICS_ATTRIBUTES_COLOR_TABLE_GREEN = { "GREEN", 5,
 "Weight of green", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_ATTRIBUTES_COLOR_TABLE_GREEN_type };
static KmParReal   _GRAPHICS_ATTRIBUTES_COLOR_TABLE_BLUE_type = { "0.", "1.",
 "0.", "1.", 0 };
static KmParameter _GRAPHICS_ATTRIBUTES_COLOR_TABLE_BLUE = { "BLUE", 4,
 "Weight of blue", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_ATTRIBUTES_COLOR_TABLE_BLUE_type };
static KmParameter *_GRAPHICS_ATTRIBUTES_COLOR_TABLE_parameters[] = {
 &_GRAPHICS_ATTRIBUTES_COLOR_TABLE_ICOL,
 &_GRAPHICS_ATTRIBUTES_COLOR_TABLE_RED,
 &_GRAPHICS_ATTRIBUTES_COLOR_TABLE_GREEN,
 &_GRAPHICS_ATTRIBUTES_COLOR_TABLE_BLUE };
static char *_GRAPHICS_ATTRIBUTES_COLOR_TABLE_guidance[] = {
 "Define the color ICOL." };
static KmCommand _GRAPHICS_ATTRIBUTES_COLOR_TABLE = {
 &_GRAPHICS_ATTRIBUTES_PALETTE, "/GRAPHICS/ATTRIBUTES/COLOR_TABLE",
 "COLOR_TABLE", 0, 2, 4, 1, _GRAPHICS_ATTRIBUTES_COLOR_TABLE_parameters, 0, 0,
 pagksa_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _GRAPHICS_ATTRIBUTES_COLOR_TABLE_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParReal   _GRAPHICS_HPLOT_NULL_XMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_HPLOT_NULL_XMIN = { "XMIN", 4, "Low range in X",
 "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GRAPHICS_HPLOT_NULL_XMIN_type };
static KmParReal   _GRAPHICS_HPLOT_NULL_XMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_HPLOT_NULL_XMAX = { "XMAX", 4, "High range in X",
 "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GRAPHICS_HPLOT_NULL_XMAX_type };
static KmParReal   _GRAPHICS_HPLOT_NULL_YMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_HPLOT_NULL_YMIN = { "YMIN", 4, "Low range in Y",
 "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GRAPHICS_HPLOT_NULL_YMIN_type };
static KmParReal   _GRAPHICS_HPLOT_NULL_YMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_HPLOT_NULL_YMAX = { "YMAX", 4, "High range in Y",
 "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GRAPHICS_HPLOT_NULL_YMAX_type };
static char *_GRAPHICS_HPLOT_NULL_CHOPT_range[] = { "", "S", "A", "B" };
static char *_GRAPHICS_HPLOT_NULL_CHOPT_text[] = { "Draw a frame box only.",
 "Redefine the scale for the current zone.",
 "Axis labels and tick marks are not drawn.", "The box is not drawn." };
static KmParOption _GRAPHICS_HPLOT_NULL_CHOPT_type = {
 _GRAPHICS_HPLOT_NULL_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GRAPHICS_HPLOT_NULL_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 4, _GRAPHICS_HPLOT_NULL_CHOPT_range, 4,
 _GRAPHICS_HPLOT_NULL_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GRAPHICS_HPLOT_NULL_CHOPT_type };
static KmParameter *_GRAPHICS_HPLOT_NULL_parameters[] = {
 &_GRAPHICS_HPLOT_NULL_XMIN, &_GRAPHICS_HPLOT_NULL_XMAX,
 &_GRAPHICS_HPLOT_NULL_YMIN, &_GRAPHICS_HPLOT_NULL_YMAX,
 &_GRAPHICS_HPLOT_NULL_CHOPT };
static char *_GRAPHICS_HPLOT_NULL_guidance[] = { "Draw a frame box.",
 "If XMIN, XMAX, etc. are given, draw a frame box",
 "with the window coordinates set to XMIN, XMAX, YMIN, YMAX. Axis",
 "labels and tick marks are drawn by default." };
static KmCommand _GRAPHICS_HPLOT_NULL = {  (KmCommand*)0,
 "/GRAPHICS/HPLOT/NULL", "NULL", 0, 2, 5, 0, _GRAPHICS_HPLOT_NULL_parameters,
 0, 0, paghpl_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 4,
 _GRAPHICS_HPLOT_NULL_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_GRAPHICS_HPLOT_GRID_guidance[] = { "Draw a grid in cm." };
static KmCommand _GRAPHICS_HPLOT_GRID = { &_GRAPHICS_HPLOT_NULL,
 "/GRAPHICS/HPLOT/GRID", "GRID", 0, 2, 0, 0, (KmParameter**)0, 0, 0, paghpl_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1, _GRAPHICS_HPLOT_GRID_guidance,
 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GRAPHICS_HPLOT_ATITLE_XTIT = { "XTIT", 4, "X Axis title",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter _GRAPHICS_HPLOT_ATITLE_YTIT = { "YTIT", 4, "Y Axis title",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter _GRAPHICS_HPLOT_ATITLE_ZTIT = { "ZTIT", 4, "Z Axis title",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _GRAPHICS_HPLOT_ATITLE_IALGN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_HPLOT_ATITLE_IALGN = { "IALGN", 5,
 "Axis titles alignment", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GRAPHICS_HPLOT_ATITLE_IALGN_type };
static char *_GRAPHICS_HPLOT_ATITLE_CHOPT_range[] = { "", "R", "T" };
static char *_GRAPHICS_HPLOT_ATITLE_CHOPT_text[] = {
 "Axis title are drawn on the left and on the bottom of the plot.",
 "Y axis title is drawn on the right of the plot.",
 "X axis title is drawn on the top of the plot." };
static KmParOption _GRAPHICS_HPLOT_ATITLE_CHOPT_type = {
 _GRAPHICS_HPLOT_ATITLE_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GRAPHICS_HPLOT_ATITLE_CHOPT = { "CHOPT", 5, "Options",
 " ", (char*)0, 8, 3, _GRAPHICS_HPLOT_ATITLE_CHOPT_range, 3,
 _GRAPHICS_HPLOT_ATITLE_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GRAPHICS_HPLOT_ATITLE_CHOPT_type };
static KmParameter *_GRAPHICS_HPLOT_ATITLE_parameters[] = {
 &_GRAPHICS_HPLOT_ATITLE_XTIT, &_GRAPHICS_HPLOT_ATITLE_YTIT,
 &_GRAPHICS_HPLOT_ATITLE_ZTIT, &_GRAPHICS_HPLOT_ATITLE_IALGN,
 &_GRAPHICS_HPLOT_ATITLE_CHOPT };
static char *_GRAPHICS_HPLOT_ATITLE_guidance[] = {
 "Draw axis titles on the axes of the present plot zone.",
 "The parameter IALGN defined where the title is aligned i.e:",
 "on the beginning, the middle or at the end of the axis. The",
 "alignment parameter has 3 digits (one for each axis): xyz",
 "where x, y and z may have independently the following values:",
 " 1: Begining of the axis", " 2: Middle of the axis",
 " 3: End of the axis (0 is equivalent to 3)", "Example:", " NUL 0 10 0 10",
 " NUL 0 100 0 100 S",
 " ATITLE 'End of axis' 'Middle of axis on the right' ! 320 R",
 " ATITLE 'Beginning of axis' 'End of axis' ! 130",
 " ATITLE 'Middle of axis on the top' 'Beginning of axis' ! 210 T" };
static KmCommand _GRAPHICS_HPLOT_ATITLE = { &_GRAPHICS_HPLOT_GRID,
 "/GRAPHICS/HPLOT/ATITLE", "ATITLE", 0, 2, 5, 0,
 _GRAPHICS_HPLOT_ATITLE_parameters, 0, 0, paghpl_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 14, _GRAPHICS_HPLOT_ATITLE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_GRAPHICS_HPLOT_TICKS_CHOPT_range[] = { "", "X", "Y", "A", "B",
 "L", "R" };
static char *_GRAPHICS_HPLOT_TICKS_CHOPT_text[] = {
 "Tick marks are drawn on the edges of the picture",
 "Cross-wire drawn perpendicular to the X-axis",
 "Cross-wire drawn perpendicular to the Y-axis",
 "Value drawn Above cross-wire", "Value drawn Below cross-wire",
 "Value drawn Left of cross-wire", "Value drawn Right of cross-wire" };
static KmParOption _GRAPHICS_HPLOT_TICKS_CHOPT_type = {
 _GRAPHICS_HPLOT_TICKS_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GRAPHICS_HPLOT_TICKS_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 7, _GRAPHICS_HPLOT_TICKS_CHOPT_range, 7,
 _GRAPHICS_HPLOT_TICKS_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GRAPHICS_HPLOT_TICKS_CHOPT_type };
static KmParReal   _GRAPHICS_HPLOT_TICKS_XVAL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_HPLOT_TICKS_XVAL = { "XVAL", 4, "X position",
 "1.E30", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GRAPHICS_HPLOT_TICKS_XVAL_type };
static KmParReal   _GRAPHICS_HPLOT_TICKS_YVAL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_HPLOT_TICKS_YVAL = { "YVAL", 4, "Y position",
 "1.E30", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GRAPHICS_HPLOT_TICKS_YVAL_type };
static KmParameter *_GRAPHICS_HPLOT_TICKS_parameters[] = {
 &_GRAPHICS_HPLOT_TICKS_CHOPT, &_GRAPHICS_HPLOT_TICKS_XVAL,
 &_GRAPHICS_HPLOT_TICKS_YVAL };
static char *_GRAPHICS_HPLOT_TICKS_guidance[] = {
 "Draw 'cross-wires' on a picture,", "optionally with tick marks and values.",
 "Cross-wires are lines perpendicular to the X and/or Y axis.",
 " XVAL intersection on the X-axis", " YVAL intersection on the Y-axis",
 "The values of XVAL are always histogram coordinates.", "",
 "The tick marks will be drawn on both side of the cross",
 "wire, unless the cross-wires are requested on the boundary",
 "of the box surrounding the histogram (i.e. at the extreme",
 "limits of the drawn histogram). In this case tick marks will",
 "only be drawn inside the box.", "",
 "The options 'A' and 'B' (for Above and Below)",
 "refer only to the cross-wire perpendicular to the Y axis.",
 "In each case only one cross-wire will be drawn.", "",
 "Similarly 'L' and 'R' (Left and Right) refer only",
 "to the cross-wires perpendicular to the X-axis.", "",
 "It is possible to redefine the length of tick marks on the X or Y",
 "axis with SET XTIC or SET YTIC.", "",
 "The position of the axis values may be changed",
 "with SET XVAL or SET YVAL.", "",
 "The Number of divisions can be cahnged with SET NDVX and SET NDVY.", "",
 "This command combines with the command NUL is a easy way to redraw",
 "axis on the current plot.", "", "Example",
 "    SET * ; OPT *                     | Reset the defaults",
 "    Nul 0 1 0 1                       | draw an empty frame with axis",
 "    Set ndvy 5                        | Change number of Y divisions",
 "    Nul 0 10 0 10 ABS                 | Redefine the scales",
 "    Tic XR 5 !                        | Axis in the new coordinates" };
static KmCommand _GRAPHICS_HPLOT_TICKS = { &_GRAPHICS_HPLOT_ATITLE,
 "/GRAPHICS/HPLOT/TICKS", "TICKS", 0, 2, 3, 0,
 _GRAPHICS_HPLOT_TICKS_parameters, 0, 0, paghpl_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 37, _GRAPHICS_HPLOT_TICKS_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParReal   _GRAPHICS_HPLOT_KEY_X_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_HPLOT_KEY_X = { "X", 1,
 "X coordinate of comment", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_HPLOT_KEY_X_type };
static KmParReal   _GRAPHICS_HPLOT_KEY_Y_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_HPLOT_KEY_Y = { "Y", 1,
 "Y coordinate of comment", (char*)0, (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_HPLOT_KEY_Y_type };
static KmParInt    _GRAPHICS_HPLOT_KEY_IATT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_HPLOT_KEY_IATT = { "IATT", 4, "Attribute value",
 "24", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GRAPHICS_HPLOT_KEY_IATT_type };
static KmParameter _GRAPHICS_HPLOT_KEY_TEXT = { "TEXT", 4, "Legend", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParReal   _GRAPHICS_HPLOT_KEY_DX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_HPLOT_KEY_DX = { "DX", 2, "Box width", "1.",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GRAPHICS_HPLOT_KEY_DX_type };
static char *_GRAPHICS_HPLOT_KEY_CHOPT_range[] = { "", "F", "H", "L", "W" };
static char *_GRAPHICS_HPLOT_KEY_CHOPT_text[] = { "IATT is a marker type",
 "IATT is a fill area color index", "IATT is a hatches type",
 "IATT is a line type", "IATT is a line width" };
static KmParOption _GRAPHICS_HPLOT_KEY_CHOPT_type = {
 _GRAPHICS_HPLOT_KEY_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GRAPHICS_HPLOT_KEY_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 5, _GRAPHICS_HPLOT_KEY_CHOPT_range, 5,
 _GRAPHICS_HPLOT_KEY_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GRAPHICS_HPLOT_KEY_CHOPT_type };
static KmParameter *_GRAPHICS_HPLOT_KEY_parameters[] = {
 &_GRAPHICS_HPLOT_KEY_X, &_GRAPHICS_HPLOT_KEY_Y, &_GRAPHICS_HPLOT_KEY_IATT,
 &_GRAPHICS_HPLOT_KEY_TEXT, &_GRAPHICS_HPLOT_KEY_DX,
 &_GRAPHICS_HPLOT_KEY_CHOPT };
static char *_GRAPHICS_HPLOT_KEY_guidance[] = {
 "Draw one legend and its explanation at a point x,y",
 "in the current normalisation transformation.", "", "The legend can be:",
 "     - A marker type (default)",
 "     - A filled box (CHOPT=F), in this case IATT is a color",
 "       and DX is the width of the box.",
 "     - A hatched  box (CHOPT=H), in this case IATT is a hatches type",
 "       and DX is the width of the box.",
 "     - A line (CHOPT=L), in this case IATT is a line type",
 "       and DX is the length of the line.",
 "     - A line (CHOPT=W), in this case IATT is a line width",
 "       and DX is the length of the line.", "", "Example",
 "    SET * ; OPT *                     | Reset the defaults",
 "    NUL 0 10 0 8 A                    | Draw a frame",
 "    KEY 5 2 ! 'Key 1'                 | Key with marker",
 "    KEY 5 3 2 'Key 2' ! F             | Key with filled box",
 "    SET FACI 3                        | Change color for next key",
 "    key 5 4 2 'Key 3' 2 H             | Key with hatches. DX is modified",
 "    key 5 5 2 'Key 4' ! L             | Key with line type",
 "    SET PLCI 4                        | Change color for next key",
 "    SET CSIZ .4                       | Change key size",
 "    KEY 5 6 8 'Key 5' 1.5 W           | Key with line width" };
static KmCommand _GRAPHICS_HPLOT_KEY = { &_GRAPHICS_HPLOT_TICKS,
 "/GRAPHICS/HPLOT/KEY", "KEY", 0, 2, 6, 2, _GRAPHICS_HPLOT_KEY_parameters, 0,
 0, paghpl_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 25,
 _GRAPHICS_HPLOT_KEY_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _GRAPHICS_HPLOT_AERRORS_X = { "X", 1,
 "Vector of X coordinates", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GRAPHICS_HPLOT_AERRORS_Y = { "Y", 1,
 "Vector of Y coordinates", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GRAPHICS_HPLOT_AERRORS_EXL = { "EXL", 3,
 "Vector of X error bars (Low)", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GRAPHICS_HPLOT_AERRORS_EXU = { "EXU", 3,
 "Vector of X error bars (Up)", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GRAPHICS_HPLOT_AERRORS_EYL = { "EYL", 3,
 "Vector of Y error bars (Low)", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GRAPHICS_HPLOT_AERRORS_EYU = { "EYU", 3,
 "Vector of Y error bars (Up)", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GRAPHICS_HPLOT_AERRORS_N_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_HPLOT_AERRORS_N = { "N", 1, "Number of points",
 "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GRAPHICS_HPLOT_AERRORS_N_type };
static KmParInt    _GRAPHICS_HPLOT_AERRORS_ISYMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_HPLOT_AERRORS_ISYMB = { "ISYMB", 5,
 "Symbol number", "24", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_GRAPHICS_HPLOT_AERRORS_ISYMB_type };
static KmParReal   _GRAPHICS_HPLOT_AERRORS_SSIZE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_HPLOT_AERRORS_SSIZE = { "SSIZE", 5,
 "Symbol size", "0.28", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_HPLOT_AERRORS_SSIZE_type };
static char *_GRAPHICS_HPLOT_AERRORS_CHOPT_range[] = { "", "C", "W", "1", "2",
 "3", "4", "0" };
static char *_GRAPHICS_HPLOT_AERRORS_CHOPT_text[] = {
 "Coordinates are expressed in histogram coordinates (of the last drawn\
 histogram). Error bars are drawn.",
 "Coordinates are expressed in centimeters.",
 "A new window is defined and axis are drawn.",
 "Draw small lines at the end of the error bars.", "Draw error rectangles.",
 "Draw a filled area through the end points of the vertical error bars.",
 "Draw a smoothed filled area through the end points of the vertical error\
 bars.", "Turn off the symbols clipping." };
static KmParOption _GRAPHICS_HPLOT_AERRORS_CHOPT_type = {
 _GRAPHICS_HPLOT_AERRORS_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GRAPHICS_HPLOT_AERRORS_CHOPT = { "CHOPT", 5, "Options",
 " ", (char*)0, 8, 8, _GRAPHICS_HPLOT_AERRORS_CHOPT_range, 8,
 _GRAPHICS_HPLOT_AERRORS_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GRAPHICS_HPLOT_AERRORS_CHOPT_type };
static KmParameter *_GRAPHICS_HPLOT_AERRORS_parameters[] = {
 &_GRAPHICS_HPLOT_AERRORS_X, &_GRAPHICS_HPLOT_AERRORS_Y,
 &_GRAPHICS_HPLOT_AERRORS_EXL, &_GRAPHICS_HPLOT_AERRORS_EXU,
 &_GRAPHICS_HPLOT_AERRORS_EYL, &_GRAPHICS_HPLOT_AERRORS_EYU,
 &_GRAPHICS_HPLOT_AERRORS_N, &_GRAPHICS_HPLOT_AERRORS_ISYMB,
 &_GRAPHICS_HPLOT_AERRORS_SSIZE, &_GRAPHICS_HPLOT_AERRORS_CHOPT };
static char *_GRAPHICS_HPLOT_AERRORS_guidance[] = {
 "Draw (according to the CHOPT value) a series of points using",
 "a symbol and asymmetric error bars in horizontal and vertical",
 "direction in the current normalisation transformation.", "",
 "By default, the symbols are not drawn if they are on the",
 "edges of the plot: the option '0' allows to turn off this",
 "symbols clipping.", "",
 "With Option 1, the size of the tick marks at the end of the error",
 "bars is equal to the marker size and can be changed with SET KSIZ.", "",
 "If ISYMB = 0 or SSIZE = 0. no symbol is drawn.", "",
 "Note that the options can be cumulated." };
static KmCommand _GRAPHICS_HPLOT_AERRORS = { &_GRAPHICS_HPLOT_KEY,
 "/GRAPHICS/HPLOT/AERRORS", "AERRORS", 0, 2, 10, 7,
 _GRAPHICS_HPLOT_AERRORS_parameters, 0, 0, paghpl_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 14, _GRAPHICS_HPLOT_AERRORS_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GRAPHICS_HPLOT_ERRORS_X = { "X", 1,
 "Vector of X coordinates", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GRAPHICS_HPLOT_ERRORS_Y = { "Y", 1,
 "Vector of Y coordinates", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GRAPHICS_HPLOT_ERRORS_EX = { "EX", 2,
 "Vector of X error bars", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GRAPHICS_HPLOT_ERRORS_EY = { "EY", 2,
 "Vector of Y error bars", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GRAPHICS_HPLOT_ERRORS_N_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_HPLOT_ERRORS_N = { "N", 1, "Number of points",
 "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GRAPHICS_HPLOT_ERRORS_N_type };
static KmParInt    _GRAPHICS_HPLOT_ERRORS_ISYMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_HPLOT_ERRORS_ISYMB = { "ISYMB", 5,
 "Symbol number", "24", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_GRAPHICS_HPLOT_ERRORS_ISYMB_type };
static KmParReal   _GRAPHICS_HPLOT_ERRORS_SSIZE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_HPLOT_ERRORS_SSIZE = { "SSIZE", 5, "Symbol size",
 "0.28", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GRAPHICS_HPLOT_ERRORS_SSIZE_type };
static char *_GRAPHICS_HPLOT_ERRORS_CHOPT_range[] = { "", "C", "W", "1", "2",
 "3", "4", "0" };
static char *_GRAPHICS_HPLOT_ERRORS_CHOPT_text[] = {
 "Coordinates are expressed in histogram coordinates (of the last drawn\
 histogram). Error bars are drawn.",
 "Coordinates are expressed in centimeters.",
 "A new window is defined and axis are drawn.",
 "Draw small lines at the end of the error bars.", "Draw error rectangles.",
 "Draw a filled area through the end points of the vertical error bars.",
 "Draw a smoothed filled area through the end points of the vertical error\
 bars.", "Turn off the symbols clipping." };
static KmParOption _GRAPHICS_HPLOT_ERRORS_CHOPT_type = {
 _GRAPHICS_HPLOT_ERRORS_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GRAPHICS_HPLOT_ERRORS_CHOPT = { "CHOPT", 5, "Options",
 " ", (char*)0, 8, 8, _GRAPHICS_HPLOT_ERRORS_CHOPT_range, 8,
 _GRAPHICS_HPLOT_ERRORS_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GRAPHICS_HPLOT_ERRORS_CHOPT_type };
static KmParameter *_GRAPHICS_HPLOT_ERRORS_parameters[] = {
 &_GRAPHICS_HPLOT_ERRORS_X, &_GRAPHICS_HPLOT_ERRORS_Y,
 &_GRAPHICS_HPLOT_ERRORS_EX, &_GRAPHICS_HPLOT_ERRORS_EY,
 &_GRAPHICS_HPLOT_ERRORS_N, &_GRAPHICS_HPLOT_ERRORS_ISYMB,
 &_GRAPHICS_HPLOT_ERRORS_SSIZE, &_GRAPHICS_HPLOT_ERRORS_CHOPT };
static char *_GRAPHICS_HPLOT_ERRORS_guidance[] = {
 "Draw (according to the CHOPT value) a series of points using",
 "a symbol and error bars in horizontal and vertical direction",
 "in the current normalisation transformation.", "",
 "By default, the symbols are not drawn if they are on the",
 "edges of the plot: the option '0' allows to turn off this",
 "symbols clipping.", "",
 "With Option 1, the size of the tick marks at the end of the error",
 "bars is equal to the marker size and can be changed with SET KSIZ.", "",
 "If ISYMB = 0 or SSIZE = 0. no symbol is drawn.", "",
 "Note that the options can be cumulated." };
static KmCommand _GRAPHICS_HPLOT_ERRORS = { &_GRAPHICS_HPLOT_AERRORS,
 "/GRAPHICS/HPLOT/ERRORS", "ERRORS", 0, 2, 8, 5,
 _GRAPHICS_HPLOT_ERRORS_parameters, 0, 0, paghpl_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 14, _GRAPHICS_HPLOT_ERRORS_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GRAPHICS_HPLOT_SYMBOLS_X = { "X", 1,
 "Vector of X coordinates", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _GRAPHICS_HPLOT_SYMBOLS_Y = { "Y", 1,
 "Vector of Y coordinates", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _GRAPHICS_HPLOT_SYMBOLS_N_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_HPLOT_SYMBOLS_N = { "N", 1, "Number of points",
 "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GRAPHICS_HPLOT_SYMBOLS_N_type };
static KmParInt    _GRAPHICS_HPLOT_SYMBOLS_ISYMB_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_HPLOT_SYMBOLS_ISYMB = { "ISYMB", 5,
 "Symbol number", "24", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_GRAPHICS_HPLOT_SYMBOLS_ISYMB_type };
static KmParReal   _GRAPHICS_HPLOT_SYMBOLS_SSIZE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_HPLOT_SYMBOLS_SSIZE = { "SSIZE", 5,
 "Symbol size", "0.28", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_GRAPHICS_HPLOT_SYMBOLS_SSIZE_type };
static KmParameter *_GRAPHICS_HPLOT_SYMBOLS_parameters[] = {
 &_GRAPHICS_HPLOT_SYMBOLS_X, &_GRAPHICS_HPLOT_SYMBOLS_Y,
 &_GRAPHICS_HPLOT_SYMBOLS_N, &_GRAPHICS_HPLOT_SYMBOLS_ISYMB,
 &_GRAPHICS_HPLOT_SYMBOLS_SSIZE };
static char *_GRAPHICS_HPLOT_SYMBOLS_guidance[] = {
 "Draw the same symbol at several points x,y",
 "in the current normalisation transformation." };
static KmCommand _GRAPHICS_HPLOT_SYMBOLS = { &_GRAPHICS_HPLOT_ERRORS,
 "/GRAPHICS/HPLOT/SYMBOLS", "SYMBOLS", 0, 2, 5, 3,
 _GRAPHICS_HPLOT_SYMBOLS_parameters, 0, 0, paghpl_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _GRAPHICS_HPLOT_SYMBOLS_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_GRAPHICS_HPLOT_guidance[] = {
 "Draw various HPLOT objects (symbols, errors, key, etc.)." };
static KmMenu _GRAPHICS_HPLOT = {  (KmMenu*)0,  (KmMenu*)0, "/GRAPHICS/HPLOT",
 "HPLOT", 2, &_GRAPHICS_HPLOT_SYMBOLS, 1, _GRAPHICS_HPLOT_guidance, 0,
 (char**)0, 0, (char**)0 };

static char *_GRAPHICS_ATTRIBUTES_guidance[] = { "Change HIGZ attributes." };
static KmMenu _GRAPHICS_ATTRIBUTES = { &_GRAPHICS_HPLOT,  (KmMenu*)0,
 "/GRAPHICS/ATTRIBUTES", "ATTRIBUTES", 2, &_GRAPHICS_ATTRIBUTES_COLOR_TABLE,
 1, _GRAPHICS_ATTRIBUTES_guidance, 0, (char**)0, 0, (char**)0 };

static char *_GRAPHICS_PRIMITIVES_guidance[] = {
 "Call HIGZ drawing primitives" };
static KmMenu _GRAPHICS_PRIMITIVES = { &_GRAPHICS_ATTRIBUTES,  (KmMenu*)0,
 "/GRAPHICS/PRIMITIVES", "PRIMITIVES", 2, &_GRAPHICS_PRIMITIVES_PLINE, 1,
 _GRAPHICS_PRIMITIVES_guidance, 0, (char**)0, 0, (char**)0 };

static char *_GRAPHICS_VIEWING_guidance[] = {
 "To define Normalisation transformations.",
 "Either automatically (ZONE and SIZE) or 'by hand' (SVP, SWN and SELNT)." };
static KmMenu _GRAPHICS_VIEWING = { &_GRAPHICS_PRIMITIVES,  (KmMenu*)0,
 "/GRAPHICS/VIEWING", "VIEWING", 2, &_GRAPHICS_VIEWING_ZONE, 2,
 _GRAPHICS_VIEWING_guidance, 0, (char**)0, 0, (char**)0 };

static char *_GRAPHICS_MISC_guidance[] = { "Miscellaneous HPLOT functions." };
static KmMenu _GRAPHICS_MISC = { &_GRAPHICS_VIEWING,  (KmMenu*)0,
 "/GRAPHICS/MISC", "MISC", 2, &_GRAPHICS_MISC_NEXT, 1,
 _GRAPHICS_MISC_guidance, 0, (char**)0, 0, (char**)0 };

static KmParInt    _GRAPHICS_WORKSTATION_IWKID_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_WORKSTATION_IWKID = { "IWKID", 5,
 "Workstation ID", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_GRAPHICS_WORKSTATION_IWKID_type };
static char *_GRAPHICS_WORKSTATION_CHOPT_range[] = { "O", "C", "A", "D", "L" };
static char *_GRAPHICS_WORKSTATION_CHOPT_text[] = { "Open a new workstation",
 "Close a workstation", "Activate a workstation", "Deactivate a workstation",
 "Give the list of open workstations" };
static KmParOption _GRAPHICS_WORKSTATION_CHOPT_type = {
 _GRAPHICS_WORKSTATION_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _GRAPHICS_WORKSTATION_CHOPT = { "CHOPT", 5, "Options",
 "OA", (char*)0, 8, 5, _GRAPHICS_WORKSTATION_CHOPT_range, 5,
 _GRAPHICS_WORKSTATION_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_GRAPHICS_WORKSTATION_CHOPT_type };
static KmParInt    _GRAPHICS_WORKSTATION_IWTYP_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_WORKSTATION_IWTYP = { "IWTYP", 5,
 "Workstation type", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_GRAPHICS_WORKSTATION_IWTYP_type };
static KmParameter *_GRAPHICS_WORKSTATION_parameters[] = {
 &_GRAPHICS_WORKSTATION_IWKID, &_GRAPHICS_WORKSTATION_CHOPT,
 &_GRAPHICS_WORKSTATION_IWTYP };
static char *_GRAPHICS_WORKSTATION_guidance[] = {
 "To create/delete workstations or change status.",
 "    IWKID > 0  Do the action specified by CHOPT on the",
 "               workstation identified by IWKID.",
 "    IWKID = 0  Do the action specified by CHOPT on all",
 "               workstations.",
 "    IWKID < 0  Do the action specified by CHOPT on the",
 "               workstation identified by -IWKID and the",
 "               complementary action on all the others.",
 "Note: IWKID should not be equal to 2 if a metafile is actived because the",
 "command METAFILE use it already." };
static KmCommand _GRAPHICS_WORKSTATION = {  (KmCommand*)0,
 "/GRAPHICS/WORKSTATION", "WORKSTATION", 0, 1, 3, 1,
 _GRAPHICS_WORKSTATION_parameters, 1, 0, pawork_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 10, _GRAPHICS_WORKSTATION_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _GRAPHICS_METAFILE_LUN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_METAFILE_LUN = { "LUN", 3, "Logical unit number",
 "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GRAPHICS_METAFILE_LUN_type };
static KmParInt    _GRAPHICS_METAFILE_METAFL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _GRAPHICS_METAFILE_METAFL = { "METAFL", 6, "Metafile ID",
 "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_GRAPHICS_METAFILE_METAFL_type };
static KmParameter _GRAPHICS_METAFILE_CHMETA = { "CHMETA", 6, "Metafile name",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_GRAPHICS_METAFILE_parameters[] = {
 &_GRAPHICS_METAFILE_LUN, &_GRAPHICS_METAFILE_METAFL,
 &_GRAPHICS_METAFILE_CHMETA };
static char *_GRAPHICS_METAFILE_guidance[] = {
 "Set the metafile logical unit and metafile type.",
 "This command controls the destination of the subsequent graphics output.",
 "Example:", " LUN =-10 output only on metafile opened on unit 10;",
 " LUN =  0 output only on screen;",
 " LUN = 10 output on both screen and metafile opened on unit 10;",
 "Use the command FORTRAN/FILE to open a new file, FORTRAN/CLOSE to close\
 it.", "Note that PAW opens the file PAW.METAFILE on the unit 10",
 "at initialisation time.", " METAFL=   4 Appendix E GKS.",
 " METAFL=-111 HIGZ/PostScript (Portrait).",
 " METAFL=-112 HIGZ/PostScript (Landscape).",
 " METAFL=-113 HIGZ/Encapsulated PostScript.",
 " METAFL=-114 HIGZ/PostScript Color (Portrait).",
 " METAFL=-115 HIGZ/PostScript Color (Landscape).",
 " METAFL=-777 HIGZ/LaTex Encapsulated.", " METAFL=-778 HIGZ/LaTex.",
 "The PostScript metafile types have the following format:",
 "                   -[Format][Nx][Ny][Type]", " Where:",
 "[Format] Is an integer between 0 and 99 which defines the format of the",
 "         paper. For example if Format=3 the paper is in the standard",
 "         A3 format. Format=4 and Format=0 are the same and",
 "         define an A4 page.",
 "         The A0 format is selected by Format=99.",
 "         The US format Letter is selected by Format=100.",
 "         The US format Legal is selected by Format=200.",
 "         The US format Ledger is selected by Format=300.",
 "[Nx, Ny] Specify respectively the number of zones on the x and y axis.",
 "         Nx and Ny are integers between 1 and 9.",
 "[Type]   Can be equal to:",
 "         1: Portrait mode with a small margin at the bottom of the page.",
 "         2: Landscape mode with a small margin at the bottom of the page.",
 "         4: Portrait mode with a large margin at the bottom of the page.",
 "         5: Landscape mode with a large margin at the bottom of the page.",
 "            The large margin is useful for some PostScript printers (very",
 "            often for the colour printers) as they need more space to grip",
 "            the paper for mechanical reasons. Note that some PostScript",
 "            colour printers can also use the so called 'special A4' format",
 "            permitting the full usage of the A4 area; in this case larger",
 "            margins are not necessary and {\\tt Type}=1 or 2 can be used.",
 "         3: Encapsulated PostScript. This Type permits the generation of",
 "            files which can be included in other documents, for example",
 "            in LaTeX files. Note that with this Type, Nx and Ny must\
 always",
 "            be equal to 1, and Format has no meaning. The size of the\
 picture",
 "            must be specified by the user via the SIZE command. Therefore",
 "            the workstation type for Encapsulated PostScript is -113. For",
 "            example if the name of an encapsulated PostScript file is",
 "            example.eps, the inclusion of this file into a LaTeX file will",
 "            be possible via (in the LaTeX file):",
 "                    \\begin{figure}",
 "                     \\epsffile{example.eps}",
 "                     \\caption{Example of Encapsulated PostScript in\
 LaTeX.}", "                     \\label{EXAMPLE}",
 "                    \\end{figure}",
 "With Type=1,2,4 and 5 the pictures are centered on the page, and the\
 usable", "area on paper is proportional to the dimensions of A4 format.",
 "Examples:", "-111 or -4111 defines an A4 page not divided.",
 "-6322 define an A6 landscape page divided in 3 columns and 2 rows.",
 "                    +-------+-------+-------+",
 "                    |   1   |   2   |   3   |",
 "                    +-------+-------+-------+",
 "                    |   4   |   5   |   6   |",
 "                    +-------+-------+-------+",
 "The first picture  will be drawn  in the area 1. After each clear the\
 screen,",
 "the graphics output will appear in the next area in the order defined\
 above.",
 "If a page is filled, a new page is used with the same grid. Note that\
 empty", "pages are not printed in order to save paper.",
 "Ignoring formats smaller than A12, the total number of possible different",
 "PostScript workstation types is: 4x9x9x13+1 = 4213 !",
 "Note: this command open a metafile on the workstation identifier number 2."
 };
static KmCommand _GRAPHICS_METAFILE = { &_GRAPHICS_WORKSTATION,
 "/GRAPHICS/METAFILE", "METAFILE", 0, 1, 3, 0, _GRAPHICS_METAFILE_parameters,
 0, 0, pagraf_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 72,
 _GRAPHICS_METAFILE_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParOption _GRAPHICS_OPTION_CHOPTN_type = { (char**)0, (int*)0,
 (int*)0 };
static KmParameter _GRAPHICS_OPTION_CHOPTN = { "CHOPTN", 6, "Option name",
 "SHOW", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_OPTION, &_GRAPHICS_OPTION_CHOPTN_type };
static KmParameter *_GRAPHICS_OPTION_parameters[] = { &_GRAPHICS_OPTION_CHOPTN
 };
static char *_GRAPHICS_OPTION_guidance[] = {
 "Set general plotting options for HPLOT.",
 "If CHOPTN='SHOW' print all current and default options.",
 "If CHOPTN='*', restore all default options." };
static KmCommand _GRAPHICS_OPTION = { &_GRAPHICS_METAFILE, "/GRAPHICS/OPTION",
 "OPTION", 0, 1, 1, 0, _GRAPHICS_OPTION_parameters, 0, 0, pagraf_,
 (IntFunc*)0, pahelp_, (pCharFunc*)0, 3, _GRAPHICS_OPTION_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _GRAPHICS_SET_CHATT = { "CHATT", 5, "Attribute name",
 "SHOW", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParReal   _GRAPHICS_SET_VALUE_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _GRAPHICS_SET_VALUE = { "VALUE", 5, "Attribute value", "0",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_GRAPHICS_SET_VALUE_type };
static KmParameter *_GRAPHICS_SET_parameters[] = { &_GRAPHICS_SET_CHATT,
 &_GRAPHICS_SET_VALUE };
static char *_GRAPHICS_SET_guidance[] = { "Set a specific HPLOT attribute.",
 "If CHATT='SHOW', print defaults and current values for all attributes.",
 "If CHATT='*', restore default values for all attributes.",
 "If VALUE=0, the attribute is set to its default value." };
static KmCommand _GRAPHICS_SET = { &_GRAPHICS_OPTION, "/GRAPHICS/SET", "SET",
 0, 1, 2, 0, _GRAPHICS_SET_parameters, 0, 0, pagraf_, (IntFunc*)0, pahelp_,
 (pCharFunc*)0, 4, _GRAPHICS_SET_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_GRAPHICS_guidance[] = {
 "Interface to the graphics packages HPLOT and HIGZ." };
static KmMenu _GRAPHICS = {  (KmMenu*)0, &_GRAPHICS_MISC, "/GRAPHICS",
 "GRAPHICS", 1, &_GRAPHICS_SET, 1, _GRAPHICS_guidance, 0, (char**)0, 0,
 (char**)0 };

  klnkmenu( &_GRAPHICS, 950303 );
}


#ifdef F77_LCASE
#  define picdef_ picdef
#  define papict_ papict
#  define pahelp_ pahelp
#endif

#ifdef F77_UCASE
#  define picdef_ PICDEF
#  define papict_ PAPICT
#  define pahelp_ PAHELP
#endif

#ifdef IBM370
#  pragma linkage(PICDEF,FORTRAN)
#  pragma linkage(PAPICT,FORTRAN)
#  pragma linkage(PAHELP,FORTRAN)
#endif

extern void picdef_();
extern void papict_();
extern void pahelp_();

void picdef_()
{

static KmParameter _PICTURE_IGSET_CHATT = { "CHATT", 5, "Attribute name",
 "SHOW", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParReal   _PICTURE_IGSET_VALUE_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _PICTURE_IGSET_VALUE = { "VALUE", 5, "Attribute value",
 "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_PICTURE_IGSET_VALUE_type };
static KmParameter *_PICTURE_IGSET_parameters[] = { &_PICTURE_IGSET_CHATT,
 &_PICTURE_IGSET_VALUE };
static char *_PICTURE_IGSET_guidance[] = { "Set a HIGZ attribute.",
 "If CHATT='SHOW' print default and current values for all attributes.",
 "If CHATT='*' restore default values for all attributes.",
 "If VALUE=0, the attribute is set to its default value." };
static KmCommand _PICTURE_IGSET = {  (KmCommand*)0, "/PICTURE/IGSET", "IGSET",
 0, 1, 2, 0, _PICTURE_IGSET_parameters, 0, 0, papict_, (IntFunc*)0, pahelp_,
 (pCharFunc*)0, 4, _PICTURE_IGSET_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_PICTURE_SWITCH_CHOPT_range[] = { "G", "Z" };
static char *_PICTURE_SWITCH_CHOPT_text[] = { "graphics output only.",
 "Graphics primitives stored in ZEBRA memory only." };
static KmParOption _PICTURE_SWITCH_CHOPT_type = { _PICTURE_SWITCH_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _PICTURE_SWITCH_CHOPT = { "CHOPT", 5, "Options", "G",
 (char*)0, 8, 2, _PICTURE_SWITCH_CHOPT_range, 2, _PICTURE_SWITCH_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_PICTURE_SWITCH_CHOPT_type };
static KmParameter *_PICTURE_SWITCH_parameters[] = { &_PICTURE_SWITCH_CHOPT };
static char *_PICTURE_SWITCH_guidance[] = {
 "Set the graphics switch to control plotting output",
 "to terminal (G) and/or picture in memory (Z)." };
static KmCommand _PICTURE_SWITCH = { &_PICTURE_IGSET, "/PICTURE/SWITCH",
 "SWITCH", 0, 1, 1, 0, _PICTURE_SWITCH_parameters, 0, 0, papict_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _PICTURE_SWITCH_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _PICTURE_IZPICT_PNAME = { "PNAME", 5, "Picture name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static char *_PICTURE_IZPICT_CHOPT_range[] = { "M", "D", "S", "N", "L", "F",
 "P", "C" };
static char *_PICTURE_IZPICT_CHOPT_text[] = {
 "Make a new picture in memory with name PNAME. An empty structure is created\
 in memory and becomes the current picture. If PNAME = ' ', the picture is\
 automatically named as PICTnnn, where the starting value of nnn is either 0\
 (default), or the value assigned by SET to the parameter PICT.",
 "Display the picture PNAME in memory.",
 "Scratch the picture PNAME from memory. If PNAME = ' ' the current picture is\
 scratched.",
 "The picture following the current picture in memory becomes the current\
 picture. If the current picture is the last one in memory, the first picture\
 in memory becomes the current picture.",
 "Give the list of the pictures in memory, following the sequence of their\
 storage in memory.",
 "The First picture in memory becomes the current picture.",
 "Print the picture data structure. Useful to debug programs.",
 "Set Current picture. All calls to HIGZ graphic functions are stored in the\
 current structure according to the option selected be IGZSET." };
static KmParOption _PICTURE_IZPICT_CHOPT_type = { _PICTURE_IZPICT_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _PICTURE_IZPICT_CHOPT = { "CHOPT", 5, "Options", "M",
 (char*)0, 8, 8, _PICTURE_IZPICT_CHOPT_range, 8, _PICTURE_IZPICT_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_PICTURE_IZPICT_CHOPT_type };
static KmParameter *_PICTURE_IZPICT_parameters[] = { &_PICTURE_IZPICT_PNAME,
 &_PICTURE_IZPICT_CHOPT };
static char *_PICTURE_IZPICT_guidance[] = {
 "Perform various operations on a picture.",
 "PNAME=' ' means the current picture.", "PNAME='*' means all pictures." };
static KmCommand _PICTURE_IZPICT = { &_PICTURE_SWITCH, "/PICTURE/IZPICT",
 "IZPICT", 0, 1, 2, 1, _PICTURE_IZPICT_parameters, 0, 0, papict_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _PICTURE_IZPICT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _PICTURE_IZIN_PNAME = { "PNAME", 5, "Picture name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _PICTURE_IZIN_ICYCLE_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _PICTURE_IZIN_ICYCLE = { "ICYCLE", 6, "Cycle number ",
 "9999", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_PICTURE_IZIN_ICYCLE_type };
static KmParameter *_PICTURE_IZIN_parameters[] = { &_PICTURE_IZIN_PNAME,
 &_PICTURE_IZIN_ICYCLE };
static char *_PICTURE_IZIN_guidance[] = {
 "Read picture into memory from a direct access picture file.",
 "(see command PICTURE/FILE).", "PNAME='*' means all pictures." };
static KmCommand _PICTURE_IZIN = { &_PICTURE_IZPICT, "/PICTURE/IZIN", "IZIN",
 0, 1, 2, 1, _PICTURE_IZIN_parameters, 1, 0, papict_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _PICTURE_IZIN_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _PICTURE_IZOUT_PNAME = { "PNAME", 5, "Picture name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_PICTURE_IZOUT_parameters[] = { &_PICTURE_IZOUT_PNAME };
static char *_PICTURE_IZOUT_guidance[] = {
 "Write the picture PNAME to a direct access picture file",
 "(see command PICTURE/FILE).", "PNAME=' ' means the current picture.",
 "PNAME='*' means all pictures." };
static KmCommand _PICTURE_IZOUT = { &_PICTURE_IZIN, "/PICTURE/IZOUT", "IZOUT",
 0, 1, 1, 0, _PICTURE_IZOUT_parameters, 1, 0, papict_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _PICTURE_IZOUT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _PICTURE_PRINT_FILE = { "FILE", 4, "File name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_PICTURE_PRINT_parameters[] = { &_PICTURE_PRINT_FILE };
static char *_PICTURE_PRINT_guidance[] = { "Print the current picture.",
 "The current picture is transformed into a printable file.",
 "The file type is defined according to the extension of",
 "the file name i.e.", "",
 "   FILE = filename.ps    A PostScript file is generated (-111)",
 "   FILE = filename.eps   A Encapsulated PostScript file",
 "                         is generated (-113)",
 "   FILE = filename.tex   A LaTex file is generated (-778)",
 "   FILE = filename.gif   A gif file is generated",
 "Do HELP META for details about the metafile types.",
 "Note that a new picture is automatically created for each new",
 "plot if the OPTION ZFL1 is on.", "",
 "For gif files, the picture in memory is not used. The gif file is",
 "a direct \"hardcopy\" of the window number 1 content.", "",
 "If FILE=HIGZPRINTER or FILE=' ' the PostScript file paw.ps (-111)",
 "is generated and the operating system command defined by the environment",
 "variable HIGZPRINTER is executed.", "",
 "The environment variable HIGZPRINTER should be defined as follow:",
 "   On UNIX sytems:",
 "          setenv HIGZPRINTER 'lp -dprinter_name paw.ps'", "     or",
 "          export HIGZPRINTER='lp -dprinter_name paw.ps'",
 "   On VAX/VMS sytems:",
 "          HIGZPRINTER == 'XPRINT paw.ps /PRINTER=printer_name'",
 "   On CERNVM:",
 "          setenv HIGZPRINTER 'XPRINT PAW PS (PR printer_name'", "",
 "Note that if the environment variable HIGZPRINTER is not defined",
 "the file paw.ps is created but not printed." };
static KmCommand _PICTURE_PRINT = { &_PICTURE_IZOUT, "/PICTURE/PRINT",
 "PRINT", 0, 1, 1, 0, _PICTURE_PRINT_parameters, 0, 0, papict_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 33, _PICTURE_PRINT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _PICTURE_RENAME_PNAME1 = { "PNAME1", 6, "Old picture name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _PICTURE_RENAME_PNAME2 = { "PNAME2", 6, "New picture name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_PICTURE_RENAME_parameters[] = { &_PICTURE_RENAME_PNAME1,
 &_PICTURE_RENAME_PNAME2 };
static char *_PICTURE_RENAME_guidance[] = { "Rename a picture." };
static KmCommand _PICTURE_RENAME = { &_PICTURE_PRINT, "/PICTURE/RENAME",
 "RENAME", 0, 1, 2, 2, _PICTURE_RENAME_parameters, 0, 0, papict_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _PICTURE_RENAME_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _PICTURE_COPY_PNAME1 = { "PNAME1", 6, "Picture name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _PICTURE_COPY_PNAME2 = { "PNAME2", 6, "New picture name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_PICTURE_COPY_parameters[] = { &_PICTURE_COPY_PNAME1,
 &_PICTURE_COPY_PNAME2 };
static char *_PICTURE_COPY_guidance[] = { "Copy a picture." };
static KmCommand _PICTURE_COPY = { &_PICTURE_RENAME, "/PICTURE/COPY", "COPY",
 0, 1, 2, 2, _PICTURE_COPY_parameters, 2, 0, papict_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _PICTURE_COPY_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _PICTURE_MERGE_PNAME = { "PNAME", 5, "Picture name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParReal   _PICTURE_MERGE_X_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _PICTURE_MERGE_X = { "X", 1,
 "X coordinates (NDC) where to draw PNAME", "0", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_PICTURE_MERGE_X_type };
static KmParReal   _PICTURE_MERGE_Y_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _PICTURE_MERGE_Y = { "Y", 1,
 "Y coordinates (NDC) where to draw PNAME", "0", (char*)0, 12, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_REAL, &_PICTURE_MERGE_Y_type };
static KmParReal   _PICTURE_MERGE_SCALE_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _PICTURE_MERGE_SCALE = { "SCALE", 5, "Scale factor", "1.",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_PICTURE_MERGE_SCALE_type };
static char *_PICTURE_MERGE_CHOPT_range[] = { "", "D" };
static char *_PICTURE_MERGE_CHOPT_text[] = {
 "Merge the picture PNAME with the current picture.",
 "Picture PNAME is displayed during merging." };
static KmParOption _PICTURE_MERGE_CHOPT_type = { _PICTURE_MERGE_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _PICTURE_MERGE_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 2, _PICTURE_MERGE_CHOPT_range, 2, _PICTURE_MERGE_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_PICTURE_MERGE_CHOPT_type };
static KmParameter *_PICTURE_MERGE_parameters[] = { &_PICTURE_MERGE_PNAME,
 &_PICTURE_MERGE_X, &_PICTURE_MERGE_Y, &_PICTURE_MERGE_SCALE,
 &_PICTURE_MERGE_CHOPT };
static char *_PICTURE_MERGE_guidance[] = {
 "Add the picture PNAME to the current picture." };
static KmCommand _PICTURE_MERGE = { &_PICTURE_COPY, "/PICTURE/MERGE", "MERGE",
 0, 1, 5, 1, _PICTURE_MERGE_parameters, 0, 0, papict_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _PICTURE_MERGE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _PICTURE_MODIFY_PNAME = { "PNAME", 5, "Picture name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_PICTURE_MODIFY_CHOPT_range[] = { "S", "A" };
static char *_PICTURE_MODIFY_CHOPT_text[] = {
 "Software characters are used for the text in menus.",
 "The option shadow is used." };
static KmParOption _PICTURE_MODIFY_CHOPT_type = { _PICTURE_MODIFY_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _PICTURE_MODIFY_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 2, _PICTURE_MODIFY_CHOPT_range, 2, _PICTURE_MODIFY_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_PICTURE_MODIFY_CHOPT_type };
static KmParameter *_PICTURE_MODIFY_parameters[] = { &_PICTURE_MODIFY_PNAME,
 &_PICTURE_MODIFY_CHOPT };
static char *_PICTURE_MODIFY_guidance[] = { "Edit the picture PNAME.",
 "PNAME=' ' means the current picture.",
 "This command is only available on workstations." };
static KmCommand _PICTURE_MODIFY = { &_PICTURE_MERGE, "/PICTURE/MODIFY",
 "MODIFY", 0, 1, 2, 0, _PICTURE_MODIFY_parameters, 0, 0, papict_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _PICTURE_MODIFY_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _PICTURE_PLOT_PNAME = { "PNAME", 5, "Picture name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_PICTURE_PLOT_parameters[] = { &_PICTURE_PLOT_PNAME };
static char *_PICTURE_PLOT_guidance[] = { "Plot the picture PNAME.",
 "PNAME=' ' means the current picture.", "PNAME='*' means all pictures." };
static KmCommand _PICTURE_PLOT = { &_PICTURE_MODIFY, "/PICTURE/PLOT", "PLOT",
 0, 1, 1, 0, _PICTURE_PLOT_parameters, 1, 0, papict_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _PICTURE_PLOT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _PICTURE_SCRATCH_PNAME = { "PNAME", 5, "Picture name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _PICTURE_SCRATCH_ICYCLE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _PICTURE_SCRATCH_ICYCLE = { "ICYCLE", 6, "Cycle number ",
 "9999", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_PICTURE_SCRATCH_ICYCLE_type };
static KmParameter *_PICTURE_SCRATCH_parameters[] = { &_PICTURE_SCRATCH_PNAME,
 &_PICTURE_SCRATCH_ICYCLE };
static char *_PICTURE_SCRATCH_guidance[] = {
 "Delete the picture PNAME from current directory on disk." };
static KmCommand _PICTURE_SCRATCH = { &_PICTURE_PLOT, "/PICTURE/SCRATCH",
 "SCRATCH", 0, 1, 2, 1, _PICTURE_SCRATCH_parameters, 1, 0, papict_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1, _PICTURE_SCRATCH_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _PICTURE_DELETE_PNAME = { "PNAME", 5, "Picture name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_PICTURE_DELETE_parameters[] = { &_PICTURE_DELETE_PNAME };
static char *_PICTURE_DELETE_guidance[] = {
 "Delete the picture PNAME from memory.", "PNAME='*' means all pictures." };
static KmCommand _PICTURE_DELETE = { &_PICTURE_SCRATCH, "/PICTURE/DELETE",
 "DELETE", 0, 1, 1, 1, _PICTURE_DELETE_parameters, 1, 0, papict_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _PICTURE_DELETE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _PICTURE_CREATE_PNAME = { "PNAME", 5, "Picture name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_PICTURE_CREATE_parameters[] = { &_PICTURE_CREATE_PNAME };
static char *_PICTURE_CREATE_guidance[] = {
 "Create a new picture, named PNAME, in memory.",
 "Note that all commands which start a new picture (clear workstation)",
 "automatically create pictures named PICT1, PICT2, etc.",
 "if the command OPTION ZFL or OPTION ZFL1 has been executed." };
static KmCommand _PICTURE_CREATE = { &_PICTURE_DELETE, "/PICTURE/CREATE",
 "CREATE", 0, 1, 1, 1, _PICTURE_CREATE_parameters, 1, 0, papict_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _PICTURE_CREATE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_PICTURE_LIST_guidance[] = {
 "List all the HIGZ pictures currently stored in memory." };
static KmCommand _PICTURE_LIST = { &_PICTURE_CREATE, "/PICTURE/LIST", "LIST",
 0, 1, 0, 0, (KmParameter**)0, 0, 0, papict_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _PICTURE_LIST_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _PICTURE_FILE_LUN_type = { "1", "128", "1", "128", 0 };
static KmParameter _PICTURE_FILE_LUN = { "LUN", 3, "Logical unit number",
 (char*)0, (char*)0, 4, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_PICTURE_FILE_LUN_type };
static KmParameter _PICTURE_FILE_FNAME = { "FNAME", 5, "File name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _PICTURE_FILE_LRECL_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _PICTURE_FILE_LRECL = { "LRECL", 5,
 "Record length in words", "1024", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_PICTURE_FILE_LRECL_type };
static char *_PICTURE_FILE_CHOPT_range[] = { "", "N", "U", "A" };
static char *_PICTURE_FILE_CHOPT_text[] = { "Existing file is opened.",
 "A new file is opened.", "Existing file is modified.", "Automatic saving." };
static KmParOption _PICTURE_FILE_CHOPT_type = { _PICTURE_FILE_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _PICTURE_FILE_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 4, _PICTURE_FILE_CHOPT_range, 4, _PICTURE_FILE_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_PICTURE_FILE_CHOPT_type };
static KmParameter *_PICTURE_FILE_parameters[] = { &_PICTURE_FILE_LUN,
 &_PICTURE_FILE_FNAME, &_PICTURE_FILE_LRECL, &_PICTURE_FILE_CHOPT };
static char *_PICTURE_FILE_guidance[] = {
 "Open a HIGZ direct access picture file.",
 "If CHOPT='AU' or 'AN', pictures will be automatically saved",
 "on the direct access file. This automatic saving facility",
 "can be switched off using SET AURZ 0." };
static KmCommand _PICTURE_FILE = { &_PICTURE_LIST, "/PICTURE/FILE", "FILE", 0,
 1, 4, 2, _PICTURE_FILE_parameters, 0, 0, papict_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _PICTURE_FILE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_PICTURE_guidance[] = {
 "Creation and manipulation of HIGZ pictures." };
static KmMenu _PICTURE = {  (KmMenu*)0,  (KmMenu*)0, "/PICTURE", "PICTURE", 1,
 &_PICTURE_FILE, 1, _PICTURE_guidance, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_PICTURE, 950303 );
}


#ifdef F77_LCASE
#  define obsdef_ obsdef
#  define paobs_ paobs
#endif

#ifdef F77_UCASE
#  define obsdef_ OBSDEF
#  define paobs_ PAOBS
#endif

#ifdef IBM370
#  pragma linkage(OBSDEF,FORTRAN)
#  pragma linkage(PAOBS,FORTRAN)
#endif

extern void obsdef_();
extern void paobs_();

void obsdef_()
{

static KmParReal   _OBSOLETE_GRAPHICS_ATTRIBUTES_SLWSC_LW_type = { "1",
 (char*)0, "1", (char*)0, 0 };
static KmParameter _OBSOLETE_GRAPHICS_ATTRIBUTES_SLWSC_LW = { "LW", 2,
 "Line width", "1", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_OBSOLETE_GRAPHICS_ATTRIBUTES_SLWSC_LW_type };
static KmParameter *_OBSOLETE_GRAPHICS_ATTRIBUTES_SLWSC_parameters[] = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_SLWSC_LW };
static char *_OBSOLETE_GRAPHICS_ATTRIBUTES_SLWSC_guidance[] = {
 "Set the line width scale factor.", "Obsolete command use SET LWID." };
static KmCommand _OBSOLETE_GRAPHICS_ATTRIBUTES_SLWSC = {  (KmCommand*)0,
 "/OBSOLETE/GRAPHICS/ATTRIBUTES/SLWSC", "SLWSC", 0, 3, 1, 0,
 _OBSOLETE_GRAPHICS_ATTRIBUTES_SLWSC_parameters, 0, 0, paobs_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _OBSOLETE_GRAPHICS_ATTRIBUTES_SLWSC_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParReal   _OBSOLETE_GRAPHICS_ATTRIBUTES_SCHH_CHH_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _OBSOLETE_GRAPHICS_ATTRIBUTES_SCHH_CHH = { "CHH", 3,
 "Character height", "0.28", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_OBSOLETE_GRAPHICS_ATTRIBUTES_SCHH_CHH_type };
static KmParameter *_OBSOLETE_GRAPHICS_ATTRIBUTES_SCHH_parameters[] = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_SCHH_CHH };
static char *_OBSOLETE_GRAPHICS_ATTRIBUTES_SCHH_guidance[] = {
 "Set the character height.", "Obsolete command use SET CHHE." };
static KmCommand _OBSOLETE_GRAPHICS_ATTRIBUTES_SCHH = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_SLWSC, "/OBSOLETE/GRAPHICS/ATTRIBUTES/SCHH",
 "SCHH", 0, 3, 1, 0, _OBSOLETE_GRAPHICS_ATTRIBUTES_SCHH_parameters, 0, 0,
 paobs_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _OBSOLETE_GRAPHICS_ATTRIBUTES_SCHH_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _OBSOLETE_GRAPHICS_ATTRIBUTES_STXFP_IFONT_type = {
 (char*)0, (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _OBSOLETE_GRAPHICS_ATTRIBUTES_STXFP_IFONT = { "IFONT", 5,
 "Font number", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_OBSOLETE_GRAPHICS_ATTRIBUTES_STXFP_IFONT_type };
static KmParInt    _OBSOLETE_GRAPHICS_ATTRIBUTES_STXFP_IPREC_type = {
 (char*)0, (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _OBSOLETE_GRAPHICS_ATTRIBUTES_STXFP_IPREC = { "IPREC", 5,
 "Font precision", "2", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_OBSOLETE_GRAPHICS_ATTRIBUTES_STXFP_IPREC_type };
static KmParameter *_OBSOLETE_GRAPHICS_ATTRIBUTES_STXFP_parameters[] = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_STXFP_IFONT,
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_STXFP_IPREC };
static char *_OBSOLETE_GRAPHICS_ATTRIBUTES_STXFP_guidance[] = {
 "Set text font and precision.", "Obsolete command use SET TXFP." };
static KmCommand _OBSOLETE_GRAPHICS_ATTRIBUTES_STXFP = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_SCHH, "/OBSOLETE/GRAPHICS/ATTRIBUTES/STXFP",
 "STXFP", 0, 3, 2, 0, _OBSOLETE_GRAPHICS_ATTRIBUTES_STXFP_parameters, 0, 0,
 paobs_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _OBSOLETE_GRAPHICS_ATTRIBUTES_STXFP_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _OBSOLETE_GRAPHICS_ATTRIBUTES_STXCI_ITXCI_type = {
 (char*)0, (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _OBSOLETE_GRAPHICS_ATTRIBUTES_STXCI_ITXCI = { "ITXCI", 5,
 "Text color index", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_OBSOLETE_GRAPHICS_ATTRIBUTES_STXCI_ITXCI_type };
static KmParameter *_OBSOLETE_GRAPHICS_ATTRIBUTES_STXCI_parameters[] = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_STXCI_ITXCI };
static char *_OBSOLETE_GRAPHICS_ATTRIBUTES_STXCI_guidance[] = {
 "Set the text color index.", "Obsolete command use SET TXCI." };
static KmCommand _OBSOLETE_GRAPHICS_ATTRIBUTES_STXCI = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_STXFP, "/OBSOLETE/GRAPHICS/ATTRIBUTES/STXCI",
 "STXCI", 0, 3, 1, 0, _OBSOLETE_GRAPHICS_ATTRIBUTES_STXCI_parameters, 0, 0,
 paobs_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _OBSOLETE_GRAPHICS_ATTRIBUTES_STXCI_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _OBSOLETE_GRAPHICS_ATTRIBUTES_SPMCI_IPMCI_type = {
 (char*)0, (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _OBSOLETE_GRAPHICS_ATTRIBUTES_SPMCI_IPMCI = { "IPMCI", 5,
 "Polymarker color index", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_OBSOLETE_GRAPHICS_ATTRIBUTES_SPMCI_IPMCI_type };
static KmParameter *_OBSOLETE_GRAPHICS_ATTRIBUTES_SPMCI_parameters[] = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_SPMCI_IPMCI };
static char *_OBSOLETE_GRAPHICS_ATTRIBUTES_SPMCI_guidance[] = {
 "Set the polymarker color index.", "Obsolete command use SET PMCI." };
static KmCommand _OBSOLETE_GRAPHICS_ATTRIBUTES_SPMCI = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_STXCI, "/OBSOLETE/GRAPHICS/ATTRIBUTES/SPMCI",
 "SPMCI", 0, 3, 1, 0, _OBSOLETE_GRAPHICS_ATTRIBUTES_SPMCI_parameters, 0, 0,
 paobs_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _OBSOLETE_GRAPHICS_ATTRIBUTES_SPMCI_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _OBSOLETE_GRAPHICS_ATTRIBUTES_SPLCI_IPLCI_type = {
 (char*)0, (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _OBSOLETE_GRAPHICS_ATTRIBUTES_SPLCI_IPLCI = { "IPLCI", 5,
 "Polyline color index", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_OBSOLETE_GRAPHICS_ATTRIBUTES_SPLCI_IPLCI_type };
static KmParameter *_OBSOLETE_GRAPHICS_ATTRIBUTES_SPLCI_parameters[] = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_SPLCI_IPLCI };
static char *_OBSOLETE_GRAPHICS_ATTRIBUTES_SPLCI_guidance[] = {
 "Set the polyline color index.", "Obsolete command use SET PLCI." };
static KmCommand _OBSOLETE_GRAPHICS_ATTRIBUTES_SPLCI = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_SPMCI, "/OBSOLETE/GRAPHICS/ATTRIBUTES/SPLCI",
 "SPLCI", 0, 3, 1, 0, _OBSOLETE_GRAPHICS_ATTRIBUTES_SPLCI_parameters, 0, 0,
 paobs_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _OBSOLETE_GRAPHICS_ATTRIBUTES_SPLCI_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _OBSOLETE_GRAPHICS_ATTRIBUTES_SFACI_IFACI_type = {
 (char*)0, (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _OBSOLETE_GRAPHICS_ATTRIBUTES_SFACI_IFACI = { "IFACI", 5,
 "Fill area color index", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_OBSOLETE_GRAPHICS_ATTRIBUTES_SFACI_IFACI_type };
static KmParameter *_OBSOLETE_GRAPHICS_ATTRIBUTES_SFACI_parameters[] = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_SFACI_IFACI };
static char *_OBSOLETE_GRAPHICS_ATTRIBUTES_SFACI_guidance[] = {
 "Set the fill area color index.", "Obsolete command use SET FACI." };
static KmCommand _OBSOLETE_GRAPHICS_ATTRIBUTES_SFACI = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_SPLCI, "/OBSOLETE/GRAPHICS/ATTRIBUTES/SFACI",
 "SFACI", 0, 3, 1, 0, _OBSOLETE_GRAPHICS_ATTRIBUTES_SFACI_parameters, 0, 0,
 paobs_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _OBSOLETE_GRAPHICS_ATTRIBUTES_SFACI_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _OBSOLETE_GRAPHICS_ATTRIBUTES_SFASI_STYLI_type = {
 (char*)0, (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _OBSOLETE_GRAPHICS_ATTRIBUTES_SFASI_STYLI = { "STYLI", 5,
 "Fill area style index", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_OBSOLETE_GRAPHICS_ATTRIBUTES_SFASI_STYLI_type };
static KmParameter *_OBSOLETE_GRAPHICS_ATTRIBUTES_SFASI_parameters[] = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_SFASI_STYLI };
static char *_OBSOLETE_GRAPHICS_ATTRIBUTES_SFASI_guidance[] = {
 "Set the fill area style index.", "Obsolete command use SET FASI." };
static KmCommand _OBSOLETE_GRAPHICS_ATTRIBUTES_SFASI = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_SFACI, "/OBSOLETE/GRAPHICS/ATTRIBUTES/SFASI",
 "SFASI", 0, 3, 1, 0, _OBSOLETE_GRAPHICS_ATTRIBUTES_SFASI_parameters, 0, 0,
 paobs_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _OBSOLETE_GRAPHICS_ATTRIBUTES_SFASI_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _OBSOLETE_GRAPHICS_ATTRIBUTES_SFAIS_INTS_type = { "0", "3",
 "0", "3", 0 };
static KmParameter _OBSOLETE_GRAPHICS_ATTRIBUTES_SFAIS_INTS = { "INTS", 4,
 "Fill area interior style", "0", (char*)0, 2, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_OBSOLETE_GRAPHICS_ATTRIBUTES_SFAIS_INTS_type };
static KmParameter *_OBSOLETE_GRAPHICS_ATTRIBUTES_SFAIS_parameters[] = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_SFAIS_INTS };
static char *_OBSOLETE_GRAPHICS_ATTRIBUTES_SFAIS_guidance[] = {
 "Set the fill area interior style.", "Obsolete command use SET FAIS." };
static KmCommand _OBSOLETE_GRAPHICS_ATTRIBUTES_SFAIS = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_SFASI, "/OBSOLETE/GRAPHICS/ATTRIBUTES/SFAIS",
 "SFAIS", 0, 3, 1, 0, _OBSOLETE_GRAPHICS_ATTRIBUTES_SFAIS_parameters, 0, 0,
 paobs_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _OBSOLETE_GRAPHICS_ATTRIBUTES_SFAIS_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _OBSOLETE_GRAPHICS_ATTRIBUTES_SLN_ILN_type = { "1",
 (char*)0, "1", (char*)0, 0 };
static KmParameter _OBSOLETE_GRAPHICS_ATTRIBUTES_SLN_ILN = { "ILN", 3,
 "Line style", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_OBSOLETE_GRAPHICS_ATTRIBUTES_SLN_ILN_type };
static KmParameter *_OBSOLETE_GRAPHICS_ATTRIBUTES_SLN_parameters[] = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_SLN_ILN };
static char *_OBSOLETE_GRAPHICS_ATTRIBUTES_SLN_guidance[] = {
 "Set the line style.", "Obsolete command use  SET LTYP." };
static KmCommand _OBSOLETE_GRAPHICS_ATTRIBUTES_SLN = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_SFAIS, "/OBSOLETE/GRAPHICS/ATTRIBUTES/SLN",
 "SLN", 0, 3, 1, 0, _OBSOLETE_GRAPHICS_ATTRIBUTES_SLN_parameters, 0, 0,
 paobs_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _OBSOLETE_GRAPHICS_ATTRIBUTES_SLN_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _OBSOLETE_GRAPHICS_ATTRIBUTES_SMK_MKT_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _OBSOLETE_GRAPHICS_ATTRIBUTES_SMK_MKT = { "MKT", 3,
 "Marker type", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_OBSOLETE_GRAPHICS_ATTRIBUTES_SMK_MKT_type };
static KmParameter *_OBSOLETE_GRAPHICS_ATTRIBUTES_SMK_parameters[] = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_SMK_MKT };
static char *_OBSOLETE_GRAPHICS_ATTRIBUTES_SMK_guidance[] = {
 "Set the marker type.", "Obsolete command use SET MTYP" };
static KmCommand _OBSOLETE_GRAPHICS_ATTRIBUTES_SMK = {
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_SLN, "/OBSOLETE/GRAPHICS/ATTRIBUTES/SMK",
 "SMK", 0, 3, 1, 0, _OBSOLETE_GRAPHICS_ATTRIBUTES_SMK_parameters, 0, 0,
 paobs_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _OBSOLETE_GRAPHICS_ATTRIBUTES_SMK_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmMenu _OBSOLETE_GRAPHICS_ATTRIBUTES = {  (KmMenu*)0,  (KmMenu*)0,
 "/OBSOLETE/GRAPHICS/ATTRIBUTES", "ATTRIBUTES", 3,
 &_OBSOLETE_GRAPHICS_ATTRIBUTES_SMK, 0, (char**)0, 0, (char**)0, 0, (char**)0
 };

static KmMenu _OBSOLETE_GRAPHICS = {  (KmMenu*)0,
 &_OBSOLETE_GRAPHICS_ATTRIBUTES, "/OBSOLETE/GRAPHICS", "GRAPHICS", 2,
 (KmCommand*)0, 0, (char**)0, 0, (char**)0, 0, (char**)0 };

static char *_OBSOLETE_guidance[] = { "Obsolete commands" };
static KmMenu _OBSOLETE = {  (KmMenu*)0, &_OBSOLETE_GRAPHICS, "/OBSOLETE",
 "OBSOLETE", 1,  (KmCommand*)0, 1, _OBSOLETE_guidance, 0, (char**)0, 0,
 (char**)0 };

  klnkmenu( &_OBSOLETE, 950303 );
}


#ifdef F77_LCASE
#  define zebdef_ zebdef
#  define pazrz_ pazrz
#  define pazfz_ pazfz
#  define pazdz_ pazdz
#endif

#ifdef F77_UCASE
#  define zebdef_ ZEBDEF
#  define pazrz_ PAZRZ
#  define pazfz_ PAZFZ
#  define pazdz_ PAZDZ
#endif

#ifdef IBM370
#  pragma linkage(ZEBDEF,FORTRAN)
#  pragma linkage(PAZRZ,FORTRAN)
#  pragma linkage(PAZFZ,FORTRAN)
#  pragma linkage(PAZDZ,FORTRAN)
#endif

extern void zebdef_();
extern void pazrz_();
extern void pazfz_();
extern void pazdz_();

void zebdef_()
{

static KmParameter _ZEBRA_RZ_STAT_CHPATH = { "CHPATH", 6,
 "Name of top directory", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_ZEBRA_RZ_STAT_parameters[] = { &_ZEBRA_RZ_STAT_CHPATH };
static char *_ZEBRA_RZ_STAT_guidance[] = {
 "Print space statistics for an RZ file." };
static KmCommand _ZEBRA_RZ_STAT = {  (KmCommand*)0, "/ZEBRA/RZ/STAT", "STAT",
 0, 2, 1, 1, _ZEBRA_RZ_STAT_parameters, 0, 0, pazrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_RZ_STAT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ZEBRA_RZ_FREE_CHLOCK = { "CHLOCK", 6, "Lock identifier",
 "RZFILE", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_ZEBRA_RZ_FREE_parameters[] = { &_ZEBRA_RZ_FREE_CHLOCK };
static char *_ZEBRA_RZ_FREE_guidance[] = { "Free an RZ directory." };
static KmCommand _ZEBRA_RZ_FREE = { &_ZEBRA_RZ_STAT, "/ZEBRA/RZ/FREE", "FREE",
 0, 2, 1, 0, _ZEBRA_RZ_FREE_parameters, 0, 0, pazrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_RZ_FREE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ZEBRA_RZ_LOCK_CHLOCK = { "CHLOCK", 6, "Lock identifier",
 "RZFILE", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_ZEBRA_RZ_LOCK_parameters[] = { &_ZEBRA_RZ_LOCK_CHLOCK };
static char *_ZEBRA_RZ_LOCK_guidance[] = { "Lock an RZ directory." };
static KmCommand _ZEBRA_RZ_LOCK = { &_ZEBRA_RZ_FREE, "/ZEBRA/RZ/LOCK", "LOCK",
 0, 2, 1, 0, _ZEBRA_RZ_LOCK_parameters, 0, 0, pazrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_RZ_LOCK_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _ZEBRA_RZ_PURGE_KEEP_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ZEBRA_RZ_PURGE_KEEP = { "KEEP", 4,
 "Number of cycles to be kept", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_ZEBRA_RZ_PURGE_KEEP_type };
static KmParameter *_ZEBRA_RZ_PURGE_parameters[] = { &_ZEBRA_RZ_PURGE_KEEP };
static char *_ZEBRA_RZ_PURGE_guidance[] = { "Purge an RZ directory." };
static KmCommand _ZEBRA_RZ_PURGE = { &_ZEBRA_RZ_LOCK, "/ZEBRA/RZ/PURGE",
 "PURGE", 0, 2, 1, 0, _ZEBRA_RZ_PURGE_parameters, 0, 0, pazrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_RZ_PURGE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ZEBRA_RZ_CDIR_CHPATH = { "CHPATH", 6, "Path name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParOption _ZEBRA_RZ_CDIR_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _ZEBRA_RZ_CDIR_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_ZEBRA_RZ_CDIR_CHOPT_type };
static KmParameter *_ZEBRA_RZ_CDIR_parameters[] = { &_ZEBRA_RZ_CDIR_CHPATH,
 &_ZEBRA_RZ_CDIR_CHOPT };
static char *_ZEBRA_RZ_CDIR_guidance[] = {
 "Change the current working directory (CWD).",
 "IF CHPATH is given make it the new CWD.",
 "Otherwise, print the pathname of the CWD.",
 " Ex.  CD dir1         ; make DIR1 the new CWD",
 "      CD //file1/dir2 ; make //FILE1/DIR2 the new CWD",
 "      CD              ; print the name of the CWD" };
static KmCommand _ZEBRA_RZ_CDIR = { &_ZEBRA_RZ_PURGE, "/ZEBRA/RZ/CDIR",
 "CDIR", 0, 2, 2, 0, _ZEBRA_RZ_CDIR_parameters, 0, 0, pazrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 6, _ZEBRA_RZ_CDIR_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ZEBRA_RZ_LDIR_CHPATH = { "CHPATH", 6, "Path name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_ZEBRA_RZ_LDIR_CHOPT_range[] = { "", "A", "T" };
static char *_ZEBRA_RZ_LDIR_CHOPT_text[] = { "List contents of a directory.",
 "List all the Ntuple extensions.", "List a directory Tree." };
static KmParOption _ZEBRA_RZ_LDIR_CHOPT_type = { _ZEBRA_RZ_LDIR_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _ZEBRA_RZ_LDIR_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 3, _ZEBRA_RZ_LDIR_CHOPT_range, 3, _ZEBRA_RZ_LDIR_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_ZEBRA_RZ_LDIR_CHOPT_type };
static KmParameter *_ZEBRA_RZ_LDIR_parameters[] = { &_ZEBRA_RZ_LDIR_CHPATH,
 &_ZEBRA_RZ_LDIR_CHOPT };
static char *_ZEBRA_RZ_LDIR_guidance[] = {
 "List contents of a directory (memory or disk).",
 "To list all RZ files currently opened, type 'LD //'.",
 "Note that if the Current Directory is //PAWC, this command",
 "uses the same format as HISTO/LIST." };
static KmCommand _ZEBRA_RZ_LDIR = { &_ZEBRA_RZ_CDIR, "/ZEBRA/RZ/LDIR", "LDIR",
 0, 2, 2, 0, _ZEBRA_RZ_LDIR_parameters, 0, 0, pazrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _ZEBRA_RZ_LDIR_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ZEBRA_RZ_DDIR_CHDIR = { "CHDIR", 5, "Directory name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_ZEBRA_RZ_DDIR_parameters[] = { &_ZEBRA_RZ_DDIR_CHDIR };
static char *_ZEBRA_RZ_DDIR_guidance[] = {
 "Delete the directory CHDIR from the current directory." };
static KmCommand _ZEBRA_RZ_DDIR = { &_ZEBRA_RZ_LDIR, "/ZEBRA/RZ/DDIR", "DDIR",
 0, 2, 1, 1, _ZEBRA_RZ_DDIR_parameters, 0, 0, pazrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_RZ_DDIR_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ZEBRA_RZ_MDIR_CHDIR = { "CHDIR", 5, "Directory name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _ZEBRA_RZ_MDIR_NWKEY_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ZEBRA_RZ_MDIR_NWKEY = { "NWKEY", 5,
 "Number of words per Key", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_ZEBRA_RZ_MDIR_NWKEY_type };
static KmParameter _ZEBRA_RZ_MDIR_CHFORM = { "CHFORM", 6, "CHFORM", "I",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter _ZEBRA_RZ_MDIR_CHTAGS = { "CHTAGS", 6, "List of Tags",
 "HBOOK-ID", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_ZEBRA_RZ_MDIR_parameters[] = { &_ZEBRA_RZ_MDIR_CHDIR,
 &_ZEBRA_RZ_MDIR_NWKEY, &_ZEBRA_RZ_MDIR_CHFORM, &_ZEBRA_RZ_MDIR_CHTAGS };
static char *_ZEBRA_RZ_MDIR_guidance[] = {
 "Create a new RZ directory below the current directory." };
static KmCommand _ZEBRA_RZ_MDIR = { &_ZEBRA_RZ_DDIR, "/ZEBRA/RZ/MDIR", "MDIR",
 0, 2, 4, 1, _ZEBRA_RZ_MDIR_parameters, 0, 0, pazrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_RZ_MDIR_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _ZEBRA_RZ_MAKE_LUN_type = { "1", "128", "1", "128", 0 };
static KmParameter _ZEBRA_RZ_MAKE_LUN = { "LUN", 3, "Logical unit number",
 (char*)0, (char*)0, 4, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ZEBRA_RZ_MAKE_LUN_type };
static KmParameter _ZEBRA_RZ_MAKE_FNAME = { "FNAME", 5, "File name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _ZEBRA_RZ_MAKE_LRECL_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ZEBRA_RZ_MAKE_LRECL = { "LRECL", 5,
 "Record length in WORDS", "1024", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_ZEBRA_RZ_MAKE_LRECL_type };
static KmParInt    _ZEBRA_RZ_MAKE_NREC_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ZEBRA_RZ_MAKE_NREC = { "NREC", 4, "Number of records",
 "1000", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ZEBRA_RZ_MAKE_NREC_type };
static KmParInt    _ZEBRA_RZ_MAKE_NWKEY_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ZEBRA_RZ_MAKE_NWKEY = { "NWKEY", 5,
 "Number of words per Key", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_ZEBRA_RZ_MAKE_NWKEY_type };
static char *_ZEBRA_RZ_MAKE_CHFORM_range[] = { "I", "B", "A", "H" };
static char *_ZEBRA_RZ_MAKE_CHFORM_text[] = { (char*)0, (char*)0, (char*)0,
 (char*)0 };
static KmParOption _ZEBRA_RZ_MAKE_CHFORM_type = { _ZEBRA_RZ_MAKE_CHFORM_text,
 (int*)0, (int*)0 };
static KmParameter _ZEBRA_RZ_MAKE_CHFORM = { "CHFORM", 6, "Key format", "I",
 (char*)0, 8, 4, _ZEBRA_RZ_MAKE_CHFORM_range, 4, _ZEBRA_RZ_MAKE_CHFORM_range,
 (KmParFlag)0, KmTYPE_OPTION, &_ZEBRA_RZ_MAKE_CHFORM_type };
static KmParameter _ZEBRA_RZ_MAKE_CHTAGS = { "CHTAGS", 6, "List of Tags",
 "HBOOK-ID", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_ZEBRA_RZ_MAKE_parameters[] = { &_ZEBRA_RZ_MAKE_LUN,
 &_ZEBRA_RZ_MAKE_FNAME, &_ZEBRA_RZ_MAKE_LRECL, &_ZEBRA_RZ_MAKE_NREC,
 &_ZEBRA_RZ_MAKE_NWKEY, &_ZEBRA_RZ_MAKE_CHFORM, &_ZEBRA_RZ_MAKE_CHTAGS };
static char *_ZEBRA_RZ_MAKE_guidance[] = { "Open a new direct access file." };
static KmCommand _ZEBRA_RZ_MAKE = { &_ZEBRA_RZ_MDIR, "/ZEBRA/RZ/MAKE", "MAKE",
 0, 2, 7, 2, _ZEBRA_RZ_MAKE_parameters, 0, 0, pazrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_RZ_MAKE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _ZEBRA_RZ_FILE_LUN_type = { "1", "128", "1", "128", 0 };
static KmParameter _ZEBRA_RZ_FILE_LUN = { "LUN", 3, "Logical unit number",
 (char*)0, (char*)0, 4, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ZEBRA_RZ_FILE_LUN_type };
static KmParameter _ZEBRA_RZ_FILE_FNAME = { "FNAME", 5, "File name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _ZEBRA_RZ_FILE_LRECL_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ZEBRA_RZ_FILE_LRECL = { "LRECL", 5,
 "Record length in WORDS", "1024", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_ZEBRA_RZ_FILE_LRECL_type };
static char *_ZEBRA_RZ_FILE_CHOPT_range[] = { "", "U" };
static char *_ZEBRA_RZ_FILE_CHOPT_text[] = { "Read only mode.", "Update mode."
 };
static KmParOption _ZEBRA_RZ_FILE_CHOPT_type = { _ZEBRA_RZ_FILE_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _ZEBRA_RZ_FILE_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 2, _ZEBRA_RZ_FILE_CHOPT_range, 2, _ZEBRA_RZ_FILE_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_ZEBRA_RZ_FILE_CHOPT_type };
static KmParameter *_ZEBRA_RZ_FILE_parameters[] = { &_ZEBRA_RZ_FILE_LUN,
 &_ZEBRA_RZ_FILE_FNAME, &_ZEBRA_RZ_FILE_LRECL, &_ZEBRA_RZ_FILE_CHOPT };
static char *_ZEBRA_RZ_FILE_guidance[] = {
 "Open an existing direct access file." };
static KmCommand _ZEBRA_RZ_FILE = { &_ZEBRA_RZ_MAKE, "/ZEBRA/RZ/FILE", "FILE",
 0, 2, 4, 2, _ZEBRA_RZ_FILE_parameters, 0, 0, pazrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_RZ_FILE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ZEBRA_FZ_FRALPHA_FNAME = { "FNAME", 5,
 "Name of the FZ text file", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_ZEBRA_FZ_FRALPHA_parameters[] = {
 &_ZEBRA_FZ_FRALPHA_FNAME };
static char *_ZEBRA_FZ_FRALPHA_guidance[] = {
 "Copy the FZ alphanumeric file into the current directory." };
static KmCommand _ZEBRA_FZ_FRALPHA = {  (KmCommand*)0, "/ZEBRA/FZ/FRALPHA",
 "FRALPHA", 0, 2, 1, 1, _ZEBRA_FZ_FRALPHA_parameters, 0, 0, pazfz_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_FZ_FRALPHA_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ZEBRA_FZ_TOALPHA_FNAME = { "FNAME", 5,
 "Name of the FZ text file", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_ZEBRA_FZ_TOALPHA_parameters[] = {
 &_ZEBRA_FZ_TOALPHA_FNAME };
static char *_ZEBRA_FZ_TOALPHA_guidance[] = {
 "Copy the current directory tree onto a FZ file.",
 "An alphanumeric format is used.",
 "The file FNAME can be exchanged between different machines." };
static KmCommand _ZEBRA_FZ_TOALPHA = { &_ZEBRA_FZ_FRALPHA,
 "/ZEBRA/FZ/TOALPHA", "TOALPHA", 0, 2, 1, 1, _ZEBRA_FZ_TOALPHA_parameters, 0,
 0, pazfz_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _ZEBRA_FZ_TOALPHA_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _ZEBRA_FZ_FRFZ_LUN_type = { "1", "128", "1", "128", 0 };
static KmParameter _ZEBRA_FZ_FRFZ_LUN = { "LUN", 3,
 "Logical unit number of FZ file", (char*)0, (char*)0, 4, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_ZEBRA_FZ_FRFZ_LUN_type };
static KmParOption _ZEBRA_FZ_FRFZ_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _ZEBRA_FZ_FRFZ_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_ZEBRA_FZ_FRFZ_CHOPT_type };
static KmParameter *_ZEBRA_FZ_FRFZ_parameters[] = { &_ZEBRA_FZ_FRFZ_LUN,
 &_ZEBRA_FZ_FRFZ_CHOPT };
static char *_ZEBRA_FZ_FRFZ_guidance[] = {
 "Copy the FZ file into the current directory tree." };
static KmCommand _ZEBRA_FZ_FRFZ = { &_ZEBRA_FZ_TOALPHA, "/ZEBRA/FZ/FRFZ",
 "FRFZ", 0, 2, 2, 1, _ZEBRA_FZ_FRFZ_parameters, 0, 0, pazfz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_FZ_FRFZ_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _ZEBRA_FZ_TOFZ_LUN_type = { "1", "128", "1", "128", 0 };
static KmParameter _ZEBRA_FZ_TOFZ_LUN = { "LUN", 3,
 "Logical unit number of FZ file", (char*)0, (char*)0, 4, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_ZEBRA_FZ_TOFZ_LUN_type };
static KmParOption _ZEBRA_FZ_TOFZ_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _ZEBRA_FZ_TOFZ_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_ZEBRA_FZ_TOFZ_CHOPT_type };
static KmParameter *_ZEBRA_FZ_TOFZ_parameters[] = { &_ZEBRA_FZ_TOFZ_LUN,
 &_ZEBRA_FZ_TOFZ_CHOPT };
static char *_ZEBRA_FZ_TOFZ_guidance[] = {
 "Copy the current directory tree onto an FZ file." };
static KmCommand _ZEBRA_FZ_TOFZ = { &_ZEBRA_FZ_FRFZ, "/ZEBRA/FZ/TOFZ", "TOFZ",
 0, 2, 2, 1, _ZEBRA_FZ_TOFZ_parameters, 0, 0, pazfz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_FZ_TOFZ_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _ZEBRA_FZ_FILE_LUN_type = { "1", "128", "1", "128", 0 };
static KmParameter _ZEBRA_FZ_FILE_LUN = { "LUN", 3, "Logical unit number",
 (char*)0, (char*)0, 4, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ZEBRA_FZ_FILE_LUN_type };
static KmParameter _ZEBRA_FZ_FILE_FNAME = { "FNAME", 5, "File name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _ZEBRA_FZ_FILE_LRECL_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ZEBRA_FZ_FILE_LRECL = { "LRECL", 5,
 "Record length in words", "900", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_ZEBRA_FZ_FILE_LRECL_type };
static char *_ZEBRA_FZ_FILE_CHOPT_range[] = { "I", "O", "X", "A" };
static char *_ZEBRA_FZ_FILE_CHOPT_text[] = { "Input file.", "Output file.",
 "Binary exchange mode.", "Alphanumeric exchange mode." };
static KmParOption _ZEBRA_FZ_FILE_CHOPT_type = { _ZEBRA_FZ_FILE_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _ZEBRA_FZ_FILE_CHOPT = { "CHOPT", 5, "Options", "IX",
 (char*)0, 8, 4, _ZEBRA_FZ_FILE_CHOPT_range, 4, _ZEBRA_FZ_FILE_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_ZEBRA_FZ_FILE_CHOPT_type };
static KmParameter *_ZEBRA_FZ_FILE_parameters[] = { &_ZEBRA_FZ_FILE_LUN,
 &_ZEBRA_FZ_FILE_FNAME, &_ZEBRA_FZ_FILE_LRECL, &_ZEBRA_FZ_FILE_CHOPT };
static char *_ZEBRA_FZ_FILE_guidance[] = {
 "Open an FZ sequential formatted or unformatted file." };
static KmCommand _ZEBRA_FZ_FILE = { &_ZEBRA_FZ_TOFZ, "/ZEBRA/FZ/FILE", "FILE",
 0, 2, 4, 2, _ZEBRA_FZ_FILE_parameters, 0, 0, pazfz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_FZ_FILE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _ZEBRA_DZ_STORE_IXSTOR_type = { "0", "24", "0", "24", 0 };
static KmParameter _ZEBRA_DZ_STORE_IXSTOR = { "IXSTOR", 6, "Store number",
 "0", (char*)0, 3, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ZEBRA_DZ_STORE_IXSTOR_type };
static KmParameter *_ZEBRA_DZ_STORE_parameters[] = { &_ZEBRA_DZ_STORE_IXSTOR };
static char *_ZEBRA_DZ_STORE_guidance[] = {
 "Display the structure of the ZEBRA store IXSTOR.",
 "Output the parameters characterizing the store, followed by a",
 "list of all divisions and all link areas associated with the store in",
 "question." };
static KmCommand _ZEBRA_DZ_STORE = {  (KmCommand*)0, "/ZEBRA/DZ/STORE",
 "STORE", 0, 2, 1, 0, _ZEBRA_DZ_STORE_parameters, 0, 0, pazdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _ZEBRA_DZ_STORE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _ZEBRA_DZ_VERIFY_IDIV_type = { "0", "24", "0", "24", 0 };
static KmParameter _ZEBRA_DZ_VERIFY_IDIV = { "IDIV", 4, "Division number ",
 "0", (char*)0, 3, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ZEBRA_DZ_VERIFY_IDIV_type };
static char *_ZEBRA_DZ_VERIFY_CHOPT_range[] = { "C", "L", "S", "U", "F" };
static char *_ZEBRA_DZ_VERIFY_CHOPT_text[] = { "Check chaining of banks only",
 "Check validity of the structural links (implies 'C')",
 "Check the store parameters",
 "Check the validity of the up and origin (implies 'C')",
 "Errors are considered fatal and generate a call to ZFATAL" };
static KmParOption _ZEBRA_DZ_VERIFY_CHOPT_type = {
 _ZEBRA_DZ_VERIFY_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _ZEBRA_DZ_VERIFY_CHOPT = { "CHOPT", 5, "Options", "CLSU",
 (char*)0, 8, 5, _ZEBRA_DZ_VERIFY_CHOPT_range, 5,
 _ZEBRA_DZ_VERIFY_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_ZEBRA_DZ_VERIFY_CHOPT_type };
static KmParameter *_ZEBRA_DZ_VERIFY_parameters[] = { &_ZEBRA_DZ_VERIFY_IDIV,
 &_ZEBRA_DZ_VERIFY_CHOPT };
static char *_ZEBRA_DZ_VERIFY_guidance[] = {
 "Check the structure of one or more ZEBRA divisions.",
 "The verification detail depends on the settings in CHOPT." };
static KmCommand _ZEBRA_DZ_VERIFY = { &_ZEBRA_DZ_STORE, "/ZEBRA/DZ/VERIFY",
 "VERIFY", 0, 2, 2, 0, _ZEBRA_DZ_VERIFY_parameters, 0, 0, pazdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _ZEBRA_DZ_VERIFY_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _ZEBRA_DZ_SNAP_IDIV_type = { "0", "24", "0", "24", 0 };
static KmParameter _ZEBRA_DZ_SNAP_IDIV = { "IDIV", 4, "Division number ", "2",
 (char*)0, 3, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ZEBRA_DZ_SNAP_IDIV_type };
static char *_ZEBRA_DZ_SNAP_CHOPT_range[] = { "M", "E", "F", "K", "L", "W",
 "Z" };
static char *_ZEBRA_DZ_SNAP_CHOPT_text[] = { "Print Map entry for each bank",
 "Extend map entry to dump all links of each bank (otherwise only as many\
 links as will fit on a line)", "Full. Dump all active banks, links and data",
 "Kill. Dropped banks to be treated as active (dropped banks are not normally\
 dumped under D or F option)",
 "Dump all Link areas associated with the store",
 "Dump the Working space, links and data",
 "Dump the information in hexadecimal." };
static KmParOption _ZEBRA_DZ_SNAP_CHOPT_type = { _ZEBRA_DZ_SNAP_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _ZEBRA_DZ_SNAP_CHOPT = { "CHOPT", 5, "Options", "M",
 (char*)0, 8, 7, _ZEBRA_DZ_SNAP_CHOPT_range, 7, _ZEBRA_DZ_SNAP_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_ZEBRA_DZ_SNAP_CHOPT_type };
static KmParameter *_ZEBRA_DZ_SNAP_parameters[] = { &_ZEBRA_DZ_SNAP_IDIV,
 &_ZEBRA_DZ_SNAP_CHOPT };
static char *_ZEBRA_DZ_SNAP_guidance[] = { "Snap of one or more divisions.",
 "Provides a snapshot of one or more divisions in a ZEBRA store.",
 "The kind of information provided is controlled by CHOPT." };
static KmCommand _ZEBRA_DZ_SNAP = { &_ZEBRA_DZ_VERIFY, "/ZEBRA/DZ/SNAP",
 "SNAP", 0, 2, 2, 0, _ZEBRA_DZ_SNAP_parameters, 0, 0, pazdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _ZEBRA_DZ_SNAP_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ZEBRA_DZ_SURV_NAME = { "NAME", 4, "Bank name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _ZEBRA_DZ_SURV_NUMBER_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _ZEBRA_DZ_SURV_NUMBER = { "NUMBER", 6, "Bank number", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ZEBRA_DZ_SURV_NUMBER_type };
static KmParameter *_ZEBRA_DZ_SURV_parameters[] = { &_ZEBRA_DZ_SURV_NAME,
 &_ZEBRA_DZ_SURV_NUMBER };
static char *_ZEBRA_DZ_SURV_guidance[] = {
 "Print a survey of the structure identified by NAME, NUMBER." };
static KmCommand _ZEBRA_DZ_SURV = { &_ZEBRA_DZ_SNAP, "/ZEBRA/DZ/SURV", "SURV",
 0, 2, 2, 1, _ZEBRA_DZ_SURV_parameters, 0, 0, pazdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_DZ_SURV_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ZEBRA_DZ_SHOW_NAME = { "NAME", 4, "Bank name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _ZEBRA_DZ_SHOW_NUMBER_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _ZEBRA_DZ_SHOW_NUMBER = { "NUMBER", 6, "Bank number", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ZEBRA_DZ_SHOW_NUMBER_type };
static char *_ZEBRA_DZ_SHOW_CHOPT_range[] = { "B", "S", "V", "D", "L", "Z" };
static char *_ZEBRA_DZ_SHOW_CHOPT_text[] = { "Print the bank.",
 "Print the bank contents from left to right Sideways with up to ten elements\
 per line.", "Print the vertical (down) structure.",
 "Print the bank contents from top to bottom Downwards with five elements per\
 line.", "Print the linear structure.",
 "Print the data part of each bank in hexadecimal format" };
static KmParOption _ZEBRA_DZ_SHOW_CHOPT_type = { _ZEBRA_DZ_SHOW_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _ZEBRA_DZ_SHOW_CHOPT = { "CHOPT", 5, "Options", "BSV",
 (char*)0, 8, 6, _ZEBRA_DZ_SHOW_CHOPT_range, 6, _ZEBRA_DZ_SHOW_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_ZEBRA_DZ_SHOW_CHOPT_type };
static KmParameter *_ZEBRA_DZ_SHOW_parameters[] = { &_ZEBRA_DZ_SHOW_NAME,
 &_ZEBRA_DZ_SHOW_NUMBER, &_ZEBRA_DZ_SHOW_CHOPT };
static char *_ZEBRA_DZ_SHOW_guidance[] = {
 "Display the contents of a bank or a data structure",
 "identified by its NAME and NUMBER.",
 "The output format of the data part is controlled by the internal",
 "or external I/O characteristic." };
static KmCommand _ZEBRA_DZ_SHOW = { &_ZEBRA_DZ_SURV, "/ZEBRA/DZ/SHOW", "SHOW",
 0, 2, 3, 1, _ZEBRA_DZ_SHOW_parameters, 0, 0, pazdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _ZEBRA_DZ_SHOW_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_ZEBRA_DZ_guidance[] = { "ZEBRA/DZ package: debugging." };
static KmMenu _ZEBRA_DZ = {  (KmMenu*)0,  (KmMenu*)0, "/ZEBRA/DZ", "DZ", 2,
 &_ZEBRA_DZ_SHOW, 1, _ZEBRA_DZ_guidance, 0, (char**)0, 0, (char**)0 };

static char *_ZEBRA_FZ_guidance[] = {
 "ZEBRA/FZ package: sequential access Input/Output." };
static KmMenu _ZEBRA_FZ = { &_ZEBRA_DZ,  (KmMenu*)0, "/ZEBRA/FZ", "FZ", 2,
 &_ZEBRA_FZ_FILE, 1, _ZEBRA_FZ_guidance, 0, (char**)0, 0, (char**)0 };

static char *_ZEBRA_RZ_guidance[] = {
 "ZEBRA/RZ package: direct access Input/Output." };
static KmMenu _ZEBRA_RZ = { &_ZEBRA_FZ,  (KmMenu*)0, "/ZEBRA/RZ", "RZ", 2,
 &_ZEBRA_RZ_FILE, 1, _ZEBRA_RZ_guidance, 0, (char**)0, 0, (char**)0 };

static char *_ZEBRA_guidance[] = {
 "Interfaces to the ZEBRA RZ, FZ and DZ packages." };
static KmMenu _ZEBRA = {  (KmMenu*)0, &_ZEBRA_RZ, "/ZEBRA", "ZEBRA", 1,
 (KmCommand*)0, 1, _ZEBRA_guidance, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_ZEBRA, 950303 );
}


#ifdef F77_LCASE
#  define fordef_ fordef
#  define pasigm_ pasigm
#  define pafort_ pafort
#  define pahelp_ pahelp
#endif

#ifdef F77_UCASE
#  define fordef_ FORDEF
#  define pasigm_ PASIGM
#  define pafort_ PAFORT
#  define pahelp_ PAHELP
#endif

#ifdef IBM370
#  pragma linkage(FORDEF,FORTRAN)
#  pragma linkage(PASIGM,FORTRAN)
#  pragma linkage(PAFORT,FORTRAN)
#  pragma linkage(PAHELP,FORTRAN)
#endif

extern void fordef_();
extern void pasigm_();
extern void pafort_();
extern void pahelp_();

void fordef_()
{

static KmParameter _FORTRAN_SIGMA_EXPR = { "EXPR", 4, "Expression", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_FORTRAN_SIGMA_parameters[] = { &_FORTRAN_SIGMA_EXPR };
static char *_FORTRAN_SIGMA_guidance[] = { "Invoke the SIGMA package.",
 "SIGMA is an array manipulation package using its own",
 "vector-oriented language, outside the PAW command conventions.",
 "SIGMA may be invoked in one of the three following ways:",
 " 1- Using the KUIP $SIGMA function. Example:",
 "    PAW > Vector/Create x(10) r 1 2 3 4 5 6 7 8 9 10",
 "    PAW > Graph 10 x $sigma(sqrt(x))", "",
 " 2- Using the SIGMA command. Example:", "    PAW > sigma x=array(10,1#10)",
 "    PAW > sigma y=sqrt(x)", "    PAW > Graph 10 x y", "",
 " 3- Using the APPLication command. Example:", "    PAW > APPLication SIGMA",
 "    SIGMA > x=array(10,1#10)", "    SIGMA > y=sqrt(x)", "    SIGMA > exit",
 "    PAW > Graph 10 x y" };
static KmCommand _FORTRAN_SIGMA = {  (KmCommand*)0, "/FORTRAN/SIGMA", "SIGMA",
 0, 1, 1, 0, _FORTRAN_SIGMA_parameters, 0, 0, pasigm_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 19, _FORTRAN_SIGMA_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _FORTRAN_REWIND_LUN_type = { "1", "128", "1", "128", 0 };
static KmParameter _FORTRAN_REWIND_LUN = { "LUN", 3, "Logical unit number",
 (char*)0, (char*)0, 4, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_FORTRAN_REWIND_LUN_type };
static KmParameter *_FORTRAN_REWIND_parameters[] = { &_FORTRAN_REWIND_LUN };
static char *_FORTRAN_REWIND_guidance[] = { "Rewind the file on unit LUN." };
static KmCommand _FORTRAN_REWIND = { &_FORTRAN_SIGMA, "/FORTRAN/REWIND",
 "REWIND", 0, 1, 1, 1, _FORTRAN_REWIND_parameters, 0, 0, pafort_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _FORTRAN_REWIND_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_FORTRAN_UNITS_guidance[] = {
 "List all Input/Output logical units currently open.",
 "The files attached to them are also shown." };
static KmCommand _FORTRAN_UNITS = { &_FORTRAN_REWIND, "/FORTRAN/UNITS",
 "UNITS", 0, 1, 0, 0, (KmParameter**)0, 0, 0, pafort_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _FORTRAN_UNITS_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _FORTRAN_CLOSE_LUN_type = { "0", "128", "0", "128", 0 };
static KmParameter _FORTRAN_CLOSE_LUN = { "LUN", 3, "Logical unit number",
 (char*)0, (char*)0, 4, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_FORTRAN_CLOSE_LUN_type };
static KmParameter *_FORTRAN_CLOSE_parameters[] = { &_FORTRAN_CLOSE_LUN };
static char *_FORTRAN_CLOSE_guidance[] = { "Close the file on unit LUN.",
 "If the file has been opened with HISTO/FILE, PICTURE/FILE, etc, then",
 "before closing the unit, PAW will close correctly the file with",
 "CALL HREND or FZENDI(O), ICLWK, etc.",
 "Giving 0 as unit will close all open files." };
static KmCommand _FORTRAN_CLOSE = { &_FORTRAN_UNITS, "/FORTRAN/CLOSE",
 "CLOSE", 0, 1, 1, 1, _FORTRAN_CLOSE_parameters, 0, 0, pafort_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _FORTRAN_CLOSE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _FORTRAN_FILE_LUN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _FORTRAN_FILE_LUN = { "LUN", 3, "Logical unit number",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_FORTRAN_FILE_LUN_type };
static KmParameter _FORTRAN_FILE_FNAME = { "FNAME", 5, "File name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_FORTRAN_FILE_STATUS_range[] = { "OLD", "APPEND", "NEW",
 "UNKNOWN", "DONTKNOW" };
static char *_FORTRAN_FILE_STATUS_text[] = {
 "Open existing file for reading.", "Open existing file and position at EOF.",
 "Create new file; error if already existing.",
 "Open existing or create new file.",
 "Like UNKNOWN except on VMS opens highest cycle." };
static KmParOption _FORTRAN_FILE_STATUS_type = { _FORTRAN_FILE_STATUS_text,
 (int*)0, (int*)0 };
static KmParameter _FORTRAN_FILE_STATUS = { "STATUS", 6, "File status",
 "DONTKNOW", (char*)0, 8, 5, _FORTRAN_FILE_STATUS_range, 5,
 _FORTRAN_FILE_STATUS_range, (KmParFlag)0, KmTYPE_OPTION,
 &_FORTRAN_FILE_STATUS_type };
static KmParameter *_FORTRAN_FILE_parameters[] = { &_FORTRAN_FILE_LUN,
 &_FORTRAN_FILE_FNAME, &_FORTRAN_FILE_STATUS };
static char *_FORTRAN_FILE_guidance[] = {
 "Open a FORTRAN formatted text file.",
 "UNKNOWN opens a file for write access without flagging an error if the",
 "file already exists.  On VMS a new cycle is created.",
 "DONTKNOW is the same as UNKNOWN except on VMS",
 "where the highest cycle is opened.",
 "This option should be used if it is not yet known whether the file will",
 "be read or written." };
static KmCommand _FORTRAN_FILE = { &_FORTRAN_CLOSE, "/FORTRAN/FILE", "FILE",
 0, 1, 3, 2, _FORTRAN_FILE_parameters, 0, 0, pafort_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 7, _FORTRAN_FILE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _FORTRAN_LOOP_NTIMES_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _FORTRAN_LOOP_NTIMES = { "NTIMES", 6, "Number of calls",
 "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_FORTRAN_LOOP_NTIMES_type };
static KmParameter _FORTRAN_LOOP_UROUT = { "UROUT", 5, "User routine",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_FORTRAN_LOOP_parameters[] = { &_FORTRAN_LOOP_NTIMES,
 &_FORTRAN_LOOP_UROUT };
static char *_FORTRAN_LOOP_guidance[] = {
 "The routine UROUT is called NTIMES times.",
 "See command CALL for explanation of UROUT." };
static KmCommand _FORTRAN_LOOP = { &_FORTRAN_FILE, "/FORTRAN/LOOP", "LOOP", 0,
 1, 2, 2, _FORTRAN_LOOP_parameters, 0, 0, pafort_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _FORTRAN_LOOP_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _FORTRAN_CALL_UROUT = { "UROUT", 5, "User routine",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_FORTRAN_CALL_parameters[] = { &_FORTRAN_CALL_UROUT };
static char *_FORTRAN_CALL_guidance[] = { "Execute the routine UROUT.",
 "UROUT may be a routine compiled and linked with PAW.",
 "For example : CALL HPRINT(10).", "",
 "UROUT may also be the name of a file which can be edited interactively",
 "with the command EDIT. For example if file UROUT.FOR contains:",
 "     SUBROUTINE UROUT(N)", "     SUM=0.", "     DO 10 I=1,N",
 "       SUM=SUM+I", "  10 CONTINUE", "     PRINT *,SUM", "     END",
 "Then one can type CALL UROUT.FOR(10). The routine UROUT may also",
 "contain references to the library routines mentioned below.", "",
 "The functions $CALL, $ICALL, and $DCALL allow to call REAL, INTEGER,",
 "and DOUBLE PRECISION functions, respectively.",
 "The function call must be enclosed in quotes, for example:",
 "     $CALL('fun.f(1.5)')", "with file fun.f containing",
 "     FUNCTION FUN(X)", "     FUN=X**2", "     END", "",
 "The following routines from the CERN Program Library can be called:" };
static KmCommand _FORTRAN_CALL = { &_FORTRAN_LOOP, "/FORTRAN/CALL", "CALL", 0,
 1, 1, 1, _FORTRAN_CALL_parameters, 0, 0, pafort_, (IntFunc*)0, pahelp_,
 (pCharFunc*)0, 26, _FORTRAN_CALL_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_FORTRAN_COMIS_guidance[] = {
 "Invoke the COMIS FORTRAN interpreter.",
 "COMIS allows to execute FORTRAN routines without recompiling",
 "and relinking. It communicates",
 "with PAW commands through vectors and functions. COMIS has its",
 "PAW-independent command structure.", "Example in command mode:",
 " PAW > Comis", " CS >    do 10 i=1,10", " MND>       x=sqrt(i)*10.",
 " MND>       print *,i,x", " MND> 10 continue", " MND>    END", " CS > quit",
 " PAW >", "COMIS code may be inserted into a macro. Example:",
 " Vector/Create Y(10) r 1 2 3 4 5 6 7 8 9 10", " *",
 " *  In the following COMIS code, the statement 'Vector Y' declares",
 " *  to COMIS an existing KUIP vector. KUIP dimension is assumed.",
 " *  The statement 'Vector X(10)' creates a new KUIP vector.",
 " *  (Note that SUBROUTINEs must be declared before the MAIN program)",
 " *  (KUIP vectors cannot be created into the MAIN program)", " *",
 " APPLIcation COMIS QUIT", "       SUBROUTINE DEMO", "       Vector Y",
 "       Vector X(10)", "       do 10 i=1,10", "          XX=i",
 "          X(i)=Y(i)*sqrt(XX)*10.", "   10  CONTINUE", "       END",
 "       CALL DEMO", "       END", " QUIT",
 " Vector/print X       | Print KUIP vector created by COMIS" };
static KmCommand _FORTRAN_COMIS = { &_FORTRAN_CALL, "/FORTRAN/COMIS", "COMIS",
 0, 1, 0, 0, (KmParameter**)0, 0, 0, pafort_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 36, _FORTRAN_COMIS_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_FORTRAN_HMINUIT_guidance[] = {
 "To input commands for Interactive MINUIT in a macro.", "Example:",
 " Application HMINUIT EXIT", " SET EPS 1.E-14", " MIGRAD", " SET PRIN 2",
 " MINOS", " EXIT", " Histo/fit 10 g m" };
static KmCommand _FORTRAN_HMINUIT = { &_FORTRAN_COMIS, "/FORTRAN/HMINUIT",
 "HMINUIT", 0, 1, 0, 0, (KmParameter**)0, 0, 0, pafort_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 9, _FORTRAN_HMINUIT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_FORTRAN_guidance[] = {
 "Interface to MINUIT, COMIS, SIGMA and FORTRAN Input/Output." };
static KmMenu _FORTRAN = {  (KmMenu*)0,  (KmMenu*)0, "/FORTRAN", "FORTRAN", 1,
 &_FORTRAN_HMINUIT, 1, _FORTRAN_guidance, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_FORTRAN, 950303 );
}


#ifdef F77_LCASE
#  define netdef_ netdef
#  define papiaf_ papiaf
#  define rlogin_ rlogin
#  define rshell_ rshell
#endif

#ifdef F77_UCASE
#  define netdef_ NETDEF
#  define papiaf_ PAPIAF
#  define rlogin_ RLOGIN
#  define rshell_ RSHELL
#endif

#ifdef IBM370
#  pragma linkage(NETDEF,FORTRAN)
#  pragma linkage(PAPIAF,FORTRAN)
#  pragma linkage(RLOGIN,FORTRAN)
#  pragma linkage(RSHELL,FORTRAN)
#endif

extern void netdef_();
extern void papiaf_();
extern void rlogin_();
extern void rshell_();

void netdef_()
{

static char *_NETWORK_PIAF_DISCONNECT_guidance[] = {
 "Close the connection to the Piaf server." };
static KmCommand _NETWORK_PIAF_DISCONNECT = {  (KmCommand*)0,
 "/NETWORK/PIAF/DISCONNECT", "DISCONNECT", 0, 2, 0, 0, (KmParameter**)0, 0, 0,
 papiaf_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _NETWORK_PIAF_DISCONNECT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _NETWORK_PIAF_LOGLEVEL_LEVEL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _NETWORK_PIAF_LOGLEVEL_LEVEL = { "LEVEL", 5, "Log level",
 "0", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NETWORK_PIAF_LOGLEVEL_LEVEL_type };
static KmParameter *_NETWORK_PIAF_LOGLEVEL_parameters[] = {
 &_NETWORK_PIAF_LOGLEVEL_LEVEL };
static char *_NETWORK_PIAF_LOGLEVEL_guidance[] = {
 "Set the level of diagnostic output from the Piaf server." };
static KmCommand _NETWORK_PIAF_LOGLEVEL = { &_NETWORK_PIAF_DISCONNECT,
 "/NETWORK/PIAF/LOGLEVEL", "LOGLEVEL", 0, 2, 1, 1,
 _NETWORK_PIAF_LOGLEVEL_parameters, 0, 0, papiaf_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _NETWORK_PIAF_LOGLEVEL_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_NETWORK_PIAF_MODE_OPTION_range[] = { "?", "SEQ", "PAR" };
static char *_NETWORK_PIAF_MODE_OPTION_text[] = { "Inquire the current mode.",
 "Set sequential processing mode.", "Set parallel processing mode." };
static KmParOption _NETWORK_PIAF_MODE_OPTION_type = {
 _NETWORK_PIAF_MODE_OPTION_text, (int*)0, (int*)0 };
static KmParameter _NETWORK_PIAF_MODE_OPTION = { "OPTION", 6,
 "Processing mode", "?", (char*)0, 8, 3, _NETWORK_PIAF_MODE_OPTION_range, 3,
 _NETWORK_PIAF_MODE_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_NETWORK_PIAF_MODE_OPTION_type };
static KmParameter *_NETWORK_PIAF_MODE_parameters[] = {
 &_NETWORK_PIAF_MODE_OPTION };
static char *_NETWORK_PIAF_MODE_guidance[] = {
 "Inquire or change the processing mode of the Piaf server.",
 "In parallel mode the Piaf server uses slave servers to process",
 "Ntuple requests on all available machines in parallel.", "",
 "With certain types of COMIS selection functions,",
 "e.g. when reading from an external file for each event,",
 "parallel processing is not possible.",
 "The Piaf server should be switched to sequential mode,",
 "i.e. the master server alone processes the Ntuple request." };
static KmCommand _NETWORK_PIAF_MODE = { &_NETWORK_PIAF_LOGLEVEL,
 "/NETWORK/PIAF/MODE", "MODE", 0, 2, 1, 0, _NETWORK_PIAF_MODE_parameters, 0,
 0, papiaf_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 9,
 _NETWORK_PIAF_MODE_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_NETWORK_PIAF_STATUS_guidance[] = {
 "Inquire the status of the Piaf server." };
static KmCommand _NETWORK_PIAF_STATUS = { &_NETWORK_PIAF_MODE,
 "/NETWORK/PIAF/STATUS", "STATUS", 0, 2, 0, 0, (KmParameter**)0, 0, 0,
 papiaf_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _NETWORK_PIAF_STATUS_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _NETWORK_PIAF_MESSAGE_MESS = { "MESS", 4, "Message",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_NETWORK_PIAF_MESSAGE_parameters[] = {
 &_NETWORK_PIAF_MESSAGE_MESS };
static char *_NETWORK_PIAF_MESSAGE_guidance[] = { "Send a message to Piaf." };
static KmCommand _NETWORK_PIAF_MESSAGE = { &_NETWORK_PIAF_STATUS,
 "/NETWORK/PIAF/MESSAGE", "MESSAGE", 0, 2, 1, 1,
 _NETWORK_PIAF_MESSAGE_parameters, 0, 0, papiaf_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _NETWORK_PIAF_MESSAGE_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NETWORK_PIAF_RMDIR_DIR = { "DIR", 3, "Directory name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_NETWORK_PIAF_RMDIR_parameters[] = {
 &_NETWORK_PIAF_RMDIR_DIR };
static char *_NETWORK_PIAF_RMDIR_guidance[] = { "Delete a directory on Piaf."
 };
static KmCommand _NETWORK_PIAF_RMDIR = { &_NETWORK_PIAF_MESSAGE,
 "/NETWORK/PIAF/RMDIR", "RMDIR", 0, 2, 1, 1, _NETWORK_PIAF_RMDIR_parameters,
 0, 0, papiaf_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _NETWORK_PIAF_RMDIR_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _NETWORK_PIAF_MKDIR_DIR = { "DIR", 3, "Directory name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_NETWORK_PIAF_MKDIR_parameters[] = {
 &_NETWORK_PIAF_MKDIR_DIR };
static char *_NETWORK_PIAF_MKDIR_guidance[] = {
 "Create a new directory on Piaf." };
static KmCommand _NETWORK_PIAF_MKDIR = { &_NETWORK_PIAF_RMDIR,
 "/NETWORK/PIAF/MKDIR", "MKDIR", 0, 2, 1, 1, _NETWORK_PIAF_MKDIR_parameters,
 0, 0, papiaf_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _NETWORK_PIAF_MKDIR_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_NETWORK_PIAF_PWD_guidance[] = {
 "Show current Piaf working directory." };
static KmCommand _NETWORK_PIAF_PWD = { &_NETWORK_PIAF_MKDIR,
 "/NETWORK/PIAF/PWD", "PWD", 0, 2, 0, 0, (KmParameter**)0, 0, 0, papiaf_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1, _NETWORK_PIAF_PWD_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NETWORK_PIAF_CP_FROM = { "FROM", 4, "Old file name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _NETWORK_PIAF_CP_TO = { "TO", 2, "New file name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_NETWORK_PIAF_CP_parameters[] = { &_NETWORK_PIAF_CP_FROM,
 &_NETWORK_PIAF_CP_TO };
static char *_NETWORK_PIAF_CP_guidance[] = { "Copy a Piaf file to a new file."
 };
static KmCommand _NETWORK_PIAF_CP = { &_NETWORK_PIAF_PWD, "/NETWORK/PIAF/CP",
 "CP", 0, 2, 2, 2, _NETWORK_PIAF_CP_parameters, 0, 0, papiaf_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _NETWORK_PIAF_CP_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NETWORK_PIAF_MV_FROM = { "FROM", 4, "Old file name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _NETWORK_PIAF_MV_TO = { "TO", 2, "New file name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_NETWORK_PIAF_MV_parameters[] = { &_NETWORK_PIAF_MV_FROM,
 &_NETWORK_PIAF_MV_TO };
static char *_NETWORK_PIAF_MV_guidance[] = { "Rename a Piaf file." };
static KmCommand _NETWORK_PIAF_MV = { &_NETWORK_PIAF_CP, "/NETWORK/PIAF/MV",
 "MV", 0, 2, 2, 2, _NETWORK_PIAF_MV_parameters, 0, 0, papiaf_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _NETWORK_PIAF_MV_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NETWORK_PIAF_RM_FILE = { "FILE", 4, "File name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_NETWORK_PIAF_RM_parameters[] = { &_NETWORK_PIAF_RM_FILE };
static char *_NETWORK_PIAF_RM_guidance[] = { "Delete a Piaf file." };
static KmCommand _NETWORK_PIAF_RM = { &_NETWORK_PIAF_MV, "/NETWORK/PIAF/RM",
 "RM", 0, 2, 1, 1, _NETWORK_PIAF_RM_parameters, 0, 0, papiaf_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _NETWORK_PIAF_RM_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NETWORK_PIAF_CAT_FILE = { "FILE", 4, "File name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_NETWORK_PIAF_CAT_parameters[] = { &_NETWORK_PIAF_CAT_FILE
 };
static char *_NETWORK_PIAF_CAT_guidance[] = {
 "Print a Piaf file on the terminal." };
static KmCommand _NETWORK_PIAF_CAT = { &_NETWORK_PIAF_RM, "/NETWORK/PIAF/CAT",
 "CAT", 0, 2, 1, 1, _NETWORK_PIAF_CAT_parameters, 0, 0, papiaf_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _NETWORK_PIAF_CAT_guidance, 0, (char**)0,
 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NETWORK_PIAF_LS_FILES = { "FILES", 5, "File pattern", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_NETWORK_PIAF_LS_parameters[] = { &_NETWORK_PIAF_LS_FILES
 };
static char *_NETWORK_PIAF_LS_guidance[] = {
 "List files stored on the Piaf server." };
static KmCommand _NETWORK_PIAF_LS = { &_NETWORK_PIAF_CAT, "/NETWORK/PIAF/LS",
 "LS", 0, 2, 1, 0, _NETWORK_PIAF_LS_parameters, 0, 0, papiaf_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _NETWORK_PIAF_LS_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NETWORK_PIAF_PUT_LOCAL = { "LOCAL", 5, "Local file name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _NETWORK_PIAF_PUT_REMOTE = { "REMOTE", 6,
 "Remote file name", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_NETWORK_PIAF_PUT_FORMAT_range[] = { "T", "RZ", "BIN" };
static char *_NETWORK_PIAF_PUT_FORMAT_text[] = { "Text file.",
 "Zebra RZ file in exchange format.", "Binary file." };
static KmParOption _NETWORK_PIAF_PUT_FORMAT_type = {
 _NETWORK_PIAF_PUT_FORMAT_text, (int*)0, (int*)0 };
static KmParameter _NETWORK_PIAF_PUT_FORMAT = { "FORMAT", 6, "Text or binary",
 "RZ", (char*)0, 8, 3, _NETWORK_PIAF_PUT_FORMAT_range, 3,
 _NETWORK_PIAF_PUT_FORMAT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_NETWORK_PIAF_PUT_FORMAT_type };
static KmParameter *_NETWORK_PIAF_PUT_parameters[] = {
 &_NETWORK_PIAF_PUT_LOCAL, &_NETWORK_PIAF_PUT_REMOTE,
 &_NETWORK_PIAF_PUT_FORMAT };
static char *_NETWORK_PIAF_PUT_guidance[] = {
 "Copy a file from the client system to the Piaf server.",
 "If not specified the remote file name will be same as the local file name.",
 "Note for VMS: Avoid text files with variable record length.",
 "Use Stream_LF format instead." };
static KmCommand _NETWORK_PIAF_PUT = { &_NETWORK_PIAF_LS, "/NETWORK/PIAF/PUT",
 "PUT", 0, 2, 3, 1, _NETWORK_PIAF_PUT_parameters, 0, 0, papiaf_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _NETWORK_PIAF_PUT_guidance, 0, (char**)0,
 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NETWORK_PIAF_GET_REMOTE = { "REMOTE", 6,
 "Remote file name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _NETWORK_PIAF_GET_LOCAL = { "LOCAL", 5, "Local file name",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_NETWORK_PIAF_GET_FORMAT_range[] = { "T", "RZ", "BIN" };
static char *_NETWORK_PIAF_GET_FORMAT_text[] = { "Text file.",
 "Zebra RZ file in exchange format.",
 "Binary file with record length given by RECL." };
static KmParOption _NETWORK_PIAF_GET_FORMAT_type = {
 _NETWORK_PIAF_GET_FORMAT_text, (int*)0, (int*)0 };
static KmParameter _NETWORK_PIAF_GET_FORMAT = { "FORMAT", 6, "Text or binary",
 "RZ", (char*)0, 8, 3, _NETWORK_PIAF_GET_FORMAT_range, 3,
 _NETWORK_PIAF_GET_FORMAT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_NETWORK_PIAF_GET_FORMAT_type };
static KmParInt    _NETWORK_PIAF_GET_RECL_type = { "0", (char*)0, "0",
 (char*)0, 0 };
static KmParameter _NETWORK_PIAF_GET_RECL = { "RECL", 4,
 "Record length in bytes", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_NETWORK_PIAF_GET_RECL_type };
static KmParameter *_NETWORK_PIAF_GET_parameters[] = {
 &_NETWORK_PIAF_GET_REMOTE, &_NETWORK_PIAF_GET_LOCAL,
 &_NETWORK_PIAF_GET_FORMAT, &_NETWORK_PIAF_GET_RECL };
static char *_NETWORK_PIAF_GET_guidance[] = {
 "Copy a file from the Piaf server to the client system.",
 "If not specified the local file name will be same as the remote file name.",
 "RECL needs to be specified only for BIN format.",
 "For IBM only: A text file with RECL=0 is written in V-format.",
 "Otherwise it is written in F-format with the given LRECL." };
static KmCommand _NETWORK_PIAF_GET = { &_NETWORK_PIAF_PUT,
 "/NETWORK/PIAF/GET", "GET", 0, 2, 4, 1, _NETWORK_PIAF_GET_parameters, 0, 0,
 papiaf_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 5,
 _NETWORK_PIAF_GET_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _NETWORK_PIAF_STAGE_SOURCE = { "SOURCE", 6,
 "Source file identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _NETWORK_PIAF_STAGE_TARGET = { "TARGET", 6,
 "Target file name", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_NETWORK_PIAF_STAGE_OPTION_range[] = { "N" };
static char *_NETWORK_PIAF_STAGE_OPTION_text[] = {
 "NoWait. Submit the request to the staging system and return immediately." };
static KmParOption _NETWORK_PIAF_STAGE_OPTION_type = {
 _NETWORK_PIAF_STAGE_OPTION_text, (int*)0, (int*)0 };
static KmParameter _NETWORK_PIAF_STAGE_OPTION = { "OPTION", 6, "Options", " ",
 (char*)0, 8, 1, _NETWORK_PIAF_STAGE_OPTION_range, 1,
 _NETWORK_PIAF_STAGE_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_NETWORK_PIAF_STAGE_OPTION_type };
static KmParameter *_NETWORK_PIAF_STAGE_parameters[] = {
 &_NETWORK_PIAF_STAGE_SOURCE, &_NETWORK_PIAF_STAGE_TARGET,
 &_NETWORK_PIAF_STAGE_OPTION };
static char *_NETWORK_PIAF_STAGE_guidance[] = {
 "Stage an Ntuple file on the Piaf server.",
 "The source file identifier can be the name of a local file on the client",
 "system, a Fatmen path, or a tape identifier.",
 "If the target file name is not specified it is constructed from the",
 "source identifier.", "",
 "Unless the option N is used the STAGE command waits until the staging",
 "is completed and the file is ready to be used." };
static KmCommand _NETWORK_PIAF_STAGE = { &_NETWORK_PIAF_GET,
 "/NETWORK/PIAF/STAGE", "STAGE", 0, 2, 3, 1, _NETWORK_PIAF_STAGE_parameters,
 0, 0, papiaf_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 8,
 _NETWORK_PIAF_STAGE_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _NETWORK_PIAF_CONNECT_SERVER = { "SERVER", 6,
 "Server name", "piaf", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _NETWORK_PIAF_CONNECT_NODE = { "NODE", 4, "Front-end node",
 "piaf1.cern.ch", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_NETWORK_PIAF_CONNECT_parameters[] = {
 &_NETWORK_PIAF_CONNECT_SERVER, &_NETWORK_PIAF_CONNECT_NODE };
static char *_NETWORK_PIAF_CONNECT_guidance[] = {
 "Establish a connection to the Piaf server.",
 "Subsequent HISTO/FILE commands can refer to files on the server",
 "using path names '//piaf/file.hbook'." };
static KmCommand _NETWORK_PIAF_CONNECT = { &_NETWORK_PIAF_STAGE,
 "/NETWORK/PIAF/CONNECT", "CONNECT", 0, 2, 2, 0,
 _NETWORK_PIAF_CONNECT_parameters, 0, 0, rlogin_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 3, _NETWORK_PIAF_CONNECT_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static char *_NETWORK_PIAF_guidance[] = {
 "To establish and control the connection to the Piaf server.",
 "The Parallel Interactive Analysis Facility (Piaf) is a cluster of",
 "5 high-performance HP workstations.", "",
 "A locally running PAW session (client) connected to the Piaf server",
 "can access Hbook RZ files stored on the server side in a transparent way.",
 "Commands with high CPU or I/O requirements, e.g. NT/PLOT and NT/PROJECT",
 "are processed by the server and only the resulting histograms etc. are",
 "sent back to the client.", "",
 "In order to use the Piaf server the PAW client must have been compiled",
 "with the communications option CZ using TCP/IP as transport protocol." };
static KmMenu _NETWORK_PIAF = {  (KmMenu*)0,  (KmMenu*)0, "/NETWORK/PIAF",
 "PIAF", 2, &_NETWORK_PIAF_CONNECT, 12, _NETWORK_PIAF_guidance, 0, (char**)0,
 0, (char**)0 };

static KmParameter _NETWORK_RSHELL_MESSAGE = { "MESSAGE", 7,
 "Message to remote host", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_NETWORK_RSHELL_parameters[] = { &_NETWORK_RSHELL_MESSAGE
 };
static char *_NETWORK_RSHELL_guidance[] = {
 "Send MESSAGE to current remote host.",
 "Note that the Current Directory must be //HOST (see RLOGIN).",
 "Some PAW commands (Histo/Plot, Histo/List) can communicate",
 "directly with HOST." };
static KmCommand _NETWORK_RSHELL = {  (KmCommand*)0, "/NETWORK/RSHELL",
 "RSHELL", 0, 1, 1, 1, _NETWORK_RSHELL_parameters, 0, 0, rshell_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _NETWORK_RSHELL_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NETWORK_RLOGIN_HOST = { "HOST", 4, "Host name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_NETWORK_RLOGIN_parameters[] = { &_NETWORK_RLOGIN_HOST };
static char *_NETWORK_RLOGIN_guidance[] = {
 "Start a communication with a remote machine HOST.",
 "Current Directory will be changed to //HOST." };
static KmCommand _NETWORK_RLOGIN = { &_NETWORK_RSHELL, "/NETWORK/RLOGIN",
 "RLOGIN", 0, 1, 1, 1, _NETWORK_RLOGIN_parameters, 0, 0, rlogin_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _NETWORK_RLOGIN_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_NETWORK_guidance[] = { "To access files on remote computers.",
 "To send messages to a remote process (ZEBRA server)" };
static KmMenu _NETWORK = {  (KmMenu*)0, &_NETWORK_PIAF, "/NETWORK", "NETWORK",
 1, &_NETWORK_RLOGIN, 2, _NETWORK_guidance, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_NETWORK, 950303 );
}


#ifdef F77_LCASE
#  define pvedef_ pvedef
#  define pafitv_ pafitv
#  define pavect_ pavect
#  define pavercmd_ pavercmd
#  define bugreprt_ bugreprt
#endif

#ifdef F77_UCASE
#  define pvedef_ PVEDEF
#  define pafitv_ PAFITV
#  define pavect_ PAVECT
#  define pavercmd_ PAVERCMD
#  define bugreprt_ BUGREPRT
#endif

#ifdef IBM370
#  pragma linkage(PVEDEF,FORTRAN)
#  pragma linkage(PAFITV,FORTRAN)
#  pragma linkage(PAVECT,FORTRAN)
#  pragma linkage(PAVERCMD,FORTRAN)
#  pragma linkage(BUGREPRT,FORTRAN)
#endif

extern void pvedef_();
extern void pafitv_();
extern void pavect_();
extern void pavercmd_();
extern void bugreprt_();

void pvedef_()
{

static KmParameter _VECTOR_FIT_X = { "X", 1, "Vector of X coordinates",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _VECTOR_FIT_Y = { "Y", 1, "Vector of Y coordinates",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _VECTOR_FIT_EY = { "EY", 2, "Vector of errors on Y", "?",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter _VECTOR_FIT_FUNC = { "FUNC", 4, "Function name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_VECTOR_FIT_CHOPT_range[] = { "", "0", "N", "Q", "V", "B", "L",
 "D", "W", "M", "E", "Z" };
static char *_VECTOR_FIT_CHOPT_text[] = {
 "Do the fit, plot the result and print the parameters.",
 "Do not plot the result of the fit. By default the fitted function is drawn\
 unless the option 'N' below is specified.",
 "Do not store the result of the fit bin by bin with the histogram. By default\
 the function is calculated at the middle of each bin and the fit results\
 stored with the histogram data structure.", "Quiet mode. No print",
 "Verbose mode. Results after each iteration are printed By default only final\
 results are printed.",
 "Some or all parameters are bounded. The vectors STEP,PMIN,PMAX must be\
 specified. Default is: All parameters vary freely.",
 "Use Log Likelihood. Default is chisquare method.",
 "The user is assumed to compute derivatives analytically using the routine\
 HDERIV. By default, derivatives are computed numerically.",
 "Sets weights equal to 1. Default weights taken from the square root of the\
 contents or from HPAKE/HBARX (PUT/ERRORS).",
 "The interactive Minuit is invoked.",
 "Performs a better Error evaluation (MIGRAD + HESSE + MINOS).",
 "FUNC is the user fitting model" };
static KmParOption _VECTOR_FIT_CHOPT_type = { _VECTOR_FIT_CHOPT_text, (int*)0,
 (int*)0 };
static KmParameter _VECTOR_FIT_CHOPT = { "CHOPT", 5, "Character options", " ",
 (char*)0, 8, 12, _VECTOR_FIT_CHOPT_range, 12, _VECTOR_FIT_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_VECTOR_FIT_CHOPT_type };
static KmParInt    _VECTOR_FIT_NP_type = { "0", "20", "0", "20", 0 };
static KmParameter _VECTOR_FIT_NP = { "NP", 2, "Number of parameters", "0",
 (char*)0, 3, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_VECTOR_FIT_NP_type };
static KmParameter _VECTOR_FIT_PAR = { "PAR", 3, "Vector of parameters",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _VECTOR_FIT_STEP = { "STEP", 4, "Vector of steps size",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _VECTOR_FIT_PMIN = { "PMIN", 4, "Vector of lower bounds",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _VECTOR_FIT_PMAX = { "PMAX", 4, "Vector of upper bounds",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _VECTOR_FIT_ERRPAR = { "ERRPAR", 6,
 "Vector of errors on parameters", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_VECTOR_FIT_parameters[] = { &_VECTOR_FIT_X,
 &_VECTOR_FIT_Y, &_VECTOR_FIT_EY, &_VECTOR_FIT_FUNC, &_VECTOR_FIT_CHOPT,
 &_VECTOR_FIT_NP, &_VECTOR_FIT_PAR, &_VECTOR_FIT_STEP, &_VECTOR_FIT_PMIN,
 &_VECTOR_FIT_PMAX, &_VECTOR_FIT_ERRPAR };
static char *_VECTOR_FIT_guidance[] = { "Fit a user defined function",
 "to the points defined by the two vectors X and Y and the vector",
 "of associated errors EY.",
 "See command Histo/Fit for explanation of parameters.",
 "Note that if option 'W' is specified or EY='?' (default),",
 "the array EY is ignored. Option 'L' is not available.",
 "  When option 'Z' is given, FUNC is the user fitting model.",
 "  FUNC is a subroutine with the calling sequence:",
 "      Subroutine FUNC(N,X,Y,EY,NPAR,IFLAG,NPFITS)", "  where",
 "      - X(N),Y(N),EY(N) are the input vectors,",
 "      - NPAR the number of parameters",
 "      - NPFITS is an output parameter = Number of points used in the fit",
 "  The user must declare the common/HCFITD/FITPAD(24),FITFUN in FUNC" };
static KmCommand _VECTOR_FIT = {  (KmCommand*)0, "/VECTOR/FIT", "FIT", 0, 1,
 11, 4, _VECTOR_FIT_parameters, 0, 0, pafitv_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 14, _VECTOR_FIT_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _VECTOR_PLOT_VNAME = { "VNAME", 5, "Vector name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter _VECTOR_PLOT_ID = { "ID", 2, "Histogram Identifier",
 "12345", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
  (void*)0 };
static char *_VECTOR_PLOT_CHOPT_range[] = { "", "C", "S", "+", "B", "L", "P",
 "*" };
static char *_VECTOR_PLOT_CHOPT_text[] = { "Draw an histogram.",
 "Draw a smooth curve.", "Superimpose plot on top of existing picture.",
 "Add contents of ID to last plotted histogram.", "Select Bar chart format.",
 "Connect channels contents by a line.",
 "Draw the current polymarker at each channel.", "Draw a * at each channel." };
static KmParOption _VECTOR_PLOT_CHOPT_type = { _VECTOR_PLOT_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _VECTOR_PLOT_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 8, _VECTOR_PLOT_CHOPT_range, 8, _VECTOR_PLOT_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_VECTOR_PLOT_CHOPT_type };
static KmParameter *_VECTOR_PLOT_parameters[] = { &_VECTOR_PLOT_VNAME,
 &_VECTOR_PLOT_ID, &_VECTOR_PLOT_CHOPT };
static char *_VECTOR_PLOT_guidance[] = {
 "Each element of VNAME is used to fill an histogram",
 "which is automatically booked with 100 channels and then plotted.",
 "If VNAME has the form VNAME1%VNAME2 then a scatter-plot of vector VNAME1",
 "versus VNAME2 is plotted. If ID is given different of 12345, then",
 "a 2-Dim histogram is created with 40 bins by 40 bins and filled.",
 "One can use the command VECTOR/HFILL to fill an already existing",
 "histogram." };
static KmCommand _VECTOR_PLOT = { &_VECTOR_FIT, "/VECTOR/PLOT", "PLOT", 0, 1,
 3, 1, _VECTOR_PLOT_parameters, 0, 0, pavect_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 7, _VECTOR_PLOT_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _VECTOR_HFILL_VNAME = { "VNAME", 5, "Vector name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _VECTOR_HFILL_ID = { "ID", 2, "Histogram Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_VECTOR_HFILL_parameters[] = { &_VECTOR_HFILL_VNAME,
 &_VECTOR_HFILL_ID };
static char *_VECTOR_HFILL_guidance[] = {
 "Fill the existing histogram ID with vector VNAME.",
 "Note that the command VECTOR/PLOT can automatically book, fill and plot",
 "the contents of a vector." };
static KmCommand _VECTOR_HFILL = { &_VECTOR_PLOT, "/VECTOR/HFILL", "HFILL", 0,
 1, 2, 2, _VECTOR_HFILL_parameters, 0, 0, pavect_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _VECTOR_HFILL_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _VECTOR_DRAW_VNAME = { "VNAME", 5, "Vector name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter _VECTOR_DRAW_ID = { "ID", 2, "Histogram Identifier",
 "12345", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
  (void*)0 };
static char *_VECTOR_DRAW_CHOPT_range[] = { "", "C", "S", "+", "B", "L", "P",
 "*" };
static char *_VECTOR_DRAW_CHOPT_text[] = { "Draw an histogram.",
 "Draw a smooth curve.", "Superimpose plot on top of existing picture.",
 "Add contents of ID to last plotted histogram.", "Select Bar chart format.",
 "Connect channels contents by a line.",
 "Draw the current polymarker at each channel.", "Draw a * at each channel." };
static KmParOption _VECTOR_DRAW_CHOPT_type = { _VECTOR_DRAW_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _VECTOR_DRAW_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 8, _VECTOR_DRAW_CHOPT_range, 8, _VECTOR_DRAW_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_VECTOR_DRAW_CHOPT_type };
static KmParameter *_VECTOR_DRAW_parameters[] = { &_VECTOR_DRAW_VNAME,
 &_VECTOR_DRAW_ID, &_VECTOR_DRAW_CHOPT };
static char *_VECTOR_DRAW_guidance[] = {
 "Draw vector VNAME interpreting it as a histogram.",
 "Optionally save the contents in histogram ID." };
static KmCommand _VECTOR_DRAW = { &_VECTOR_HFILL, "/VECTOR/DRAW", "DRAW", 0,
 1, 3, 1, _VECTOR_DRAW_parameters, 0, 0, pavect_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 2, _VECTOR_DRAW_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_KUIP_VERSION_guidance[] = {
 "Print the version string for PAW and the underlying packages." };
static KmCommand _KUIP_VERSION = {  (KmCommand*)0, "/KUIP/VERSION", "VERSION",
 0, 1, 0, 0, (KmParameter**)0, 0, 0, pavercmd_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _KUIP_VERSION_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_KUIP_BUGREPORT_CHOPT_range[] = { "B", "C" };
static char *_KUIP_BUGREPORT_CHOPT_text[] = { "Send a bug report",
 "Send a comment, suggestion, etc." };
static KmParOption _KUIP_BUGREPORT_CHOPT_type = { _KUIP_BUGREPORT_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _KUIP_BUGREPORT_CHOPT = { "CHOPT", 5, "Options", "B",
 (char*)0, 8, 2, _KUIP_BUGREPORT_CHOPT_range, 2, _KUIP_BUGREPORT_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_KUIP_BUGREPORT_CHOPT_type };
static KmParameter *_KUIP_BUGREPORT_parameters[] = { &_KUIP_BUGREPORT_CHOPT };
static char *_KUIP_BUGREPORT_guidance[] = {
 "Email a bug report or comment to the PAW team.",
 "The local editor is invoked with a template to be", "filled out.",
 "After the template has been edited, version information",
 "about PAW and the operating system is appended.",
 "The user is asked for a confirmation before the report is send.", "",
 "In Paw++ this command can be accessed via the 'Help' menu of the",
 "'Executive Window' or the 'Main Browser' (menu item 'Mail Paw++\
 Developers').", "",
 "This command is implemented only on UNIX, VMS and VM systems.", "",
 "If the environment variable PAWSUPPORT is defined it is used as",
 "email adress." };
static KmCommand _KUIP_BUGREPORT = { &_KUIP_VERSION, "/KUIP/BUGREPORT",
 "BUGREPORT", 0, 1, 1, 0, _KUIP_BUGREPORT_parameters, 0, 0, bugreprt_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 14, _KUIP_BUGREPORT_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmMenu _KUIP = {  (KmMenu*)0,  (KmMenu*)0, "/KUIP", "KUIP", 1,
 &_KUIP_BUGREPORT, 0, (char**)0, 0, (char**)0, 0, (char**)0 };

static KmMenu _VECTOR = { &_KUIP,  (KmMenu*)0, "/VECTOR", "VECTOR", 1,
 &_VECTOR_DRAW, 0, (char**)0, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_VECTOR, 950303 );
}


#endif
